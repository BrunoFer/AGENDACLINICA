<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>25.&nbsp;JCA CCI</title><link rel="stylesheet" href="css/manual-multipage.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-integration.html" title="Part&nbsp;VI.&nbsp;Integration"><link rel="prev" href="jmx.html" title="24.&nbsp;JMX"><link rel="next" href="mail.html" title="26.&nbsp;Email"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">25.&nbsp;JCA CCI</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="jmx.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;VI.&nbsp;Integration</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="mail.html">Next</a></td></tr></table><hr></div><div class="chapter" title="25.&nbsp;JCA CCI"><div class="titlepage"><div><div><h2 class="title"><a name="cci"></a>25.&nbsp;JCA CCI</h2></div></div></div>
  

  <div class="section" title="25.1&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-introduction"></a>25.1&nbsp;Introduction</h2></div></div></div>
    

    <p>Java EE provides a specification to standardize access to enterprise
    information systems (EIS): the JCA (J2EE Connector Architecture). This
    specification is divided into several different parts:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p>SPI (Service provider interfaces) that the connector provider
        must implement. These interfaces constitute a resource adapter which
        can be deployed on a Java EE application server. In such a scenario, the
        server manages connection pooling, transaction and security (managed
        mode). The application server is also responsible for managing the
        configuration, which is held outside the client application. A
        connector can be used without an application server as well; in this
        case, the application must configure it directly (non-managed
        mode).</p>
      </li><li class="listitem">
        <p>CCI (Common Client Interface) that an application can use to
        interact with the connector and thus communicate with an EIS. An API
        for local transaction demarcation is provided as well.</p>
      </li></ul></div>

    <p>The aim of the Spring CCI support is to provide classes to access a
    CCI connector in typical Spring style, leveraging the Spring Framework's
    general resource and transaction management facilities.</p>

    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      <p>The client side of connectors doesn't alway use CCI. Some
      connectors expose their own APIs, only providing JCA resource adapter to
      use the system contracts of a Java EE container (connection pooling, global
      transactions, security). Spring does not offer special support for such
      connector-specific APIs.</p>
    </td></tr></table></div>
  </div>

  <div class="section" title="25.2&nbsp;Configuring CCI"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-config"></a>25.2&nbsp;Configuring CCI</h2></div></div></div>
    

    <div class="section" title="25.2.1&nbsp;Connector configuration"><div class="titlepage"><div><div><h3 class="title"><a name="cci-config-connector"></a>25.2.1&nbsp;Connector configuration</h3></div></div></div>
      

      <p>The base resource to use JCA CCI is the
      <code class="interfacename">ConnectionFactory</code> interface. The
      connector used must provide an implementation of this interface.</p>

      <p>To use your connector, you can deploy it on your application
      server and fetch the <code class="interfacename">ConnectionFactory</code>
      from the server's JNDI environment (managed mode). The connector must be
      packaged as a RAR file (resource adapter archive) and contain a
      <code class="filename">ra.xml</code> file to describe its deployment
      characteristics. The actual name of the resource is specified when you
      deploy it. To access it within Spring, simply use Spring's
      <code class="classname">JndiObjectFactoryBean</code> /
      <code class="literal">&lt;jee:jndi-lookup&gt;</code> fetch the factory by its JNDI
      name.</p>

      <p>Another way to use a connector is to embed it in your application
      (non-managed mode), not using an application server to deploy and
      configure it. Spring offers the possibility to configure a connector as
      a bean, through a provided <code class="literal">FactoryBean</code>
      (<code class="classname">LocalConnectionFactoryBean</code>). In this manner, you
      only need the connector library in the classpath (no RAR file and no
      <code class="filename">ra.xml</code> descriptor needed). The library must be
      extracted from the connector's RAR file, if necessary.</p>

      <p>Once you have got access to your
      <code class="interfacename">ConnectionFactory</code> instance, you can
      inject it into your components. These components can either be coded
      against the plain CCI API or leverage Spring's support classes for CCI
      access (e.g. <code class="classname">CciTemplate</code>).</p>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>When you use a connector in non-managed mode, you can't use
        global transactions because the resource is never enlisted / delisted
        in the current global transaction of the current thread. The resource
        is simply not aware of any global Java EE transactions that might be
        running.</p>
      </td></tr></table></div>
    </div>

    <div class="section" title="25.2.2&nbsp;ConnectionFactory configuration in Spring"><div class="titlepage"><div><div><h3 class="title"><a name="cci-config-connectionfactory"></a>25.2.2&nbsp;<code class="interfacename">ConnectionFactory</code> configuration in
      Spring</h3></div></div></div>
      

      <p>In order to make connections to the EIS, you need to obtain a
      <code class="interfacename">ConnectionFactory</code> from the application
      server if you are in a managed mode, or directly from Spring if you are
      in a non-managed mode.</p>

      <p>In a managed mode, you access a
      <code class="interfacename">ConnectionFactory</code> from JNDI; its
      properties will be configured in the application server.</p>

      <pre class="programlisting"><span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"eciConnectionFactory"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"eis/cicseci"</span><span class="hl-tag">/&gt;</span></pre>

      <p>In non-managed mode, you must configure the
      <code class="interfacename">ConnectionFactory</code> you want to use in the
      configuration of Spring as a JavaBean. The
      <code class="classname">LocalConnectionFactoryBean</code> class offers this
      setup style, passing in the
      <code class="classname">ManagedConnectionFactory</code> implementation of your
      connector, exposing the application-level CCI
      <code class="interfacename">ConnectionFactory</code>.</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"eciManagedConnectionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.ibm.connector2.cics.ECIManagedConnectionFactory"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"TXSERIES"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionURL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tcp://localhost/"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portNumber"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2006"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"eciConnectionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.support.LocalConnectionFactoryBean"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"managedConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"eciManagedConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>You can't directly instantiate a specific
        <code class="interfacename">ConnectionFactory</code>. You need to go
        through the corresponding implementation of the
        <code class="classname">ManagedConnectionFactory</code> interface for your
        connector. This interface is part of the JCA SPI specification.</p>
      </td></tr></table></div>
    </div>

    <div class="section" title="25.2.3&nbsp;Configuring CCI connections"><div class="titlepage"><div><div><h3 class="title"><a name="cci-config-cci-connections"></a>25.2.3&nbsp;Configuring CCI connections</h3></div></div></div>
      

      <p>JCA CCI allow the developer to configure the connections to the
      EIS using the <code class="interfacename">ConnectionSpec</code>
      implementation of your connector. In order to configure its properties,
      you need to wrap the target connection factory with a dedicated adapter,
      <code class="classname">ConnectionSpecConnectionFactoryAdapter</code>. So, the
      dedicated <code class="interfacename">ConnectionSpec</code> can be
      configured with the property <code class="literal">connectionSpec</code> (as an
      inner bean).</p>

      <p>This property is not mandatory because the CCI
      <code class="interfacename">ConnectionFactory</code> interface defines two
      different methods to obtain a CCI connection. Some of the
      <code class="interfacename">ConnectionSpec</code> properties can often be
      configured in the application server (in managed mode) or on the
      corresponding local <code class="classname">ManagedConnectionFactory</code>
      implementation.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ConnectionFactory <span class="hl-keyword">implements</span> Serializable, Referenceable {
  ...
  Connection getConnection() <span class="hl-keyword">throws</span> ResourceException;
  Connection getConnection(ConnectionSpec connectionSpec) <span class="hl-keyword">throws</span> ResourceException;
  ...
}</pre>

      <p>Spring provides a
      <code class="classname">ConnectionSpecConnectionFactoryAdapter</code> that
      allows for specifying a <code class="interfacename">ConnectionSpec</code>
      instance to use for all operations on a given factory. If the adapter's
      <code class="literal">connectionSpec</code> property is specified, the adapter
      uses the <code class="literal">getConnection</code> variant with the
      <code class="interfacename">ConnectionSpec</code> argument, otherwise
	  the variant without argument.</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"managedConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionURL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:hsqldb:hsql://localhost:9001"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.hsqldb.jdbcDriver"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"targetConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.support.LocalConnectionFactoryBean"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"managedConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"managedConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"targetConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"targetConnectionFactory"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionSpec"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.sun.connector.cciblackbox.CciConnectionSpec"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sa"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
  <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
    </div>

    <div class="section" title="25.2.4&nbsp;Using a single CCI connection"><div class="titlepage"><div><div><h3 class="title"><a name="cci-config-single-connection"></a>25.2.4&nbsp;Using a single CCI connection</h3></div></div></div>
      

      <p>If you want to use a single CCI connection, Spring provides a
      further <code class="interfacename">ConnectionFactory</code> adapter to
      manage this. The <code class="classname">SingleConnectionFactory</code> adapter
      class will open a single connection lazily and close it when this bean
      is destroyed at application shutdown. This class will expose special
      <code class="interfacename">Connection</code> proxies that behave
      accordingly, all sharing the same underlying physical connection.</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"eciManagedConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"com.ibm.connector2.cics.ECIManagedConnectionFactory"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"TEST"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionURL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tcp://localhost/"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portNumber"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2006"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"targetEciConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.support.LocalConnectionFactoryBean"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"managedConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"eciManagedConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"eciConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.cci.connection.SingleConnectionFactory"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"targetConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"targetEciConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>This <code class="interfacename">ConnectionFactory</code> adapter
        cannot directly be configured with a
        <code class="interfacename">ConnectionSpec</code>. Use an intermediary
        <code class="classname">ConnectionSpecConnectionFactoryAdapter</code> that the
        <code class="classname">SingleConnectionFactory</code> talks to if you require
        a single connection for a specific
        <code class="interfacename">ConnectionSpec</code>.</p>
      </td></tr></table></div>
    </div>
  </div>

  <div class="section" title="25.3&nbsp;Using Spring's CCI access support"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-using"></a>25.3&nbsp;Using Spring's CCI access support</h2></div></div></div>
    

    <div class="section" title="25.3.1&nbsp;Record conversion"><div class="titlepage"><div><div><h3 class="title"><a name="cci-record-creator"></a>25.3.1&nbsp;Record conversion</h3></div></div></div>
      

      <p>One of the aims of the JCA CCI support is to provide convenient
      facilities for manipulating CCI records. The developer can specify the
      strategy to create records and extract datas from records, for use with
      Spring's <code class="classname">CciTemplate</code>. The following interfaces
      will configure the strategy to use input and output records if you don't
      want to work with records directly in your application.</p>

      <p>In order to create an input <code class="interfacename">Record</code>,
      the developer can use a dedicated implementation of the
      <code class="interfacename">RecordCreator</code> interface.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> RecordCreator {

  Record createRecord(RecordFactory recordFactory) <span class="hl-keyword">throws</span> ResourceException, DataAccessException;
}</pre>

      <p>As you can see, the <code class="literal">createRecord(..)</code> method
      receives a <code class="interfacename">RecordFactory</code> instance as
      parameter, which corresponds to the
      <code class="interfacename">RecordFactory</code> of the
      <code class="interfacename">ConnectionFactory</code> used. This reference
      can be used to create <code class="interfacename">IndexedRecord</code> or
      <code class="interfacename">MappedRecord</code> instances. The following
      sample shows how to use the <code class="interfacename">RecordCreator</code>
      interface and indexed/mapped records.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyRecordCreator <span class="hl-keyword">implements</span> RecordCreator {

  <span class="hl-keyword">public</span> Record createRecord(RecordFactory recordFactory) <span class="hl-keyword">throws</span> ResourceException {
    IndexedRecord input = recordFactory.createIndexedRecord(<span class="hl-string">"input"</span>);
    input.add(<span class="hl-keyword">new</span> Integer(id));
    <span class="hl-keyword">return</span> input;
  }
}</pre>

      <p>An output <code class="interfacename">Record</code> can be used to
      receive data back from the EIS. Hence, a specific implementation of the
      <code class="interfacename">RecordExtractor</code> interface can be passed
      to Spring's <code class="classname">CciTemplate</code> for extracting data from
      the output <code class="interfacename">Record</code>.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> RecordExtractor {

  Object extractData(Record record) <span class="hl-keyword">throws</span> ResourceException, SQLException, DataAccessException;
}</pre>

      <p>The following sample shows how to use the
      <code class="interfacename">RecordExtractor</code> interface.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyRecordExtractor <span class="hl-keyword">implements</span> RecordExtractor {

  <span class="hl-keyword">public</span> Object extractData(Record record) <span class="hl-keyword">throws</span> ResourceException {
    CommAreaRecord commAreaRecord = (CommAreaRecord) record;
    String str = <span class="hl-keyword">new</span> String(commAreaRecord.toByteArray());
    String field1 = string.substring(<span class="hl-number">0</span>,<span class="hl-number">6</span>);
    String field2 = string.substring(<span class="hl-number">6</span>,<span class="hl-number">1</span>);
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> OutputObject(Long.parseLong(field1), field2);
  }
}</pre>
    </div>

    <div class="section" title="25.3.2&nbsp;The CciTemplate"><div class="titlepage"><div><div><h3 class="title"><a name="cci-using-template"></a>25.3.2&nbsp;The <code class="classname">CciTemplate</code></h3></div></div></div>
      

      <p>The <code class="classname">CciTemplate</code> is the central class of the
      core CCI support package
      (<code class="literal">org.springframework.jca.cci.core</code>). It simplifies the
      use of CCI since it handles the creation and release of resources. This
      helps to avoid common errors like forgetting to always close the
      connection. It cares for the lifecycle of connection and interaction
      objects, letting application code focus on generating input records from
      application data and extracting application data from output
      records.</p>

      <p>The JCA CCI specification defines two distinct methods to call
      operations on an EIS. The CCI <code class="interfacename">Interaction</code>
      interface provides two execute method signatures:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> javax.resource.cci.Interaction {
  ...
  <span class="hl-keyword">boolean</span> execute(InteractionSpec spec, Record input, Record output) <span class="hl-keyword">throws</span> ResourceException;

  Record execute(InteractionSpec spec, Record input) <span class="hl-keyword">throws</span> ResourceException;
  ...
}</pre>

      <p>Depending on the template method called,
      <code class="classname">CciTemplate</code> will know which
      <code class="literal">execute</code> method to call on the interaction. In any
      case, a correctly initialized
      <code class="interfacename">InteractionSpec</code> instance is
      mandatory.</p>

      <p><code class="literal">CciTemplate.execute(..)</code> can be used in two
      ways:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>With direct <code class="interfacename">Record</code> arguments.
          In this case, you simply need to pass the CCI input record in, and
          the returned object be the corresponding CCI output record.</p>
        </li><li class="listitem">
          <p>With application objects, using record mapping. In this case,
          you need to provide corresponding
          <code class="interfacename">RecordCreator</code> and
          <code class="interfacename">RecordExtractor</code> instances.</p>
        </li></ul></div>

      <p>With the first approach, the following methods of the template
      will be used. These methods directly correspond to those on the
      <code class="interfacename">Interaction</code> interface.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CciTemplate <span class="hl-keyword">implements</span> CciOperations {

  <span class="hl-keyword">public</span> Record execute(InteractionSpec spec, Record inputRecord)
      <span class="hl-keyword">throws</span> DataAccessException { ... }

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> execute(InteractionSpec spec, Record inputRecord, Record outputRecord)
      <span class="hl-keyword">throws</span> DataAccessException { ... }

}</pre>

      <p>With the second approach, we need to specify the record creation
      and record extraction strategies as arguments. The interfaces used are
      those describe in the previous section on record conversion. The
      corresponding <code class="classname">CciTemplate</code> methods are the
      following:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CciTemplate <span class="hl-keyword">implements</span> CciOperations {

  <span class="hl-keyword">public</span> Record execute(InteractionSpec spec, RecordCreator inputCreator)
      <span class="hl-keyword">throws</span> DataAccessException { ... }

  <span class="hl-keyword">public</span> Object execute(InteractionSpec spec, Record inputRecord, RecordExtractor outputExtractor)
      <span class="hl-keyword">throws</span> DataAccessException { ... }

  <span class="hl-keyword">public</span> Object execute(InteractionSpec spec, RecordCreator creator, RecordExtractor extractor)
      <span class="hl-keyword">throws</span> DataAccessException { ... }

}</pre>

      <p>Unless the <code class="literal">outputRecordCreator</code> property is set
      on the template (see the following section), every method will call the
      corresponding <code class="literal">execute</code> method of the CCI
      <code class="interfacename">Interaction</code> with two parameters:
      <code class="interfacename">InteractionSpec</code> and input
      <code class="interfacename">Record</code>, receiving an output
      <code class="interfacename">Record</code> as return value.</p>

      <p><code class="classname">CciTemplate</code> also provides methods to create
      <code class="literal">IndexRecord</code> and <code class="literal">MappedRecord</code>
      outside a <code class="interfacename">RecordCreator</code> implementation,
      through its <code class="literal">createIndexRecord(..)</code> and
      <code class="literal">createMappedRecord(..)</code> methods. This can be used
      within DAO implementations to create
      <code class="interfacename">Record</code> instances to pass into
      corresponding <code class="literal">CciTemplate.execute(..)</code> methods.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CciTemplate <span class="hl-keyword">implements</span> CciOperations {

  <span class="hl-keyword">public</span> IndexedRecord createIndexedRecord(String name) <span class="hl-keyword">throws</span> DataAccessException { ... }

  <span class="hl-keyword">public</span> MappedRecord createMappedRecord(String name) <span class="hl-keyword">throws</span> DataAccessException { ... }

}</pre>
    </div>

    <div class="section" title="25.3.3&nbsp;DAO support"><div class="titlepage"><div><div><h3 class="title"><a name="cci-using-dao"></a>25.3.3&nbsp;DAO support</h3></div></div></div>
      

      <p>Spring's CCI support provides a abstract class for DAOs,
      supporting injection of a
      <code class="interfacename">ConnectionFactory</code> or a
      <code class="classname">CciTemplate</code> instances. The name of the class is
      <code class="classname">CciDaoSupport</code>: It provides simple
      <code class="literal">setConnectionFactory</code> and
      <code class="literal">setCciTemplate</code> methods. Internally, this class will
      create a <code class="classname">CciTemplate</code> instance for a passed-in
      <code class="interfacename">ConnectionFactory</code>, exposing it to
      concrete data access implementations in subclasses.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> CciDaoSupport {

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setConnectionFactory(ConnectionFactory connectionFactory) { ... }
  <span class="hl-keyword">public</span> ConnectionFactory getConnectionFactory() { ... }

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setCciTemplate(CciTemplate cciTemplate) { ... }
  <span class="hl-keyword">public</span> CciTemplate getCciTemplate() { ... }

}</pre>
    </div>

    <div class="section" title="25.3.4&nbsp;Automatic output record generation"><div class="titlepage"><div><div><h3 class="title"><a name="automatic-output-generation"></a>25.3.4&nbsp;Automatic output record generation</h3></div></div></div>
      

      <p>If the connector used only supports the
      <code class="methodname">Interaction.execute(..)</code> method with input and
      output records as parameters (that is, it requires the desired output
      record to be passed in instead of returning an appropriate output
      record), you can set the <code class="literal">outputRecordCreator</code> property
      of the <code class="classname">CciTemplate</code> to automatically generate an
      output record to be filled by the JCA connector when the response is
      received. This record will be then returned to the caller of the
      template.</p>

      <p>This property simply holds an implementation of the
      <code class="interfacename">RecordCreator</code> interface, used for that
      purpose. The <code class="interfacename">RecordCreator</code> interface has
      already been discussed in <a class="xref" href="cci.html#cci-record-creator" title="25.3.1&nbsp;Record conversion">Section&nbsp;25.3.1, &#8220;Record conversion&#8221;</a>. The
      <code class="literal">outputRecordCreator</code> property must be directly
      specified on the <code class="classname">CciTemplate</code>. This could be done
      in the application code like so:</p>

      <pre class="programlisting">cciTemplate.setOutputRecordCreator(<span class="hl-keyword">new</span> EciOutputRecordCreator());</pre>

      <p>Or (recommended) in the Spring configuration, if the
      <code class="classname">CciTemplate</code> is configured as a dedicated bean
      instance:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"eciOutputRecordCreator"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"eci.EciOutputRecordCreator"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"cciTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.cci.core.CciTemplate"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"eciConnectionFactory"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"outputRecordCreator"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"eciOutputRecordCreator"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>As the <code class="classname">CciTemplate</code> class is thread-safe,
        it will usually be configured as a shared instance.</p>
      </td></tr></table></div>
    </div>

    <div class="section" title="25.3.5&nbsp;Summary"><div class="titlepage"><div><div><h3 class="title"><a name="template-summary"></a>25.3.5&nbsp;Summary</h3></div></div></div>
      

      <p>The following table summarizes the mechanisms of the
      <code class="classname">CciTemplate</code> class and the corresponding methods
      called on the CCI <code class="interfacename">Interaction</code>
      interface:</p><div class="table"><a name="cci-interaction-execute-methods"></a><p class="title"><b>Table&nbsp;25.1.&nbsp;Usage of <code class="interfacename">Interaction</code> execute
          methods</b></p><div class="table-contents">
          

          <table summary="Usage of Interaction execute&#xA;          methods" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">CciTemplate method signature</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">CciTemplate outputRecordCreator
                property</th><th style="border-bottom: 0.5pt solid ; " align="center">execute method called on the CCI
                Interaction</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                Record)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">not set</td><td style="border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                Record)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">set</td><td style="border-bottom: 0.5pt solid ; " align="center">boolean execute(InteractionSpec, Record,
                Record)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">void execute(InteractionSpec, Record,
                Record)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">not set</td><td style="border-bottom: 0.5pt solid ; " align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">void execute(InteractionSpec, Record,
                Record)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">set</td><td style="border-bottom: 0.5pt solid ; " align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                RecordCreator)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">not set</td><td style="border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                RecordCreator)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">set</td><td style="border-bottom: 0.5pt solid ; " align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec, Record,
                RecordExtractor)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">not set</td><td style="border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec, Record,
                RecordExtractor)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">set</td><td style="border-bottom: 0.5pt solid ; " align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                RecordCreator, RecordExtractor)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">not set</td><td style="border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td style="border-right: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
                RecordCreator, RecordExtractor)</td><td style="border-right: 0.5pt solid ; " align="center">set</td><td style="" align="center">void execute(InteractionSpec, Record,
                Record)</td></tr></tbody></table>
        </div></div><p><br class="table-break"></p>
    </div>

    <div class="section" title="25.3.6&nbsp;Using a CCI Connection and Interaction directly"><div class="titlepage"><div><div><h3 class="title"><a name="cci-straight"></a>25.3.6&nbsp;Using a CCI <code class="interfacename">Connection</code> and
      <code class="interfacename">Interaction</code> directly</h3></div></div></div>
      

      <p><code class="classname">CciTemplate</code> also offers the possibility to
      work directly with CCI connections and interactions, in the same manner
      as <code class="classname">JdbcTemplate</code> and
      <code class="classname">JmsTemplate</code>. This is useful when you want to
      perform multiple operations on a CCI connection or interaction, for
      example.</p>

      <p>The interface <code class="interfacename">ConnectionCallback</code>
      provides a CCI <code class="interfacename">Connection</code> as argument, in
      order to perform custom operations on it, plus the CCI
      <code class="interfacename">ConnectionFactory</code> which the
      <code class="interfacename">Connection</code> was created with. The latter
      can be useful for example to get an associated
      <code class="interfacename">RecordFactory</code> instance and create
      indexed/mapped records, for example.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ConnectionCallback {

  Object doInConnection(Connection connection, ConnectionFactory connectionFactory)
      <span class="hl-keyword">throws</span> ResourceException, SQLException, DataAccessException;
}</pre>

      <p>The interface <code class="interfacename">InteractionCallback</code>
      provides the CCI <code class="interfacename">Interaction</code>, in order to
      perform custom operations on it, plus the corresponding CCI
      <code class="interfacename">ConnectionFactory</code>.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> InteractionCallback {

  Object doInInteraction(Interaction interaction, ConnectionFactory connectionFactory)
      <span class="hl-keyword">throws</span> ResourceException, SQLException, DataAccessException;
}</pre>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p><code class="interfacename">InteractionSpec</code> objects can
        either be shared across multiple template calls or newly created
        inside every callback method. This is completely up to the DAO
        implementation.</p>
      </td></tr></table></div>
    </div>

    <div class="section" title="25.3.7&nbsp;Example for CciTemplate usage"><div class="titlepage"><div><div><h3 class="title"><a name="cci-template-example"></a>25.3.7&nbsp;Example for <code class="classname">CciTemplate</code> usage</h3></div></div></div>
      

      <p>In this section, the usage of the
      <code class="classname">CciTemplate</code> will be shown to acces to a CICS with
      ECI mode, with the IBM CICS ECI connector.</p>

      <p>Firstly, some initializations on the CCI
      <code class="interfacename">InteractionSpec</code> must be done to specify
      which CICS program to access and how to interact with it.</p>

      <pre class="programlisting">ECIInteractionSpec interactionSpec = <span class="hl-keyword">new</span> ECIInteractionSpec();
interactionSpec.setFunctionName(<span class="hl-string">"MYPROG"</span>);
interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);</pre>

      <p>Then the program can use CCI via Spring's template and specify
      mappings between custom objects and CCI
      <code class="literal">Records</code>.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDaoImpl <span class="hl-keyword">extends</span> CciDaoSupport <span class="hl-keyword">implements</span> MyDao {

  <span class="hl-keyword">public</span> OutputObject getData(InputObject input) {
    ECIInteractionSpec interactionSpec = ...;

    OutputObject output = (ObjectOutput) getCciTemplate().execute(interactionSpec,
        <span class="hl-keyword">new</span> RecordCreator() {
          <span class="hl-keyword">public</span> Record createRecord(RecordFactory recordFactory) <span class="hl-keyword">throws</span> ResourceException {
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CommAreaRecord(input.toString().getBytes());
          }
        },
        <span class="hl-keyword">new</span> RecordExtractor() {
          <span class="hl-keyword">public</span> Object extractData(Record record) <span class="hl-keyword">throws</span> ResourceException {
            CommAreaRecord commAreaRecord = (CommAreaRecord)record;
            String str = <span class="hl-keyword">new</span> String(commAreaRecord.toByteArray());
            String field1 = string.substring(<span class="hl-number">0</span>,<span class="hl-number">6</span>);
            String field2 = string.substring(<span class="hl-number">6</span>,<span class="hl-number">1</span>);
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> OutputObject(Long.parseLong(field1), field2);
          }
        });

    <span class="hl-keyword">return</span> output;
  }
}</pre>

      <p>As discussed previously, callbacks can be used to work directly on
      CCI connections or interactions.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDaoImpl <span class="hl-keyword">extends</span> CciDaoSupport <span class="hl-keyword">implements</span> MyDao {

  <span class="hl-keyword">public</span> OutputObject getData(InputObject input) {
    ObjectOutput output = (ObjectOutput) getCciTemplate().execute(
        <span class="hl-keyword">new</span> ConnectionCallback() {
          <span class="hl-keyword">public</span> Object doInConnection(Connection connection, ConnectionFactory factory)
              <span class="hl-keyword">throws</span> ResourceException {

            <em class="lineannotation"><span class="lineannotation">// do something...</span></em>
          }
        });
    }
    <span class="hl-keyword">return</span> output;
  }
}</pre>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>With a <code class="interfacename">ConnectionCallback</code>, the
        <code class="interfacename">Connection</code> used will be managed and
        closed by the <code class="classname">CciTemplate</code>, but any interactions
        created on the connection must be managed by the callback
        implementation.</p>
      </td></tr></table></div>

      <p>For a more specific callback, you can implement an
      <code class="interfacename">InteractionCallback</code>. The passed-in
      <code class="interfacename">Interaction</code> will be managed and closed by
      the <code class="classname">CciTemplate</code> in this case.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDaoImpl <span class="hl-keyword">extends</span> CciDaoSupport <span class="hl-keyword">implements</span> MyDao {

  <span class="hl-keyword">public</span> String getData(String input) {
    ECIInteractionSpec interactionSpec = ...;

    String output = (String) getCciTemplate().execute(interactionSpec,
        <span class="hl-keyword">new</span> InteractionCallback() {
          <span class="hl-keyword">public</span> Object doInInteraction(Interaction interaction, ConnectionFactory factory)
              <span class="hl-keyword">throws</span> ResourceException {
            Record input = <span class="hl-keyword">new</span> CommAreaRecord(inputString.getBytes());
            Record output = <span class="hl-keyword">new</span> CommAreaRecord();
            interaction.execute(holder.getInteractionSpec(), input, output);
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> String(output.toByteArray());
          }
        });

    <span class="hl-keyword">return</span> output;
  }
}</pre>

      <p>For the examples above, the corresponding configuration of the
      involved Spring beans could look like this in non-managed mode:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"managedConnectionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.ibm.connector2.cics.ECIManagedConnectionFactory"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"TXSERIES"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionURL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"local:"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"CICSUSER"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"CICS"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.support.LocalConnectionFactoryBean"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"managedConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"managedConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"component"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"mypackage.MyDaoImpl"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>In managed mode (that is, in a Java EE environment), the
      configuration could look as follows:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"eis/cicseci"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"component"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"MyDaoImpl"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
    </div>
  </div>

  <div class="section" title="25.4&nbsp;Modeling CCI access as operation objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-object"></a>25.4&nbsp;Modeling CCI access as operation objects</h2></div></div></div>
    

    <p>The <code class="literal">org.springframework.jca.cci.object</code> package
    contains support classes that allow you to access the EIS in a different
    style: through reusable operation objects, analogous to Spring's JDBC
    operation objects (see JDBC chapter). This will usually encapsulate the
    CCI API: an application-level input object will be passed to the operation
    object, so it can construct the input record and then convert the received
    record data to an application-level output object and return it.</p>

    <p><span class="emphasis"><em>Note</em></span>: This approach is internally based on the
    <code class="classname">CciTemplate</code> class and the
    <code class="interfacename">RecordCreator</code> /
    <code class="interfacename">RecordExtractor</code> interfaces, reusing the
    machinery of Spring's core CCI support.</p>

    <div class="section" title="25.4.1&nbsp;MappingRecordOperation"><div class="titlepage"><div><div><h3 class="title"><a name="cci-object-mapping-record"></a>25.4.1&nbsp;<code class="classname">MappingRecordOperation</code></h3></div></div></div>
      

      <p><code class="classname">MappingRecordOperation</code> essentially performs
      the same work as <code class="classname">CciTemplate</code>, but represents a
      specific, pre-configured operation as an object. It provides two
      template methods to specify how to convert an input object to a input
      record, and how to convert an output record to an output object (record
      mapping):</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><code class="literal">createInputRecord(..)</code> to specify how to
          convert an input object to an input
          <code class="interfacename">Record</code></p>
        </li><li class="listitem">
          <p><code class="literal">extractOutputData(..)</code> to specify how to
          extract an output object from an output
          <code class="interfacename">Record</code></p>
        </li></ul></div>

      <p>Here are the signatures of these methods:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> MappingRecordOperation <span class="hl-keyword">extends</span> EisOperation {
  ...
  <span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> Record createInputRecord(RecordFactory recordFactory, Object inputObject)
      <span class="hl-keyword">throws</span> ResourceException, DataAccessException { ... }

  <span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> Object extractOutputData(Record outputRecord)
      <span class="hl-keyword">throws</span> ResourceException, SQLException, DataAccessException { ... }
  ...
}</pre>

      <p>Thereafter, in order to execute an EIS operation, you need to use
      a single execute method, passing in an application-level input object
      and receiving an application-level output object as result:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> MappingRecordOperation <span class="hl-keyword">extends</span> EisOperation {
  ...
  <span class="hl-keyword">public</span> Object execute(Object inputObject) <span class="hl-keyword">throws</span> DataAccessException {
  ...
}</pre>

      <p>As you can see, contrary to the <code class="classname">CciTemplate</code>
      class, this <code class="methodname">execute(..)</code> method does not have an
      <code class="interfacename">InteractionSpec</code> as argument. Instead, the
      <code class="interfacename">InteractionSpec</code> is global to the
      operation. The following constructor must be used to instantiate an
      operation object with a specific
      <code class="interfacename">InteractionSpec</code>:</p>

      <pre class="programlisting">InteractionSpec spec = ...;
MyMappingRecordOperation eisOperation = <span class="hl-keyword">new</span> MyMappingRecordOperation(getConnectionFactory(), spec);
...</pre>
    </div>

    <div class="section" title="25.4.2&nbsp;MappingCommAreaOperation"><div class="titlepage"><div><div><h3 class="title"><a name="cci-object-mapping-comm-area"></a>25.4.2&nbsp;<code class="classname">MappingCommAreaOperation</code></h3></div></div></div>
      

      <p>Some connectors use records based on a COMMAREA which represents
      an array of bytes containing parameters to send to the EIS and data
      returned by it. Spring provides a special operation class for working
      directly on COMMAREA rather than on records. The
      <code class="classname">MappingCommAreaOperation</code> class extends the
      <code class="classname">MappingRecordOperation</code> class to provide such
      special COMMAREA support. It implicitly uses the
      <code class="classname">CommAreaRecord</code> class as input and output record
      type, and provides two new methods to convert an input object into an
      input COMMAREA and the output COMMAREA into an output object.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> MappingCommAreaOperation <span class="hl-keyword">extends</span> MappingRecordOperation {
  ...
  <span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">byte</span>[] objectToBytes(Object inObject)
      <span class="hl-keyword">throws</span> IOException, DataAccessException;

  <span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> Object bytesToObject(<span class="hl-keyword">byte</span>[] bytes)
      <span class="hl-keyword">throws</span> IOException, DataAccessException;
  ...
}</pre>
    </div>

    <div class="section" title="25.4.3&nbsp;Automatic output record generation"><div class="titlepage"><div><div><h3 class="title"><a name="cci-automatic-record-gen"></a>25.4.3&nbsp;Automatic output record generation</h3></div></div></div>
      

      <p>As every <code class="classname">MappingRecordOperation</code> subclass is
      based on CciTemplate internally, the same way to automatically generate
      output records as with <code class="classname">CciTemplate</code> is available.
      Every operation object provides a corresponding
      <code class="literal">setOutputRecordCreator(..)</code> method. For further
      information, see <a class="xref" href="cci.html#automatic-output-generation" title="25.3.4&nbsp;Automatic output record generation">Section&nbsp;25.3.4, &#8220;Automatic output record generation&#8221;</a>.</p>
    </div>

    <div class="section" title="25.4.4&nbsp;Summary"><div class="titlepage"><div><div><h3 class="title"><a name="cci-object-summary"></a>25.4.4&nbsp;Summary</h3></div></div></div>
      

      <p>The operation object approach uses records in the same manner as
      the <code class="classname">CciTemplate</code> class.</p>

      <div class="table"><a name="cci-interaction-methods"></a><p class="title"><b>Table&nbsp;25.2.&nbsp;Usage of Interaction execute methods</b></p><div class="table-contents">
        

        <table summary="Usage of Interaction execute methods" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center"><code class="classname">MappingRecordOperation</code>
              method signature</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center"><code class="classname">MappingRecordOperation</code>
              <code class="literal">outputRecordCreator</code> property</th><th style="border-bottom: 0.5pt solid ; " align="center">execute method called on the CCI
              <code class="interfacename">Interaction</code></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Object execute(Object)</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">not set</td><td style="border-bottom: 0.5pt solid ; " align="center">Record execute(InteractionSpec,
              Record)</td></tr><tr><td style="border-right: 0.5pt solid ; " align="center">Object execute(Object)</td><td style="border-right: 0.5pt solid ; " align="center">set</td><td style="" align="center">boolean execute(InteractionSpec, Record,
              Record)</td></tr></tbody></table>
      </div></div><br class="table-break">
    </div>

    <div class="section" title="25.4.5&nbsp;Example for MappingRecordOperation usage"><div class="titlepage"><div><div><h3 class="title"><a name="cci-objects-mappring-record-example"></a>25.4.5&nbsp;Example for <code class="classname">MappingRecordOperation</code>
      usage</h3></div></div></div>
      

      <p>In this section, the usage of the
      <code class="classname">MappingRecordOperation</code> will be shown to access a
      database with the Blackbox CCI connector.</p>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>The original version of this connector is provided by the Java EE
        SDK (version 1.3), available from Sun.</p>
      </td></tr></table></div>

      <p>Firstly, some initializations on the CCI
      <code class="interfacename">InteractionSpec</code> must be done to specify
      which SQL request to execute. In this sample, we directly define the way
      to convert the parameters of the request to a CCI record and the way to
      convert the CCI result record to an instance of the
      <code class="classname">Person</code> class.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PersonMappingOperation <span class="hl-keyword">extends</span> MappingRecordOperation {

  <span class="hl-keyword">public</span> PersonMappingOperation(ConnectionFactory connectionFactory) {
    setConnectionFactory(connectionFactory);
    CciInteractionSpec interactionSpec = <span class="hl-keyword">new</span> CciConnectionSpec();
    interactionSpec.setSql(<span class="hl-string">"select * from person where person_id=?"</span>);
    setInteractionSpec(interactionSpec);
  }

  <span class="hl-keyword">protected</span> Record createInputRecord(RecordFactory recordFactory, Object inputObject)
      <span class="hl-keyword">throws</span> ResourceException {
    Integer id = (Integer) inputObject;
    IndexedRecord input = recordFactory.createIndexedRecord(<span class="hl-string">"input"</span>);
    input.add(<span class="hl-keyword">new</span> Integer(id));
    <span class="hl-keyword">return</span> input;
  }

  <span class="hl-keyword">protected</span> Object extractOutputData(Record outputRecord)
      <span class="hl-keyword">throws</span> ResourceException, SQLException {
    ResultSet rs = (ResultSet) outputRecord;
    Person person = null;
    <span class="hl-keyword">if</span> (rs.next()) {
      Person person = <span class="hl-keyword">new</span> Person();
      person.setId(rs.getInt(<span class="hl-string">"person_id"</span>));
      person.setLastName(rs.getString(<span class="hl-string">"person_last_name"</span>));
      person.setFirstName(rs.getString(<span class="hl-string">"person_first_name"</span>));
    }
    <span class="hl-keyword">return</span> person;
  }
}</pre>

      <p>Then the application can execute the operation object, with the
      person identifier as argument. Note that operation object could be set
      up as shared instance, as it is thread-safe.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDaoImpl <span class="hl-keyword">extends</span> CciDaoSupport <span class="hl-keyword">implements</span> MyDao {

  <span class="hl-keyword">public</span> Person getPerson(<span class="hl-keyword">int</span> id) {
    PersonMappingOperation query = <span class="hl-keyword">new</span> PersonMappingOperation(getConnectionFactory());
    Person person = (Person) query.execute(<span class="hl-keyword">new</span> Integer(id));
    <span class="hl-keyword">return</span> person;
  }
}</pre>

      <p>The corresponding configuration of Spring beans could look as
      follows in non-managed mode:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"managedConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionURL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:hsqldb:hsql://localhost:9001"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.hsqldb.jdbcDriver"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"targetConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.support.LocalConnectionFactoryBean"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"managedConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"managedConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"targetConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"targetConnectionFactory"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionSpec"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.sun.connector.cciblackbox.CciConnectionSpec"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sa"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
  <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"component"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"MyDaoImpl"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>In managed mode (that is, in a Java EE environment), the
      configuration could look as follows:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"targetConnectionFactory"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"eis/blackbox"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"targetConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"targetConnectionFactory"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionSpec"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.sun.connector.cciblackbox.CciConnectionSpec"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sa"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
  <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"component"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"MyDaoImpl"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
    </div>

    <div class="section" title="25.4.6&nbsp;Example for MappingCommAreaOperation usage"><div class="titlepage"><div><div><h3 class="title"><a name="cci-objects-mapping-comm-area-example"></a>25.4.6&nbsp;Example for <code class="classname">MappingCommAreaOperation</code>
      usage</h3></div></div></div>
      

      <p>In this section, the usage of the
      <code class="classname">MappingCommAreaOperation</code> will be shown: accessing
      a CICS with ECI mode with the IBM CICS ECI connector.</p>

      <p>Firstly, the CCI <code class="interfacename">InteractionSpec</code>
      needs to be initialized to specify which CICS program to access and how
      to interact with it.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> EciMappingOperation <span class="hl-keyword">extends</span> MappingCommAreaOperation {

  <span class="hl-keyword">public</span> EciMappingOperation(ConnectionFactory connectionFactory, String programName) {
    setConnectionFactory(connectionFactory);
    ECIInteractionSpec interactionSpec = <span class="hl-keyword">new</span> ECIInteractionSpec(),
    interactionSpec.setFunctionName(programName);
    interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);
    interactionSpec.setCommareaLength(<span class="hl-number">30</span>);
    setInteractionSpec(interactionSpec);
    setOutputRecordCreator(<span class="hl-keyword">new</span> EciOutputRecordCreator());
  }

  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> EciOutputRecordCreator <span class="hl-keyword">implements</span> RecordCreator {
    <span class="hl-keyword">public</span> Record createRecord(RecordFactory recordFactory) <span class="hl-keyword">throws</span> ResourceException {
      <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CommAreaRecord();
    }
  }
}</pre>

      <p>The abstract <code class="classname">EciMappingOperation</code> class can
      then be subclassed to specify mappings between custom objects and
      <code class="literal">Records</code>.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDaoImpl <span class="hl-keyword">extends</span> CciDaoSupport <span class="hl-keyword">implements</span> MyDao {

  <span class="hl-keyword">public</span> OutputObject getData(Integer id) {
    EciMappingOperation query = <span class="hl-keyword">new</span> EciMappingOperation(getConnectionFactory(), <span class="hl-string">"MYPROG"</span>) {
      <span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">byte</span>[] objectToBytes(Object inObject) <span class="hl-keyword">throws</span> IOException {
        Integer id = (Integer) inObject;
        <span class="hl-keyword">return</span> String.valueOf(id);
      }
      <span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> Object bytesToObject(<span class="hl-keyword">byte</span>[] bytes) <span class="hl-keyword">throws</span> IOException;
        String str = <span class="hl-keyword">new</span> String(bytes);
        String field1 = str.substring(<span class="hl-number">0</span>,<span class="hl-number">6</span>);
        String field2 = str.substring(<span class="hl-number">6</span>,<span class="hl-number">1</span>);
        String field3 = str.substring(<span class="hl-number">7</span>,<span class="hl-number">1</span>);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> OutputObject(field1, field2, field3);
      }
    });

    <span class="hl-keyword">return</span> (OutputObject) query.execute(<span class="hl-keyword">new</span> Integer(id));
  }
}</pre>

      <p>The corresponding configuration of Spring beans could look as
      follows in non-managed mode:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"managedConnectionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.ibm.connector2.cics.ECIManagedConnectionFactory"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"TXSERIES"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionURL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"local:"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"CICSUSER"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"CICS"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.support.LocalConnectionFactoryBean"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"managedConnectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"managedConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"component"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"MyDaoImpl"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>In managed mode (that is, in a Java EE environment), the
      configuration could look as follows:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"eis/cicseci"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"component"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"MyDaoImpl"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
    </div>
  </div>

  <div class="section" title="25.5&nbsp;Transactions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-tx"></a>25.5&nbsp;Transactions</h2></div></div></div>
    

    <p>JCA specifies several levels of transaction support for resource
    adapters. The kind of transactions that your resource adapter supports is
    specified in its <code class="filename">ra.xml</code> file. There are essentially
    three options: none (for example with CICS EPI connector), local
    transactions (for example with a CICS ECI connector), global transactions
    (for example with an IMS connector).</p>

    <pre class="programlisting"><span class="hl-tag">&lt;connector&gt;</span>

  <span class="hl-tag">&lt;resourceadapter&gt;</span>

    <em class="lineannotation"><span class="lineannotation">&lt;!-- &lt;transaction-support&gt;NoTransaction&lt;/transaction-support&gt; --&gt;</span></em>
    <em class="lineannotation"><span class="lineannotation">&lt;!-- &lt;transaction-support&gt;LocalTransaction&lt;/transaction-support&gt; --&gt;</span></em>
    <span class="hl-tag">&lt;transaction-support&gt;</span>XATransaction<span class="hl-tag">&lt;/transaction-support&gt;</span>

  <span class="hl-tag">&lt;resourceadapter&gt;</span>

<span class="hl-tag">&lt;connector&gt;</span></pre>

    <p>For global transactions, you can use Spring's generic transaction
    infrastructure to demarcate transactions, with
    <code class="classname">JtaTransactionManager</code> as backend (delegating to the
    Java EE server's distributed transaction coordinator underneath).</p>

    <p>For local transactions on a single CCI
    <code class="interfacename">ConnectionFactory</code>, Spring provides a
    specific transaction management strategy for CCI, analogous to the
    <code class="classname">DataSourceTransactionManager</code> for JDBC. The CCI API
    defines a local transaction object and corresponding local transaction
    demarcation methods. Spring's
    <code class="classname">CciLocalTransactionManager</code> executes such local CCI
    transactions, fully compliant with Spring's generic
    <code class="interfacename">PlatformTransactionManager</code>
    abstraction.</p>

    <pre class="programlisting"><span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"eciConnectionFactory"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"eis/cicseci"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"eciTransactionManager"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.cci.connection.CciLocalTransactionManager"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"eciConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

    <p>Both transaction strategies can be used with any of Spring's
    transaction demarcation facilities, be it declarative or programmatic.
    This is a consequence of Spring's generic
    <code class="interfacename">PlatformTransactionManager</code> abstraction,
    which decouples transaction demarcation from the actual execution
    strategy. Simply switch between
    <code class="classname">JtaTransactionManager</code> and
    <code class="classname">CciLocalTransactionManager</code> as needed, keeping your
    transaction demarcation as-is.</p>

    <p>For more information on Spring's transaction facilities, see the
    chapter entitled <a class="xref" href="transaction.html" title="12.&nbsp;Transaction Management">Chapter&nbsp;12, <i>Transaction Management</i></a>.</p>
  </div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="jmx.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="mail.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">24.&nbsp;JMX&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;26.&nbsp;Email</td></tr></table></div></body></html>