<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>7.&nbsp;Validation, Data Binding, and Type Conversion</title><link rel="stylesheet" href="css/manual-multipage.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-core.html" title="Part&nbsp;III.&nbsp;Core Technologies"><link rel="prev" href="resources.html" title="6.&nbsp;Resources"><link rel="next" href="expressions.html" title="8.&nbsp;Spring Expression Language (SpEL)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.&nbsp;Validation, Data Binding, and Type Conversion</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="resources.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;III.&nbsp;Core Technologies</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="expressions.html">Next</a></td></tr></table><hr></div><div class="chapter" title="7.&nbsp;Validation, Data Binding, and Type Conversion"><div class="titlepage"><div><div><h2 class="title"><a name="validation"></a>7.&nbsp;Validation, Data Binding, and Type Conversion</h2></div></div></div>
  

  <div class="section" title="7.1&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-introduction"></a>7.1&nbsp;Introduction</h2></div></div></div>
    

    <div class="sidebar" title="JSR-303 Bean Validation"><a name="validation-beanvalidation-vs-spring-validation"></a><p class="title"><b>JSR-303 Bean Validation</b></p>
      

      <p>The Spring Framework supports JSR-303 Bean Validation adapting
      it to Spring's <code class="interfacename">Validator</code> interface.</p>

      <p>An application can choose to enable JSR-303 Bean Validation once globally,
      as described in <a class="xref" href="validation.html#validation-beanvalidation" title="7.8&nbsp;Spring 3 Validation">Section&nbsp;7.8, &#8220;Spring 3 Validation&#8221;</a>, and use it
      exclusively for all validation needs.</p>

      <p>An application can also register
      additional Spring <code class="interfacename">Validator</code> instances
      per <code class="classname">DataBinder</code> instance, as described in
      <a class="xref" href="validation.html#validation-binder" title="7.8.3&nbsp;Configuring a DataBinder">Section&nbsp;7.8.3, &#8220;Configuring a DataBinder&#8221;</a>. This may be useful for
      plugging in validation logic without the use of annotations.</p>

    </div>

    <p>There are pros and cons for considering validation as business logic,
      and Spring offers a design for validation (and data binding) that does not
      exclude either one of them. Specifically validation should not be tied to
      the web tier, should be easy to localize and it should be possible to plug
      in any validator available. Considering the above, Spring has come up with
      a <code class="interfacename">Validator</code> interface that is both basic
      ands eminently usable in every layer of an application. </p>

    <p>Data binding is useful for allowing user input to be dynamically bound
      to the domain model of an application (or whatever objects you use to
      process user input). Spring provides the so-called
      <code class="interfacename">DataBinder</code> to do exactly that. The
      <code class="interfacename">Validator</code> and the
      <code class="interfacename">DataBinder</code> make up the
      <code class="literal">validation</code> package, which is primarily used in but not
      limited to the MVC framework. </p>

    <p>The <code class="interfacename">BeanWrapper</code> is a fundamental
      concept in the Spring Framework and is used in a lot of places. However,
      you probably will not have the need to use the
      <code class="interfacename">BeanWrapper</code> directly. Because this is
      reference documentation however, we felt that some explanation might be in
      order. We will explain the <code class="interfacename">BeanWrapper</code> in
      this chapter since, if you were going to use it at all, you would most
      likely do so when trying to bind data to objects.</p>

    <p>Spring's DataBinder and the lower-level BeanWrapper both use
      PropertyEditors to parse and format property values. The
      <code class="interfacename">PropertyEditor</code> concept is part of the
      JavaBeans specification, and is also explained in this chapter. Spring 3
      introduces a "core.convert" package that provides a general type
      conversion facility, as well as a higher-level "format" package for
      formatting UI field values. These new packages may be used as simpler
      alternatives to PropertyEditors, and will also be discussed in this
      chapter.</p>
  </div>

  <div class="section" title="7.2&nbsp;Validation using Spring's Validator interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validator"></a>7.2&nbsp;Validation using Spring's <code class="interfacename">Validator</code>
      interface</h2></div></div></div>
    

    <p>Spring features a <code class="interfacename">Validator</code> interface
      that you can use to validate objects. The
      <code class="interfacename">Validator</code> interface works using an
      <code class="interfacename">Errors</code> object so that while validating,
      validators can report validation failures to the
      <code class="interfacename">Errors</code> object.</p>

    <p>Let's consider a small data object:</p>

    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

  <span class="hl-keyword">private</span> String name;
  <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> age;

  <em class="lineannotation"><span class="lineannotation">// the usual getters and setters...</span></em>
}</pre>

    <p>We're going to provide validation behavior for the
      <code class="classname">Person</code> class by implementing the following two
      methods of the
      <code class="interfacename">org.springframework.validation.Validator</code>
      interface: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
        <p><code class="methodname">supports(Class)</code> - Can this
          <code class="interfacename">Validator</code> validate instances of the
          supplied <code class="classname">Class</code>?</p>
      </li><li class="listitem">
        <p><code class="methodname">validate(Object,
          org.springframework.validation.Errors)</code> - validates the
          given object and in case of validation errors, registers those with
          the given <code class="interfacename">Errors</code> object</p>
      </li></ul></div><p> </p>

    <p> Implementing a <code class="interfacename">Validator</code> is fairly
      straightforward, especially when you know of the
      <code class="classname">ValidationUtils</code> helper class that the Spring
      Framework also provides.</p>

    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PersonValidator <span class="hl-keyword">implements</span> Validator {

    <em class="lineannotation"><span class="lineannotation">/**
    * This Validator validates *just* Person instances
    */</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> supports(Class clazz) {
        <span class="hl-keyword">return</span> Person.<span class="hl-keyword">class</span>.equals(clazz);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, <span class="hl-string">"name"</span>, <span class="hl-string">"name.empty"</span>);
        Person p = (Person) obj;
        <span class="hl-keyword">if</span> (p.getAge() &lt; <span class="hl-number">0</span>) {
            e.rejectValue(<span class="hl-string">"age"</span>, <span class="hl-string">"negativevalue"</span>);
        } <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (p.getAge() &gt; <span class="hl-number">110</span>) {
            e.rejectValue(<span class="hl-string">"age"</span>, <span class="hl-string">"too.darn.old"</span>);
        }
    }
}</pre>

    <p>As you can see, the <code class="literal">static</code>
      <code class="methodname">rejectIfEmpty(..)</code> method on the
      <code class="classname">ValidationUtils</code> class is used to reject the
      <code class="literal">'name'</code> property if it is <code class="literal">null</code> or the
      empty string. Have a look at the Javadoc for the
      <code class="classname">ValidationUtils</code> class to see what functionality it
      provides besides the example shown previously.</p>

    <p>While it is certainly possible to implement a single
      <code class="interfacename">Validator</code> class to validate each of the
      nested objects in a rich object, it may be better to encapsulate the
      validation logic for each nested class of object in its own
      <code class="interfacename">Validator</code> implementation. A simple example
      of a <span class="emphasis"><em>'rich'</em></span> object would be a
      <code class="classname">Customer</code> that is composed of two
      <code class="classname">String</code> properties (a first and second name) and a
      complex <code class="classname">Address</code> object.
      <code class="classname">Address</code> objects may be used independently of
      <code class="classname">Customer</code> objects, and so a distinct
      <code class="classname">AddressValidator</code> has been implemented. If you want
      your <code class="classname">CustomerValidator</code> to reuse the logic contained
      within the <code class="classname">AddressValidator</code> class without resorting
      to copy-and-paste, you can dependency-inject or instantiate an
      <code class="classname">AddressValidator</code> within your
      <code class="classname">CustomerValidator</code>, and use it like so:</p>

    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomerValidator <span class="hl-keyword">implements</span> Validator {

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> Validator addressValidator;

    <span class="hl-keyword">public</span> CustomerValidator(Validator addressValidator) {
        <span class="hl-keyword">if</span> (addressValidator == null) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(
              <span class="hl-string">"The supplied [Validator] is required and must not be null."</span>);
        }
        <span class="hl-keyword">if</span> (!addressValidator.supports(Address.<span class="hl-keyword">class</span>)) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(
              <span class="hl-string">"The supplied [Validator] must support the validation of [Address] instances."</span>);
        }
        <span class="hl-keyword">this</span>.addressValidator = addressValidator;
    }

    <em class="lineannotation"><span class="lineannotation">/**
    * This Validator validates Customer instances, and any subclasses of Customer too
    */</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> supports(Class clazz) {
        <span class="hl-keyword">return</span> Customer.<span class="hl-keyword">class</span>.isAssignableFrom(clazz);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="hl-string">"firstName"</span>, <span class="hl-string">"field.required"</span>);
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="hl-string">"surname"</span>, <span class="hl-string">"field.required"</span>);
        Customer customer = (Customer) target;
        <span class="hl-keyword">try</span> {
            errors.pushNestedPath(<span class="hl-string">"address"</span>);
            ValidationUtils.invokeValidator(<span class="hl-keyword">this</span>.addressValidator, customer.getAddress(), errors);
        } <span class="hl-keyword">finally</span> {
            errors.popNestedPath();
        }
    }
}</pre>

    <p>Validation errors are reported to the
      <code class="interfacename">Errors</code> object passed to the validator. In
      case of Spring Web MVC you can use <code class="literal">&lt;spring:bind/&gt;</code>
      tag to inspect the error messages, but of course you can also inspect the
      errors object yourself. More information about the methods it offers can
      be found from the Javadoc.</p>
  </div>

  <div class="section" title="7.3&nbsp;Resolving codes to error messages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-conversion"></a>7.3&nbsp;Resolving codes to error messages</h2></div></div></div>
    

    <p>We've talked about databinding and validation. Outputting messages
      corresponding to validation errors is the last thing we need to discuss.
      In the example we've shown above, we rejected the <code class="literal">name</code>
      and the <code class="literal">age</code> field. If we're going to output the error
      messages by using a <code class="interfacename">MessageSource</code>, we will
      do so using the error code we've given when rejecting the field ('name'
      and 'age' in this case). When you call (either directly, or indirectly,
      using for example the <code class="classname">ValidationUtils</code> class)
      <code class="literal">rejectValue</code> or one of the other
      <code class="literal">reject</code> methods from the
      <code class="interfacename">Errors</code> interface, the underlying
      implementation will not only register the code you've passed in, but also
      a number of additional error codes. What error codes it registers is
      determined by the <code class="interfacename">MessageCodesResolver</code> that
      is used. By default, the
      <code class="classname">DefaultMessageCodesResolver</code> is used, which for
      example not only registers a message with the code you gave, but also
      messages that include the field name you passed to the reject method. So
      in case you reject a field using <code class="literal">rejectValue("age",
      "too.darn.old")</code>, apart from the <code class="literal">too.darn.old</code>
      code, Spring will also register <code class="literal">too.darn.old.age</code> and
      <code class="literal">too.darn.old.age.int</code> (so the first will include the
      field name and the second will include the type of the field); this is
      done as a convenience to aid developers in targeting error messages and
      suchlike.</p>

    <p>More information on the
      <code class="interfacename">MessageCodesResolver</code> and the default
      strategy can be found online with the Javadocs for <a class="ulink" href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/validation/MessageCodesResolver.html" target="_top">MessageCodesResolver</a> and <a class="ulink" href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html" target="_top">DefaultMessageCodesResolver</a> respectively.</p>
  </div>

  <div class="section" title="7.4&nbsp;Bean manipulation and the BeanWrapper"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beans"></a>7.4&nbsp;Bean manipulation and the
      <code class="interfacename">BeanWrapper</code></h2></div></div></div>
    

    <p>The <code class="literal">org.springframework.beans</code> package adheres to
      the JavaBeans standard provided by Sun. A JavaBean is simply a class with
      a default no-argument constructor, which follows a naming convention where
      (by way of an example) a property named <code class="literal">bingoMadness</code>
      would have a setter method <code class="methodname">setBingoMadness(..)</code>
      and a getter method <code class="methodname">getBingoMadness()</code>. For more
      information about JavaBeans and the specification, please refer to Sun's
      website ( <a class="ulink" href="http://java.sun.com/products/javabeans/" target="_top">java.sun.com/products/javabeans</a>).</p>

    <p>One quite important class in the beans package is the
      <code class="interfacename">BeanWrapper</code> interface and its corresponding
      implementation (<code class="classname">BeanWrapperImpl</code>). As quoted from
      the Javadoc, the <code class="interfacename">BeanWrapper</code> offers
      functionality to set and get property values (individually or in bulk),
      get property descriptors, and to query properties to determine if they are
      readable or writable. Also, the <code class="interfacename">BeanWrapper</code>
      offers support for nested properties, enabling the setting of properties
      on sub-properties to an unlimited depth. Then, the
      <code class="interfacename">BeanWrapper</code> supports the ability to add
      standard JavaBeans <code class="interfacename">PropertyChangeListeners</code>
      and <code class="interfacename">VetoableChangeListeners</code>, without the
      need for supporting code in the target class. Last but not least, the
      <code class="interfacename">BeanWrapper</code> provides support for the
      setting of indexed properties. The
      <code class="interfacename">BeanWrapper</code> usually isn't used by
      application code directly, but by the
      <code class="interfacename">DataBinder</code> and the
      <code class="interfacename">BeanFactory</code>.</p>

    <p>The way the <code class="interfacename">BeanWrapper</code> works is partly
      indicated by its name: <span class="emphasis"><em>it wraps a bean</em></span> to perform
      actions on that bean, like setting and retrieving properties.</p>

    <div class="section" title="7.4.1&nbsp;Setting and getting basic and nested properties"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conventions"></a>7.4.1&nbsp;Setting and getting basic and nested properties</h3></div></div></div>
      

      <p>Setting and getting properties is done using the
        <code class="literal">setPropertyValue(s)</code> and
        <code class="literal">getPropertyValue(s)</code> methods that both come with a
        couple of overloaded variants. They're all described in more detail in
        the Javadoc Spring comes with. What's important to know is that there
        are a couple of conventions for indicating properties of an object. A
        couple of examples:</p>

      <div class="table"><a name="beans-beans-conventions-properties-tbl"></a><p class="title"><b>Table&nbsp;7.1.&nbsp;Examples of properties</b></p><div class="table-contents">
        

        <table summary="Examples of properties" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Expression</th><th style="border-bottom: 0.5pt solid ; ">Explanation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">name</code></td><td style="border-bottom: 0.5pt solid ; ">Indicates the property <code class="literal">name</code>
                corresponding to the methods <code class="methodname">getName()</code>
                or <code class="methodname">isName()</code> and
                <code class="methodname">setName(..)</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">account.name</code></td><td style="border-bottom: 0.5pt solid ; ">Indicates the nested property <code class="literal">name</code> of
                the property <code class="literal">account</code> corresponding e.g. to
                the methods <code class="literal">getAccount().setName()</code> or
                <code class="literal">getAccount().getName()</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">account[2]</code></td><td style="border-bottom: 0.5pt solid ; ">Indicates the <span class="emphasis"><em>third</em></span> element of the
                indexed property <code class="literal">account</code>. Indexed properties
                can be of type <code class="literal">array</code>, <code class="literal">list</code>
                or other <span class="emphasis"><em>naturally ordered</em></span>
                collection</td></tr><tr><td style="border-right: 0.5pt solid ; "><code class="literal">account[COMPANYNAME]</code></td><td style="">Indicates the value of the map entry indexed by the key
                <span class="emphasis"><em>COMPANYNAME</em></span> of the Map property
                <code class="literal">account</code></td></tr></tbody></table>
      </div></div><br class="table-break">

      <p>Below you'll find some examples of working with the
        <code class="interfacename">BeanWrapper</code> to get and set
        properties.</p>

      <p><span class="emphasis"><em>(This next section is not vitally important to you if
        you're not planning to work with the
        <code class="interfacename">BeanWrapper</code> directly. If you're just
        using the <code class="interfacename">DataBinder</code> and the
        <code class="interfacename">BeanFactory</code> and their out-of-the-box
        implementation, you should skip ahead to the section about
        <code class="interfacename">PropertyEditors</code>.)</em></span></p>

      <p>Consider the following two classes:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Company {
    <span class="hl-keyword">private</span> String name;
    <span class="hl-keyword">private</span> Employee managingDirector;

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.name;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        <span class="hl-keyword">this</span>.name = name;
    }
    <span class="hl-keyword">public</span> Employee getManagingDirector() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.managingDirector;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setManagingDirector(Employee managingDirector) {
        <span class="hl-keyword">this</span>.managingDirector = managingDirector;
    }
}</pre>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Employee {
    <span class="hl-keyword">private</span> String name;
    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span> salary;

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.name;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        <span class="hl-keyword">this</span>.name = name;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getSalary() {
        <span class="hl-keyword">return</span> salary;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSalary(<span class="hl-keyword">float</span> salary) {
        <span class="hl-keyword">this</span>.salary = salary;
    }
}</pre>

      <p>The following code snippets show some examples of how to retrieve
        and manipulate some of the properties of instantiated
        <code class="literal">Companies</code> and <code class="literal">Employees</code>:</p>

      <pre class="programlisting">BeanWrapper company = BeanWrapperImpl(<span class="hl-keyword">new</span> Company());
<em class="lineannotation"><span class="lineannotation">// setting the company name..</span></em>
company.setPropertyValue(<span class="hl-string">"name"</span>, <span class="hl-string">"Some Company Inc."</span>);
<em class="lineannotation"><span class="lineannotation">// ... can also be done like this:</span></em>
PropertyValue value = <span class="hl-keyword">new</span> PropertyValue(<span class="hl-string">"name"</span>, <span class="hl-string">"Some Company Inc."</span>);
company.setPropertyValue(value);

<em class="lineannotation"><span class="lineannotation">// ok, let's create the director and tie it to the company:</span></em>
BeanWrapper jim = BeanWrapperImpl(<span class="hl-keyword">new</span> Employee());
jim.setPropertyValue(<span class="hl-string">"name"</span>, <span class="hl-string">"Jim Stravinsky"</span>);
company.setPropertyValue(<span class="hl-string">"managingDirector"</span>, jim.getWrappedInstance());

<em class="lineannotation"><span class="lineannotation">// retrieving the salary of the managingDirector through the company</span></em>
Float salary = (Float) company.getPropertyValue(<span class="hl-string">"managingDirector.salary"</span>);</pre>
    </div>

    <div class="section" title="7.4.2&nbsp;Built-in PropertyEditor implementations"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conversion"></a>7.4.2&nbsp;Built-in <code class="interfacename">PropertyEditor</code>
        implementations</h3></div></div></div>
      

      <p>Spring uses the concept of <code class="literal">PropertyEditors</code> to
        effect the conversion between an <code class="classname">Object</code> and a
        <code class="classname">String</code>. If you think about it, it sometimes might
        be handy to be able to represent properties in a different way than the
        object itself. For example, a <code class="classname">Date</code> can be
        represented in a human readable way (as the
        <code class="classname">String</code> '<code class="literal">2007-14-09</code>'), while
        we're still able to convert the human readable form back to the original
        date (or even better: convert any date entered in a human readable form,
        back to <code class="classname">Date</code> objects). This behavior can be
        achieved by <span class="emphasis"><em>registering custom editors</em></span>, of type
        <code class="interfacename">java.beans.PropertyEditor</code>. Registering
        custom editors on a <code class="interfacename">BeanWrapper</code> or
        alternately in a specific IoC container as mentioned in the previous
        chapter, gives it the knowledge of how to convert properties to the
        desired type. Read more about
        <code class="interfacename">PropertyEditors</code> in the Javadoc of the
        <code class="literal">java.beans</code> package provided by Sun.</p>

      <p>A couple of examples where property editing is used in Spring:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
          <p><span class="emphasis"><em>setting properties on beans</em></span> is done using
            <code class="literal">PropertyEditors</code>. When mentioning
            <code class="literal">java.lang.String</code> as the value of a property of
            some bean you're declaring in XML file, Spring will (if the setter
            of the corresponding property has a
            <code class="classname">Class</code>-parameter) use the
            <code class="classname">ClassEditor</code> to try to resolve the parameter
            to a <code class="classname">Class</code> object.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>parsing HTTP request parameters</em></span> in Spring's
            MVC framework is done using all kinds of
            <code class="literal">PropertyEditors</code> that you can manually bind in all
            subclasses of the <code class="classname">CommandController</code>.</p>
        </li></ul></div><p> </p>

      <p>Spring has a number of built-in <code class="literal">PropertyEditors</code>
        to make life easy. Each of those is listed below and they are all
        located in the
        <code class="literal">org.springframework.beans.propertyeditors</code> package.
        Most, but not all (as indicated below), are registered by default by
        <code class="classname">BeanWrapperImpl</code>. Where the property editor is
        configurable in some fashion, you can of course still register your own
        variant to override the default one:</p>

      <div class="table"><a name="beans-beans-property-editors-tbl"></a><p class="title"><b>Table&nbsp;7.2.&nbsp;Built-in <code class="literal">PropertyEditors</code></b></p><div class="table-contents">
        

        <table summary="Built-in PropertyEditors" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Class</th><th style="border-bottom: 0.5pt solid ; ">Explanation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">ByteArrayPropertyEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Editor for byte arrays. Strings will simply be converted to
                their corresponding byte representations. Registered by default
                by <code class="classname">BeanWrapperImpl</code>.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">ClassEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Parses Strings representing classes to actual classes and
                the other way around. When a class is not found, an
                <code class="classname">IllegalArgumentException</code> is thrown.
                Registered by default by
                <code class="classname">BeanWrapperImpl</code>.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">CustomBooleanEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Customizable property editor for
                <code class="classname">Boolean</code> properties. Registered by default
                by <code class="classname">BeanWrapperImpl</code>, but, can be
                overridden by registering custom instance of it as custom
                editor.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">CustomCollectionEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Property editor for Collections, converting any source
                <code class="interfacename">Collection</code> to a given target
                <code class="interfacename">Collection</code> type.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">CustomDateEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Customizable property editor for java.util.Date, supporting
                a custom DateFormat. NOT registered by default. Must be user
                registered as needed with appropriate format.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">CustomNumberEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Customizable property editor for any Number subclass like
                <code class="classname">Integer</code>, <code class="classname">Long</code>,
                <code class="classname">Float</code>, <code class="classname">Double</code>.
                Registered by default by <code class="classname">BeanWrapperImpl</code>,
                but can be overridden by registering custom instance of it as a
                custom editor.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">FileEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Capable of resolving Strings to
                <code class="classname">java.io.File</code> objects. Registered by
                default by <code class="classname">BeanWrapperImpl</code>. </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">InputStreamEditor</code></td><td style="border-bottom: 0.5pt solid ; ">One-way property editor, capable of taking a text string
                and producing (via an intermediate
                <code class="classname">ResourceEditor</code> and
                <code class="interfacename">Resource</code>) an
                <code class="interfacename">InputStream</code>, so
                <code class="interfacename">InputStream</code> properties may be
                directly set as Strings. Note that the default usage will not
                close the <code class="interfacename">InputStream</code> for you!
                Registered by default by
                <code class="classname">BeanWrapperImpl</code>.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">LocaleEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Capable of resolving Strings to
                <code class="classname">Locale</code> objects and vice versa (the String
                format is [language]_[country]_[variant], which is the same
                thing the toString() method of Locale provides). Registered by
                default by <code class="classname">BeanWrapperImpl</code>.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">PatternEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Capable of resolving Strings to JDK 1.5
                <code class="classname">Pattern</code> objects and vice versa.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">PropertiesEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Capable of converting Strings (formatted using the format
                as defined in the Javadoc for the java.lang.Properties class) to
                <code class="classname">Properties</code> objects. Registered by default
                by <code class="classname">BeanWrapperImpl</code>.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">StringTrimmerEditor</code></td><td style="border-bottom: 0.5pt solid ; ">Property editor that trims Strings. Optionally allows
                transforming an empty string into a <code class="literal">null</code>
                value. NOT registered by default; must be user registered as
                needed.</td></tr><tr><td style="border-right: 0.5pt solid ; "><code class="classname">URLEditor</code></td><td style="">Capable of resolving a String representation of a URL to an
                actual <code class="classname">URL</code> object. Registered by default
                by <code class="classname">BeanWrapperImpl</code>.</td></tr></tbody></table>
      </div></div><br class="table-break">

      <p> Spring uses the
        <code class="interfacename">java.beans.PropertyEditorManager</code> to set
        the search path for property editors that might be needed. The search
        path also includes <code class="literal">sun.bean.editors</code>, which includes
        <code class="interfacename">PropertyEditor</code> implementations for types
        such as <code class="classname">Font</code>, <code class="classname">Color</code>, and
        most of the primitive types. Note also that the standard JavaBeans
        infrastructure will automatically discover
        <code class="interfacename">PropertyEditor</code> classes (without you
        having to register them explicitly) if they are in the same package as
        the class they handle, and have the same name as that class, with
        <code class="literal">'Editor'</code> appended; for example, one could have the
        following class and package structure, which would be sufficient for the
        <code class="classname">FooEditor</code> class to be recognized and used as the
        <code class="interfacename">PropertyEditor</code> for
        <code class="classname">Foo</code>-typed properties. </p>
      <pre class="programlisting">com
  chank
    pop
      Foo
      FooEditor   <em class="lineannotation"><span class="lineannotation">// the PropertyEditor for the Foo class</span></em></pre>

      <p>Note that you can also use the standard
        <code class="interfacename">BeanInfo</code> JavaBeans mechanism here as well
        (described <a class="ulink" href="http://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html" target="_top">in not-amazing-detail here</a>). Find below an example of using the
        <code class="interfacename">BeanInfo</code> mechanism for explicitly
        registering one or more <code class="interfacename">PropertyEditor</code>
        instances with the properties of an associated class.</p>
      <pre class="programlisting">com
  chank
    pop
      Foo
      FooBeanInfo   <em class="lineannotation"><span class="lineannotation">// the BeanInfo for the Foo class</span></em></pre>

      <p> Here is the Java source code for the referenced
        <code class="classname">FooBeanInfo</code> class. This would associate a
        <code class="classname">CustomNumberEditor</code> with the
        <code class="literal">age</code> property of the <code class="classname">Foo</code> class. </p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FooBeanInfo <span class="hl-keyword">extends</span> SimpleBeanInfo {

    <span class="hl-keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() {
        <span class="hl-keyword">try</span> {
            <span class="hl-keyword">final</span> PropertyEditor numberPE = <span class="hl-keyword">new</span> CustomNumberEditor(Integer.<span class="hl-keyword">class</span>, true);
            PropertyDescriptor ageDescriptor = <span class="hl-keyword">new</span> PropertyDescriptor(<span class="hl-string">"age"</span>, Foo.<span class="hl-keyword">class</span>) {
                <span class="hl-keyword">public</span> PropertyEditor createPropertyEditor(Object bean) {
                    <span class="hl-keyword">return</span> numberPE;
                };
            };
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> PropertyDescriptor[] { ageDescriptor };
        }
        <span class="hl-keyword">catch</span> (IntrospectionException ex) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> Error(ex.toString());
        }
    }
}</pre>

      <div class="section" title="Registering additional custom PropertyEditors"><div class="titlepage"><div><div><h4 class="title"><a name="beans-beans-conversion-customeditor-registration"></a>Registering additional custom
          <code class="interfacename">PropertyEditors</code></h4></div></div></div>
        

        <p>When setting bean properties as a string value, a Spring IoC
          container ultimately uses standard JavaBeans
          <code class="literal">PropertyEditors</code> to convert these Strings to the
          complex type of the property. Spring pre-registers a number of custom
          <code class="literal">PropertyEditors</code> (for example, to convert a
          classname expressed as a string into a real
          <code class="classname">Class</code> object). Additionally, Java's standard
          JavaBeans <code class="interfacename">PropertyEditor</code> lookup
          mechanism allows a <code class="classname">PropertyEditor</code> for a class
          simply to be named appropriately and placed in the same package as the
          class it provides support for, to be found automatically.</p>

        <p>If there is a need to register other custom
          <code class="literal">PropertyEditors</code>, there are several mechanisms
          available. The most manual approach, which is not normally convenient
          or recommended, is to simply use the
          <code class="methodname">registerCustomEditor()</code> method of the
          <code class="interfacename">ConfigurableBeanFactory</code> interface,
          assuming you have a <code class="interfacename">BeanFactory</code>
          reference. Another, slightly more convenient, mechanism is to use a
          special bean factory post-processor called
          <code class="classname">CustomEditorConfigurer</code>. Although bean factory
          post-processors can be used with
          <code class="interfacename">BeanFactory</code> implementations, the
          <code class="classname">CustomEditorConfigurer</code> has a nested property
          setup, so it is strongly recommended that it is used with the
          <code class="interfacename">ApplicationContext</code>, where it may be
          deployed in similar fashion to any other bean, and automatically
          detected and applied.</p>

        <p>Note that all bean factories and application contexts
          automatically use a number of built-in property editors, through their
          use of something called a <code class="interfacename">BeanWrapper</code>
          to handle property conversions. The standard property editors that the
          <code class="interfacename">BeanWrapper</code> registers are listed in
          <a class="link" href="validation.html#beans-beans-conversion" title="7.4.2&nbsp;Built-in PropertyEditor implementations">the previous section</a>.
          Additionally, <code class="literal">ApplicationContexts</code> also override or
          add an additional number of editors to handle resource lookups in a
          manner appropriate to the specific application context type.</p>

        <p>Standard JavaBeans <code class="interfacename">PropertyEditor</code>
          instances are used to convert property values expressed as strings to
          the actual complex type of the property.
          <code class="classname">CustomEditorConfigurer</code>, a bean factory
          post-processor, may be used to conveniently add support for additional
          <code class="interfacename">PropertyEditor</code> instances to an
          <code class="interfacename">ApplicationContext</code>.</p>

        <p>Consider a user class <code class="classname">ExoticType</code>, and
          another class <code class="classname">DependsOnExoticType</code> which needs
          <code class="classname">ExoticType</code> set as a property:</p>

        <pre class="programlisting"><span class="hl-keyword">package</span> example;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExoticType {

    <span class="hl-keyword">private</span> String name;

    <span class="hl-keyword">public</span> ExoticType(String name) {
        <span class="hl-keyword">this</span>.name = name;
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DependsOnExoticType {

    <span class="hl-keyword">private</span> ExoticType type;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setType(ExoticType type) {
        <span class="hl-keyword">this</span>.type = type;
    }
}</pre>

        <p>When things are properly set up, we want to be able to assign the
          type property as a string, which a
          <code class="interfacename">PropertyEditor</code> will behind the scenes
          convert into an actual <code class="classname">ExoticType</code>
          instance:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sample"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"example.DependsOnExoticType"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"type"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"aNameForExoticType"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

        <p>The <code class="interfacename">PropertyEditor</code> implementation
          could look similar to this:</p>
        <pre class="programlisting"><em class="lineannotation"><span class="lineannotation">// converts string representation to ExoticType object</span></em>
<span class="hl-keyword">package</span> example;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExoticTypeEditor <span class="hl-keyword">extends</span> PropertyEditorSupport {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAsText(String text) {
        setValue(<span class="hl-keyword">new</span> ExoticType(text.toUpperCase()));
    }
}</pre>

        <p>Finally, we use <code class="classname">CustomEditorConfigurer</code> to
          register the new <code class="interfacename">PropertyEditor</code> with
          the <code class="interfacename">ApplicationContext</code>, which will then
          be able to use it as needed:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"customEditors"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;map&gt;</span>
      <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"example.ExoticType"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"example.ExoticTypeEditor"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/map&gt;</span>
  <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

        <div class="section" title="Using PropertyEditorRegistrars"><div class="titlepage"><div><div><h5 class="title"><a name="beans-beans-conversion-customeditor-registration-per"></a>Using
            <code class="interfacename">PropertyEditorRegistrars</code></h5></div></div></div>
          

          <p>Another mechanism for registering property editors with the
            Spring container is to create and use a
            <code class="interfacename">PropertyEditorRegistrar</code>. This
            interface is particularly useful when you need to use the same set
            of property editors in several different situations: write a
            corresponding registrar and reuse that in each case.
            <code class="literal">PropertyEditorRegistrars</code> work in conjunction with
            an interface called
            <code class="interfacename">PropertyEditorRegistry</code>, an interface
            that is implemented by the Spring
            <code class="interfacename">BeanWrapper</code> (and
            <code class="interfacename">DataBinder</code>).
            <code class="literal">PropertyEditorRegistrars</code> are particularly
            convenient when used in conjunction with the
            <code class="classname">CustomEditorConfigurer</code> (introduced <a class="link" href="validation.html#beans-beans-conversion-customeditor-registration" title="Registering additional custom PropertyEditors">here</a>), which exposes a property called
            <code class="methodname">setPropertyEditorRegistrars(..)</code>:
            <code class="literal">PropertyEditorRegistrars</code> added to a
            <code class="classname">CustomEditorConfigurer</code> in this fashion can
            easily be shared with <code class="interfacename">DataBinder</code> and
            Spring MVC <code class="interfacename">Controllers</code>. Furthermore,
            it avoids the need for synchronization on custom editors: a
            <code class="interfacename">PropertyEditorRegistrar</code> is expected
            to create fresh <code class="interfacename">PropertyEditor</code>
            instances for each bean creation attempt.</p>

          <p>Using a <code class="interfacename">PropertyEditorRegistrar</code>
            is perhaps best illustrated with an example. First off, you need to
            create your own
            <code class="interfacename">PropertyEditorRegistrar</code>
            implementation:</p>

          <pre class="programlisting"><span class="hl-keyword">package</span> com.foo.editors.spring;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> CustomPropertyEditorRegistrar <span class="hl-keyword">implements</span> PropertyEditorRegistrar {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> registerCustomEditors(PropertyEditorRegistry registry) {

        <em class="lineannotation"><span class="lineannotation">// it is expected that new PropertyEditor instances are created</span></em>
        registry.registerCustomEditor(ExoticType.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> ExoticTypeEditor());

        <em class="lineannotation"><span class="lineannotation">// you could register as many custom property editors as are required here...</span></em>
    }
}</pre>

          <p>See also the
            <code class="classname">org.springframework.beans.support.ResourceEditorRegistrar</code>
            for an example
            <code class="interfacename">PropertyEditorRegistrar</code>
            implementation. Notice how in its implementation of the
            <code class="methodname">registerCustomEditors(..)</code> method it creates
            new instances of each property editor.</p>

          <p>Next we configure a
            <code class="classname">CustomEditorConfigurer</code> and inject an instance
            of our <code class="classname">CustomPropertyEditorRegistrar</code> into
            it:</p>
          <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"propertyEditorRegistrars"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"customPropertyEditorRegistrar"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/list&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customPropertyEditorRegistrar"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"com.foo.editors.spring.CustomPropertyEditorRegistrar"</span><span class="hl-tag">/&gt;</span></pre>

          <p>Finally, and in a bit of a departure from the focus of this
            chapter, for those of you using <a class="link" href="mvc.html" title="17.&nbsp;Web MVC framework">Spring's MVC web
            framework</a>, using
            <code class="interfacename">PropertyEditorRegistrars</code> in
            conjunction with data-binding
            <code class="interfacename">Controllers</code> (such as
            <code class="classname">SimpleFormController</code>) can be very convenient.
            Find below an example of using a
            <code class="interfacename">PropertyEditorRegistrar</code> in the
            implementation of an <code class="methodname">initBinder(..)</code>
            method:</p>

          <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> RegisterUserController <span class="hl-keyword">extends</span> SimpleFormController {

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> PropertyEditorRegistrar customPropertyEditorRegistrar;

    <span class="hl-keyword">public</span> RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
        <span class="hl-keyword">this</span>.customPropertyEditorRegistrar = propertyEditorRegistrar;
    }

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> initBinder(HttpServletRequest request, ServletRequestDataBinder binder)
                        <span class="hl-keyword">throws</span> Exception {
        <span class="bold"><strong>this.customPropertyEditorRegistrar.registerCustomEditors(binder);</strong></span>
    }

    <em class="lineannotation"><span class="lineannotation">// other methods to do with registering a User</span></em>
}</pre>

          <p>This style of <code class="interfacename">PropertyEditor</code>
            registration can lead to concise code (the implementation of
            <code class="methodname">initBinder(..)</code> is just one line long!), and
            allows common <code class="interfacename">PropertyEditor</code>
            registration code to be encapsulated in a class and then shared
            amongst as many <code class="interfacename">Controllers</code> as
            needed.</p>
        </div>
      </div>
    </div>
  </div>

  <div class="section" title="7.5&nbsp;Spring 3 Type Conversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-convert"></a>7.5&nbsp;Spring 3 Type Conversion</h2></div></div></div>
    

    <p> Spring 3 introduces a <code class="filename">core.convert</code> package that
      provides a general type conversion system. The system defines an SPI to
      implement type conversion logic, as well as an API to execute type
      conversions at runtime. Within a Spring container, this system can be used
      as an alternative to PropertyEditors to convert externalized bean property
      value strings to required property types. The public API may also be used
      anywhere in your application where type conversion is needed. </p>

    <div class="section" title="7.5.1&nbsp;Converter SPI"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-Converter-API"></a>7.5.1&nbsp;Converter SPI</h3></div></div></div>
      

      <p> The SPI to implement type conversion logic is simple and strongly
        typed: </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.converter;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Converter&lt;S, T&gt; {

    T convert(S source);

}</pre>

      <p> To create your own Converter, simply implement the interface above.
        Parameterize S as the type you are converting from, and T as the type
        you are converting to. For each call to convert(S), the source argument
        is guaranteed to be NOT null. Your Converter may throw any Exception if
        conversion fails. An IllegalArgumentException should be thrown to report
        an invalid source value. Take care to ensure your Converter
        implementation is thread-safe. </p>

      <p> Several converter implementations are provided in the
        <code class="filename">core.convert.support</code> package as a convenience.
        These include converters from Strings to Numbers and other common types.
        Consider <code class="classname">StringToInteger</code> as an example Converter
        implementation: </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.support;

<span class="hl-keyword">final</span> <span class="hl-keyword">class</span> StringToInteger <span class="hl-keyword">implements</span> Converter&lt;String, Integer&gt; {

    <span class="hl-keyword">public</span> Integer convert(String source) {
        <span class="hl-keyword">return</span> Integer.valueOf(source);
    }

}</pre>
    </div>

    <div class="section" title="7.5.2&nbsp;ConverterFactory"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-ConverterFactory-SPI"></a>7.5.2&nbsp;ConverterFactory</h3></div></div></div>
      

      <p> When you need to centralize the conversion logic for an entire
        class hierarchy, for example, when converting from String to
        java.lang.Enum objects, implement
        <code class="interfacename">ConverterFactory</code>: </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.converter;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ConverterFactory&lt;S, R&gt; {

    &lt;T <span class="hl-keyword">extends</span> R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);

}</pre>

      <p> Parameterize S to be the type you are converting from and R to be
        the base type defining the <span class="emphasis"><em>range</em></span> of classes you can
        convert to. Then implement getConverter(Class&lt;T&gt;), where T is a
        subclass of R. </p>

      <p> Consider the <code class="classname">StringToEnum</code> ConverterFactory
        as an example: </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.support;

<span class="hl-keyword">final</span> <span class="hl-keyword">class</span> StringToEnumConverterFactory <span class="hl-keyword">implements</span> ConverterFactory&lt;String, Enum&gt; {

    <span class="hl-keyword">public</span> &lt;T <span class="hl-keyword">extends</span> Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> StringToEnumConverter(targetType);
    }

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> StringToEnumConverter&lt;T <span class="hl-keyword">extends</span> Enum&gt; <span class="hl-keyword">implements</span> Converter&lt;String, T&gt; {

        <span class="hl-keyword">private</span> Class&lt;T&gt; enumType;

        <span class="hl-keyword">public</span> StringToEnumConverter(Class&lt;T&gt; enumType) {
            <span class="hl-keyword">this</span>.enumType = enumType;
        }

        <span class="hl-keyword">public</span> T convert(String source) {
            <span class="hl-keyword">return</span> (T) Enum.valueOf(<span class="hl-keyword">this</span>.enumType, source.trim());
        }
    }
}</pre>
    </div>

    <div class="section" title="7.5.3&nbsp;GenericConverter"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-GenericConverter-SPI"></a>7.5.3&nbsp;GenericConverter</h3></div></div></div>
      

      <p> When you require a sophisticated Converter implementation, consider
        the GenericConverter interface. With a more flexible but less strongly
        typed signature, a GenericConverter supports converting between multiple
        source and target types. In addition, a GenericConverter makes available
        source and target field context you can use when implementing your
        conversion logic. Such context allows a type conversion to be driven by
        a field annotation, or generic information declared on a field
        signature. </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.converter;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> GenericConverter {

    <span class="hl-keyword">public</span> Set&lt;ConvertiblePair&gt; getConvertibleTypes();

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}</pre>

      <p> To implement a GenericConverter, have getConvertibleTypes() return
        the supported source-&gt;target type pairs. Then implement
        convert(Object, TypeDescriptor, TypeDescriptor) to implement your
        conversion logic. The source TypeDescriptor provides access to the
        source field holding the value being converted. The target
        TypeDescriptor provides access to the target field where the converted
        value will be set. </p>

      <p> A good example of a GenericConverter is a converter that converts
        between a Java Array and a Collection. Such an
        ArrayToCollectionConverter introspects the field that declares the
        target Collection type to resolve the Collection's element type. This
        allows each element in the source array to be converted to the
        Collection element type before the Collection is set on the target
        field. </p>
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p> Because GenericConverter is a more complex SPI interface, only
          use it when you need it. Favor Converter or ConverterFactory for basic
          type conversion needs. </p>
      </td></tr></table></div>

      <div class="section" title="ConditionalGenericConverter"><div class="titlepage"><div><div><h4 class="title"><a name="core-convert-ConditionalGenericConverter-SPI"></a>ConditionalGenericConverter</h4></div></div></div>
        

        <p> Sometimes you only want a Converter to execute if a specific
          condition holds true. For example, you might only want to execute a
          Converter if a specific annotation is present on the target field. Or
          you might only want to execute a Converter if a specific method, such
          as static valueOf method, is defined on the target class.
          ConditionalGenericConverter is an subinterface of GenericConverter
          that allows you to define such custom matching criteria: </p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ConditionalGenericConverter <span class="hl-keyword">extends</span> GenericConverter {

    <span class="hl-keyword">boolean</span> matches(TypeDescriptor sourceType, TypeDescriptor targetType);

}</pre>

        <p> A good example of a ConditionalGenericConverter is an
          EntityConverter that converts between an persistent entity identifier
          and an entity reference. Such a EntityConverter might only match if
          the target entity type declares a static finder method e.g.
          findAccount(Long). You would perform such a finder method check in the
          implementation of matches(TypeDescriptor, TypeDescriptor). </p>
      </div>
    </div>

    <div class="section" title="7.5.4&nbsp;ConversionService API"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-ConversionService-API"></a>7.5.4&nbsp;ConversionService API</h3></div></div></div>
      

      <p> The ConversionService defines a unified API for executing type
        conversion logic at runtime. Converters are often executed behind this
        facade interface: </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ConversionService {

    <span class="hl-keyword">boolean</span> canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);

    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);

    <span class="hl-keyword">boolean</span> canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}</pre>

      <p> Most ConversionService implementations also implement
        <code class="interfacename">ConverterRegistry</code>, which provides an SPI for
        registering converters. Internally, a ConversionService implementation
        delegates to its registered converters to carry out type conversion
        logic. </p>

      <p> A robust ConversionService implementation is provided in the
        <code class="filename">core.convert.support</code> package.
        <code class="classname">GenericConversionService</code> is the general-purpose
        implementation suitable for use in most environments.
        <code class="classname">ConversionServiceFactory</code> provides a convenient
        factory for creating common ConversionService configurations. </p>
    </div>

    <div class="section" title="7.5.5&nbsp;Configuring a ConversionService"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-Spring-config"></a>7.5.5&nbsp;Configuring a ConversionService</h3></div></div></div>
      

      <p> A ConversionService is a stateless object designed to be
        instantiated at application startup, then shared between multiple
        threads. In a Spring application, you typically configure a
        ConversionService instance per Spring container (or ApplicationContext).
        That ConversionService will be picked up by Spring and then used
        whenever a type conversion needs to be performed by the framework. You
        may also inject this ConversionService into any of your beans and invoke
        it directly. </p>
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p> If no ConversionService is registered with Spring, the original
          PropertyEditor-based system is used. </p>
      </td></tr></table></div>

      <p> To register a default ConversionService with Spring, add the
        following bean definition with id <code class="code">conversionService</code>: </p>
      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"conversionService"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.context.support.ConversionServiceFactoryBean"</span><span class="hl-tag">/&gt;</span></pre>

      <p> A default ConversionService can convert between strings, numbers,
        enums, collections, maps, and other common types. To supplement or
        override the default converters with your own custom converter(s), set
        the <code class="code">converters</code> property. Property values may implement
        either of the Converter, ConverterFactory, or GenericConverter
        interfaces. </p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"conversionService"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.context.support.ConversionServiceFactoryBean"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"converters"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"example.MyCustomConverter"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/list&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>It is also common to use a ConversionService within a Spring MVC
        application. See <a class="xref" href="validation.html#format-configuring-formatting-mvc" title="7.6.5&nbsp;Configuring Formatting in Spring MVC">Section&nbsp;7.6.5, &#8220;Configuring Formatting in Spring MVC&#8221;</a>
        for details on use with
        <code class="literal">&lt;mvc:annotation-driven/&gt;</code>.</p>

      <p>In certain situations you may wish to apply formatting during
        conversion. See <a class="xref" href="validation.html#format-FormatterRegistry-SPI" title="7.6.3&nbsp;FormatterRegistry SPI">Section&nbsp;7.6.3, &#8220;FormatterRegistry SPI&#8221;</a> for
        details on using
        <code class="classname">FormattingConversionServiceFactoryBean</code>.</p>
    </div>

    <div class="section" title="7.5.6&nbsp;Using a ConversionService programmatically"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-programmatic-usage"></a>7.5.6&nbsp;Using a ConversionService programmatically</h3></div></div></div>
      

      <p> To work with a ConversionService instance programmatically, simply
        inject a reference to it like you would for any other bean: </p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Service</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">public</span> MyService(ConversionService conversionService) {
        <span class="hl-keyword">this</span>.conversionService = conversionService;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doIt() {
        <span class="hl-keyword">this</span>.conversionService.convert(...)
    }
}</pre>
    </div>
  </div>

  <div class="section" title="7.6&nbsp;Spring 3 Field Formatting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="format"></a>7.6&nbsp;Spring 3 Field Formatting</h2></div></div></div>
    

    <p> As discussed in the previous section, <a class="link" href="validation.html#core-convert" title="7.5&nbsp;Spring 3 Type Conversion"><code class="filename">core.convert</code></a> is a general-purpose type
      conversion system. It provides a unified ConversionService API as well as
      a strongly-typed Converter SPI for implementing conversion logic from one
      type to another. A Spring Container uses this system to bind bean property
      values. In addition, both the Spring Expression Language (SpEL) and
      DataBinder use this system to bind field values. For example, when SpEL
      needs to coerce a <code class="classname">Short</code> to a
      <code class="classname">Long</code> to complete an
      <code class="function">expression.setValue(Object bean, Object value)</code>
      attempt, the core.convert system performs the coercion. </p>

    <p> Now consider the type conversion requirements of a typical client
      environment such as a web or desktop application. In such environments,
      you typically convert <span class="emphasis"><em>from String</em></span> to support the
      client postback process, as well as back <span class="emphasis"><em>to String</em></span> to
      support the view rendering process. In addition, you often need to
      localize String values. The more general <span class="emphasis"><em>core.convert</em></span>
      Converter SPI does not address such <span class="emphasis"><em>formatting</em></span>
      requirements directly. To directly address them, Spring 3 introduces a
      convenient Formatter SPI that provides a simple and robust alternative to
      PropertyEditors for client environments. </p>

    <p> In general, use the Converter SPI when you need to implement
      general-purpose type conversion logic; for example, for converting between
      a java.util.Date and and java.lang.Long. Use the Formatter SPI when you're
      working in a client environment, such as a web application, and need to
      parse and print localized field values. The ConversionService provides a
      unified type conversion API for both SPIs. </p>

    <div class="section" title="7.6.1&nbsp;Formatter SPI"><div class="titlepage"><div><div><h3 class="title"><a name="format-Formatter-SPI"></a>7.6.1&nbsp;Formatter SPI</h3></div></div></div>
      

      <p> The Formatter SPI to implement field formatting logic is simple and
        strongly typed: </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Formatter&lt;T&gt; <span class="hl-keyword">extends</span> Printer&lt;T&gt;, Parser&lt;T&gt; {
}</pre>

      <p> Where Formatter extends from the Printer and Parser building-block
        interfaces: </p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Printer&lt;T&gt; {
    String print(T fieldValue, Locale locale);
}</pre>

      <pre class="programlisting"><span class="hl-keyword">import</span> java.text.ParseException;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Parser&lt;T&gt; {
    T parse(String clientValue, Locale locale) <span class="hl-keyword">throws</span> ParseException;
}</pre>

      <p> To create your own Formatter, simply implement the Formatter
        interface above. Parameterize T to be the type of object you wish to
        format, for example, <code class="classname">java.util.Date</code>. Implement
        the <code class="methodname">print()</code> operation to print an instance of T
        for display in the client locale. Implement the
        <code class="methodname">parse()</code> operation to parse an instance of T from
        the formatted representation returned from the client locale. Your
        Formatter should throw a ParseException or IllegalArgumentException if a
        parse attempt fails. Take care to ensure your Formatter implementation
        is thread-safe. </p>

      <p> Several Formatter implementations are provided in
        <code class="filename">format</code> subpackages as a convenience. The
        <code class="filename">number</code> package provides a NumberFormatter,
        CurrencyFormatter, and PercentFormatter to format java.lang.Number
        objects using a java.text.NumberFormat. The
        <code class="filename">datetime</code> package provides a DateFormatter to format
        java.util.Date objects with a java.text.DateFormat. The
        <code class="filename">datetime.joda</code> package provides comprehensive
        datetime formatting support based on the <a class="ulink" href="http://joda-time.sourceforge.net" target="_top">Joda Time library</a>. </p>

      <p> Consider <code class="classname">DateFormatter</code> as an example
        <code class="interfacename">Formatter</code> implementation: </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format.datetime;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> DateFormatter <span class="hl-keyword">implements</span> Formatter&lt;Date&gt; {

    <span class="hl-keyword">private</span> String pattern;

    <span class="hl-keyword">public</span> DateFormatter(String pattern) {
        <span class="hl-keyword">this</span>.pattern = pattern;
    }

    <span class="hl-keyword">public</span> String print(Date date, Locale locale) {
        <span class="hl-keyword">if</span> (date == null) {
            <span class="hl-keyword">return</span> <span class="hl-string">""</span>;
        }
        <span class="hl-keyword">return</span> getDateFormat(locale).format(date);
    }

    <span class="hl-keyword">public</span> Date parse(String formatted, Locale locale) <span class="hl-keyword">throws</span> ParseException {
        <span class="hl-keyword">if</span> (formatted.length() == <span class="hl-number">0</span>) {
            <span class="hl-keyword">return</span> null;
        }
        <span class="hl-keyword">return</span> getDateFormat(locale).parse(formatted);
    }

    <span class="hl-keyword">protected</span> DateFormat getDateFormat(Locale locale) {
        DateFormat dateFormat = <span class="hl-keyword">new</span> SimpleDateFormat(<span class="hl-keyword">this</span>.pattern, locale);
        dateFormat.setLenient(false);
        <span class="hl-keyword">return</span> dateFormat;
    }

}</pre>

      <p> The Spring team welcomes community-driven Formatter contributions;
        see <a class="ulink" href="http://jira.springframework.org" target="_top">http://jira.springframework.org</a> to contribute. </p>
    </div>

    <div class="section" title="7.6.2&nbsp;Annotation-driven Formatting"><div class="titlepage"><div><div><h3 class="title"><a name="format-CustomFormatAnnotations"></a>7.6.2&nbsp;Annotation-driven Formatting</h3></div></div></div>
      

      <p> As you will see, field formatting can be configured by field type
        or annotation. To bind an Annotation to a formatter, implement
        AnnotationFormatterFactory: </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> AnnotationFormatterFactory&lt;A <span class="hl-keyword">extends</span> Annotation&gt; {

    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();

    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);

    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);

}</pre>

      <p> Parameterize A to be the field annotationType you wish to associate
        formatting logic with, for example
        <code class="code">org.springframework.format.annotation.DateTimeFormat</code>. Have
        <code class="methodname">getFieldTypes()</code> return the types of fields the
        annotation may be used on. Have <code class="methodname">getPrinter()</code>
        return a Printer to print the value of an annotated field. Have
        <code class="methodname">getParser()</code> return a Parser to parse a
        clientValue for an annotated field. </p>

      <p> The example AnnotationFormatterFactory implementation below binds
        the @NumberFormat Annotation to a formatter. This annotation allows
        either a number style or pattern to be specified: </p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> NumberFormatAnnotationFormatterFactory
        <span class="hl-keyword">implements</span> AnnotationFormatterFactory&lt;NumberFormat&gt; {

    <span class="hl-keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;(asList(<span class="hl-keyword">new</span> Class&lt;?&gt;[] {
            Short.<span class="hl-keyword">class</span>, Integer.<span class="hl-keyword">class</span>, Long.<span class="hl-keyword">class</span>, Float.<span class="hl-keyword">class</span>,
            Double.<span class="hl-keyword">class</span>, BigDecimal.<span class="hl-keyword">class</span>, BigInteger.<span class="hl-keyword">class</span> }));
    }

    <span class="hl-keyword">public</span> Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        <span class="hl-keyword">return</span> configureFormatterFrom(annotation, fieldType);
    }

    <span class="hl-keyword">public</span> Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        <span class="hl-keyword">return</span> configureFormatterFrom(annotation, fieldType);
    }

    <span class="hl-keyword">private</span> Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation,
                                                     Class&lt;?&gt; fieldType) {
        <span class="hl-keyword">if</span> (!annotation.pattern().isEmpty()) {
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> NumberFormatter(annotation.pattern());
        } <span class="hl-keyword">else</span> {
            Style style = annotation.style();
            <span class="hl-keyword">if</span> (style == Style.PERCENT) {
                <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> PercentFormatter();
            } <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (style == Style.CURRENCY) {
                <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CurrencyFormatter();
            } <span class="hl-keyword">else</span> {
                <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> NumberFormatter();
            }
        }
    }
}</pre>

      <p> To trigger formatting, simply annotate fields with @NumberFormat: </p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyModel {

    <i><span class="hl-annotation" style="color: gray">@NumberFormat(style=Style.CURRENCY)</span></i>
    <span class="hl-keyword">private</span> BigDecimal decimal;

}</pre>

      <div class="section" title="Format Annotation API"><div class="titlepage"><div><div><h4 class="title"><a name="format-annotations-api"></a>Format Annotation API</h4></div></div></div>
        

        <p> A portable format annotation API exists in the
          <code class="filename">org.springframework.format.annotation</code> package.
          Use @NumberFormat to format java.lang.Number fields. Use
          @DateTimeFormat to format java.util.Date, java.util.Calendar,
          java.util.Long, or Joda Time fields. </p>

        <p> The example below uses @DateTimeFormat to format a java.util.Date
          as a ISO Date (yyyy-MM-dd): </p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyModel {

    <i><span class="hl-annotation" style="color: gray">@DateTimeFormat(iso=ISO.DATE)</span></i>
    <span class="hl-keyword">private</span> Date date;

}</pre>
      </div>
    </div>

    <div class="section" title="7.6.3&nbsp;FormatterRegistry SPI"><div class="titlepage"><div><div><h3 class="title"><a name="format-FormatterRegistry-SPI"></a>7.6.3&nbsp;FormatterRegistry SPI</h3></div></div></div>
      

      <p> The FormatterRegistry is an SPI for registering formatters and
          converters. <code class="classname">FormattingConversionService</code> is
          an implementation of FormatterRegistry suitable for most environments.
          This implementation may be configured programmatically or declaratively
          as a Spring bean using
          <code class="classname">FormattingConversionServiceFactoryBean</code>.
          Because this implementation also implements
        <code class="classname">ConversionService</code>, it can be directly
        configured for use with Spring's DataBinder and the Spring Expression
        Language (SpEL).
      </p>

      <p> Review the FormatterRegistry SPI below: </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FormatterRegistry <span class="hl-keyword">extends</span> ConverterRegistry {

    <span class="hl-keyword">void</span> addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);

    <span class="hl-keyword">void</span> addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);

    <span class="hl-keyword">void</span> addFormatterForFieldType(Formatter&lt;?&gt; formatter);

    <span class="hl-keyword">void</span> addFormatterForAnnotation(AnnotationFormatterFactory&lt;?, ?&gt; factory);

}</pre>

      <p> As shown above, Formatters can be registered by fieldType or
        annotation.
      </p>
      <p> The FormatterRegistry SPI allows you to configure Formatting rules
        centrally, instead of duplicating such configuration across your
        Controllers. For example, you might want to enforce that all Date fields
        are formatted a certain way, or fields with a specific annotation are
        formatted in a certain way. With a shared FormatterRegistry, you define
        these rules once and they are applied whenever formatting is needed.
      </p>
    </div>

    <div class="section" title="7.6.4&nbsp;FormatterRegistrar SPI"><div class="titlepage"><div><div><h3 class="title"><a name="format-FormatterRegistrar-SPI"></a>7.6.4&nbsp;FormatterRegistrar SPI</h3></div></div></div>
      

      <p> The FormatterRegistrar is an SPI for registering formatters and
          converters through the FormatterRegistry:
      </p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FormatterRegistrar {

    <span class="hl-keyword">void</span> registerFormatters(FormatterRegistry registry);

}</pre>

        <p> A FormatterRegistrar is useful when registering multiple related
            converters and formatters for a given formatting category, such as Date
            formatting. It can also be useful where declarative registration is
            insufficient. For example when a formatter needs to be indexed under a
            specific field type different from its own &lt;T&gt; or when registering
            a Printer/Parser pair. The next section provides more information on
            converter and formatter registration.
        </p>
    </div>

    <div class="section" title="7.6.5&nbsp;Configuring Formatting in Spring MVC"><div class="titlepage"><div><div><h3 class="title"><a name="format-configuring-formatting-mvc"></a>7.6.5&nbsp;Configuring Formatting in Spring MVC</h3></div></div></div>
      

      <p> In a Spring MVC application, you may configure a custom
        ConversionService instance explicitly as an attribute of the
        <code class="literal">annotation-driven</code> element of the MVC namespace. This
        ConversionService will then be used anytime a type conversion is
        required during Controller model binding. If not configured explicitly,
        Spring MVC will automatically register default formatters and converters
        for common types such as numbers and dates. </p>

      <p> To rely on default formatting rules, no custom configuration is
        required in your Spring MVC config XML: </p>

      <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:mvc</span>=<span class="hl-value">"http://www.springframework.org/schema/mvc"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;mvc:annotation-driven/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

      <p> With this one-line of configuration, default formatters for Numbers
        and Date types will be installed, including support for the
        @NumberFormat and @DateTimeFormat annotations. Full support for the Joda
        Time formatting library is also installed if Joda Time is present on the
        classpath.</p>

      <p> To inject a ConversionService instance with custom formatters and
        converters registered, set the conversion-service attribute and then
        specify custom converters, formatters, or FormatterRegistrars as properties
        of the FormattingConversionServiceFactoryBean: </p>
      <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:mvc</span>=<span class="hl-value">"http://www.springframework.org/schema/mvc"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;mvc:annotation-driven</span> <span class="hl-attribute">conversion-service</span>=<span class="hl-value">"conversionService"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"conversionService"</span>
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"converters"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;set&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.example.MyConverter"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/set&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"formatters"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;set&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.example.MyFormatter"</span><span class="hl-tag">/&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.example.MyAnnotationFormatterFactory"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/set&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"formatterRegistrars"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;set&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.example.MyFormatterRegistrar"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/set&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p> See <a class="xref" href="validation.html#format-FormatterRegistrar-SPI" title="7.6.4&nbsp;FormatterRegistrar SPI">Section&nbsp;7.6.4, &#8220;FormatterRegistrar SPI&#8221;</a> and
            the <code class="classname">FormattingConversionServiceFactoryBean</code>
            for more information on when to use FormatterRegistrars.
          </p>
      </td></tr></table></div>

    </div>
  </div>

  <div class="section" title="7.7&nbsp;Configuring a global date &amp; time format"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="format-configuring-formatting-globaldatetimeformat"></a>7.7&nbsp;Configuring a global date &amp; time format</h2></div></div></div>
    

    <p>By default, date and time fields that are not annotated with
    <code class="interfacename">@DateTimeFormat</code> are converted from strings
    using the the <code class="literal">DateFormat.SHORT</code> style. If you prefer,
    you can change this by defining your own global format.</p>

    <p>You will need to ensure that Spring does not register default
    formatters, and instead you should register all formatters manually. Use the
    <code class="classname">org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code>
    or <code class="classname">org.springframework.format.datetime.DateFormatterRegistrar</code>
    class depending on whether you use the Joda Time library.</p>

    <p>For example, the following Java configuration will register a global
    '<code class="literal">yyyyMMdd</code>' format. This example does not depend on the
    Joda Time library:</p>
    <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Configuration</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

  <i><span class="hl-annotation" style="color: gray">@Bean</span></i>
  <span class="hl-keyword">public</span> FormattingConversionService conversionService() {

    <span class="hl-comment">// Use the DefaultFormattingConversionService but do not register defaults</span>
    DefaultFormattingConversionService conversionService = <span class="hl-keyword">new</span> DefaultFormattingConversionService(false);

    <span class="hl-comment">// Ensure @NumberFormat is still supported</span>
    conversionService.addFormatterForFieldAnnotation(<span class="hl-keyword">new</span> NumberFormatAnnotationFormatterFactory());

    <span class="hl-comment">// Register date conversion with a specific global format</span>
    DateFormatterRegistrar registrar = <span class="hl-keyword">new</span> DateFormatterRegistrar();
    registrar.setFormatter(<span class="hl-keyword">new</span> DateFormatter(<span class="hl-string">"yyyyMMdd"</span>));
    registrar.registerFormatters(conversionService);

    <span class="hl-keyword">return</span> conversionService;
  }
}</pre>

    <p>If you prefer XML based configuration you can use a
    <code class="classname">FormattingConversionServiceFactoryBean</code>. Here is the same
    example, this time using Joda Time:</p>
    <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&gt;

    &lt;bean id="</span><span class="hl-attribute">conversionService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"registerDefaultFormatters"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"false"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"formatters"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;set&gt;</span>
            <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.number.NumberFormatAnnotationFormatterFactory"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/set&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"formatterRegistrars"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;set&gt;</span>
          <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"</span><span class="hl-tag">&gt;</span>
              <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dateFormatter"</span><span class="hl-tag">&gt;</span>
                  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean"</span><span class="hl-tag">&gt;</span>
                      <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pattern"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"yyyyMMdd"</span><span class="hl-tag">/&gt;</span>
                  <span class="hl-tag">&lt;/bean&gt;</span>
              <span class="hl-tag">&lt;/property&gt;</span>
          <span class="hl-tag">&lt;/bean&gt;</span>
      <span class="hl-tag">&lt;/set&gt;</span>
      <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
  <span class="hl-tag">&lt;/beans&gt;</span></pre>

    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      <p>Joda Time provides separate distinct types to represent
      <code class="literal">date</code>, <code class="literal">time</code> and
      <code class="literal">date-time</code> values. The <code class="literal">dateFormatter</code>,
      <code class="literal">timeFormatter</code> and <code class="literal">dateTimeFormatter</code>
      properties of the <code class="classname">JodaTimeFormatterRegistrar</code> should
      be used to configure the different formats for each type. The
      <code class="classname">DateTimeFormatterFactoryBean</code> provides a
      convenient way to create formatters.</p>
    </td></tr></table></div>

    <p>If you are using Spring MVC remember to explicitly configure the
    conversion service that is used. For Java based
    <code class="interfacename">@Configuration</code> this means extending the
    <code class="classname">WebMvcConfigurationSupport</code> class and overriding
    the <code class="literal">mvcConversionService()</code> method. For XML you should
    use the <code class="literal">'conversion-service'</code> attribute of the
    <code class="literal">mvc:annotation-driven</code> element. See
    <a class="xref" href="validation.html#format-configuring-formatting-mvc" title="7.6.5&nbsp;Configuring Formatting in Spring MVC">Section&nbsp;7.6.5, &#8220;Configuring Formatting in Spring MVC&#8221;</a> for details.</p>
  </div>

  <div class="section" title="7.8&nbsp;Spring 3 Validation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-beanvalidation"></a>7.8&nbsp;Spring 3 Validation</h2></div></div></div>
    

    <p> Spring 3 introduces several enhancements to its validation support.
      First, the JSR-303 Bean Validation API is now fully supported. Second,
      when used programmatically, Spring's DataBinder can now validate objects as
      well as bind to them. Third, Spring MVC now has support for declaratively
      validating @Controller inputs. </p>

    <div class="section" title="7.8.1&nbsp;Overview of the JSR-303 Bean Validation API"><div class="titlepage"><div><div><h3 class="title"><a name="validation-beanvalidation-overview"></a>7.8.1&nbsp;Overview of the JSR-303 Bean Validation API</h3></div></div></div>
      

      <p> JSR-303 standardizes validation constraint declaration and metadata
        for the Java platform. Using this API, you annotate domain model
        properties with declarative validation constraints and the runtime
        enforces them. There are a number of built-in constraints you can take
        advantage of. You may also define your own custom constraints. </p>

      <p> To illustrate, consider a simple PersonForm model with two
        properties: </p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PersonForm {
    <span class="hl-keyword">private</span> String name;
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> age;
}</pre>

      <p> JSR-303 allows you to define declarative validation constraints
        against such properties: </p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PersonForm {

    <i><span class="hl-annotation" style="color: gray">@NotNull</span></i>
    <i><span class="hl-annotation" style="color: gray">@Size(max=64)</span></i>
    <span class="hl-keyword">private</span> String name;

    <i><span class="hl-annotation" style="color: gray">@Min(0)</span></i>
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> age;

}</pre>

      <p> When an instance of this class is validated by a JSR-303 Validator,
        these constraints will be enforced. </p>

      <p> For general information on JSR-303, see the <a class="ulink" href="http://jcp.org/en/jsr/detail?id=303" target="_top">Bean Validation
        Specification</a>. For information on the specific capabilities of
        the default reference implementation, see the <a class="ulink" href="https://www.hibernate.org/412.html" target="_top">Hibernate Validator</a>
        documentation. To learn how to setup a JSR-303 implementation as a
        Spring bean, keep reading. </p>
    </div>

    <div class="section" title="7.8.2&nbsp;Configuring a Bean Validation Implementation"><div class="titlepage"><div><div><h3 class="title"><a name="validation-beanvalidation-spring"></a>7.8.2&nbsp;Configuring a Bean Validation Implementation</h3></div></div></div>
      

      <p> Spring provides full support for the JSR-303 Bean Validation API.
        This includes convenient support for bootstrapping a JSR-303
        implementation as a Spring bean. This allows for a
        <code class="code">javax.validation.ValidatorFactory</code> or
        <code class="code">javax.validation.Validator</code> to be injected wherever
        validation is needed in your application. </p>

      <p> Use the <code class="classname">LocalValidatorFactoryBean</code> to
        configure a default JSR-303 Validator as a Spring bean: </p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"validator"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span><span class="hl-tag">/&gt;</span></pre>

      <p> The basic configuration above will trigger JSR-303 to initialize
        using its default bootstrap mechanism. A JSR-303 provider, such as
        Hibernate Validator, is expected to be present in the classpath and will
        be detected automatically. </p>

      <div class="section" title="Injecting a Validator"><div class="titlepage"><div><div><h4 class="title"><a name="validation-beanvalidation-spring-inject"></a>Injecting a Validator</h4></div></div></div>
        

        <p> <code class="classname">LocalValidatorFactoryBean</code> implements both
          <code class="code">javax.validation.ValidatorFactory</code> and
          <code class="code">javax.validation.Validator</code>, as well as Spring's
          <code class="code">org.springframework.validation.Validator</code>. You may inject
          a reference to either of these interfaces into beans that need to
          invoke validation logic. </p>

        <p> Inject a reference to <code class="code">javax.validation.Validator</code> if
          you prefer to work with the JSR-303 API directly: </p>

        <pre class="programlisting"><span class="hl-keyword">import</span> javax.validation.Validator;

<i><span class="hl-annotation" style="color: gray">@Service</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">private</span> Validator validator;</pre>

        <p> Inject a reference to
          <code class="code">org.springframework.validation.Validator</code> if your bean
          requires the Spring Validation API: </p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.springframework.validation.Validator;

<i><span class="hl-annotation" style="color: gray">@Service</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">private</span> Validator validator;

}</pre>
      </div>

      <div class="section" title="Configuring Custom Constraints"><div class="titlepage"><div><div><h4 class="title"><a name="validation-beanvalidation-spring-constraints"></a>Configuring Custom Constraints</h4></div></div></div>
        

        <p> Each JSR-303 validation constraint consists of two parts. First,
          a @Constraint annotation that declares the constraint and its
          configurable properties. Second, an implementation of the
          <code class="code">javax.validation.ConstraintValidator</code> interface that
          implements the constraint's behavior. To associate a declaration with
          an implementation, each @Constraint annotation references a
          corresponding ValidationConstraint implementation class. At runtime, a
          <code class="code">ConstraintValidatorFactory</code> instantiates the referenced
          implementation when the constraint annotation is encountered in your
          domain model. </p>

        <p> By default, the <code class="classname">LocalValidatorFactoryBean</code>
          configures a <code class="code">SpringConstraintValidatorFactory</code> that uses
          Spring to create ConstraintValidator instances. This allows your
          custom ConstraintValidators to benefit from dependency injection like
          any other Spring bean. </p>

        <p> Shown below is an example of a custom @Constraint declaration,
          followed by an associated <code class="code">ConstraintValidator</code>
          implementation that uses Spring for dependency injection: </p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Target({ElementType.METHOD, ElementType.FIELD})</span></i>
<i><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></i>
<i><span class="hl-annotation" style="color: gray">@Constraint(validatedBy=MyConstraintValidator.class)</span></i>
<span class="hl-keyword">public</span> <i><span class="hl-annotation" style="color: gray">@interface</span></i> MyConstraint {
}</pre>

        <pre class="programlisting"><span class="hl-keyword">import</span> javax.validation.ConstraintValidator;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyConstraintValidator <span class="hl-keyword">implements</span> ConstraintValidator {

    <i><span class="hl-annotation" style="color: gray">@Autowired;</span></i>
    <span class="hl-keyword">private</span> Foo aDependency;

    ...
}</pre>

        <p> As you can see, a ConstraintValidator implementation may have its
          dependencies @Autowired like any other Spring bean. </p>
      </div>

      <div class="section" title="Additional Configuration Options"><div class="titlepage"><div><div><h4 class="title"><a name="validation-beanvalidation-spring-other"></a>Additional Configuration Options</h4></div></div></div>
        

        <p> The default <code class="classname">LocalValidatorFactoryBean</code>
          configuration should prove sufficient for most cases. There are a
          number of other configuration options for various JSR-303 constructs,
          from message interpolation to traversal resolution. See the JavaDocs
          of <code class="classname">LocalValidatorFactoryBean</code> for more
          information on these options. </p>
      </div>
    </div>

    <div class="section" title="7.8.3&nbsp;Configuring a DataBinder"><div class="titlepage"><div><div><h3 class="title"><a name="validation-binder"></a>7.8.3&nbsp;Configuring a DataBinder</h3></div></div></div>
      

      <p> Since Spring 3, a DataBinder instance can be configured with a
        Validator. Once configured, the Validator may be invoked by calling
        <code class="code">binder.validate()</code>. Any validation Errors are automatically
        added to the binder's BindingResult. </p>

      <p> When working with the DataBinder programmatically, this can be used
        to invoke validation logic after binding to a target object: </p>

      <pre class="programlisting">Foo target = <span class="hl-keyword">new</span> Foo();
DataBinder binder = <span class="hl-keyword">new</span> DataBinder(target);
binder.setValidator(<span class="hl-keyword">new</span> FooValidator());

<em class="lineannotation"><span class="lineannotation">// bind to the target object</span></em>
binder.bind(propertyValues);

<em class="lineannotation"><span class="lineannotation">// validate the target object</span></em>
binder.validate();

<em class="lineannotation"><span class="lineannotation">// get BindingResult that includes any validation errors</span></em>
BindingResult results = binder.getBindingResult();</pre>

      <p> A DataBinder can also be configured with multiple
      <code class="interfacename">Validator</code> instances
      via <code class="code">dataBinder.addValidators</code>
      and <code class="code">dataBinder.replaceValidators</code>.
      This is useful when combining globally configured JSR-303 Bean Validation
      with a Spring <code class="interfacename">Validator</code> configured
      locally on a DataBinder instance.
      See <a class="xref" href="validation.html#validation-mvc-configuring" title="Configuring a Validator for use by Spring MVC">the section called &#8220;Configuring a Validator for use by Spring MVC&#8221;</a>.</p>

    </div>

    <div class="section" title="7.8.4&nbsp;Spring MVC 3 Validation"><div class="titlepage"><div><div><h3 class="title"><a name="validation-mvc"></a>7.8.4&nbsp;Spring MVC 3 Validation</h3></div></div></div>
      

      <p> Beginning with Spring 3, Spring MVC has the ability to
        automatically validate @Controller inputs. In previous versions it was
        up to the developer to manually invoke validation logic. </p>

      <div class="section" title="Triggering @Controller Input Validation"><div class="titlepage"><div><div><h4 class="title"><a name="validation-mvc-triggering"></a>Triggering @Controller Input Validation</h4></div></div></div>
        

        <p> To trigger validation of a @Controller input, simply annotate the
          input argument as @Valid: </p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Controller</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyController {

    <i><span class="hl-annotation" style="color: gray">@RequestMapping("/foo", method=RequestMethod.POST)</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processFoo(<span class="bold"><strong>@Valid</strong></span> Foo foo) { <em class="lineannotation"><span class="lineannotation">/* ... */</span></em> }</pre>

        <p> Spring MVC will validate a @Valid object after binding so-long as
          an appropriate Validator has been configured. </p>
        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p> The @Valid annotation is part of the standard JSR-303 Bean
            Validation API, and is not a Spring-specific construct. </p>
        </td></tr></table></div>
      </div>

      <div class="section" title="Configuring a Validator for use by Spring MVC"><div class="titlepage"><div><div><h4 class="title"><a name="validation-mvc-configuring"></a>Configuring a Validator for use by Spring MVC</h4></div></div></div>
        

        <p> The Validator instance invoked when a @Valid method argument is
          encountered may be configured in two ways. First, you may call
          binder.setValidator(Validator) within a @Controller's @InitBinder
          callback. This allows you to configure a Validator instance per
          @Controller class: </p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Controller</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyController {

    <i><span class="hl-annotation" style="color: gray">@InitBinder</span></i>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> initBinder(WebDataBinder binder) {
        binder.setValidator(<span class="hl-keyword">new</span> FooValidator());
    }

    <i><span class="hl-annotation" style="color: gray">@RequestMapping("/foo", method=RequestMethod.POST)</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processFoo(<i><span class="hl-annotation" style="color: gray">@Valid</span></i> Foo foo) { ... }

}</pre>

        <p> Second, you may call setValidator(Validator) on the global
          WebBindingInitializer. This allows you to configure a Validator
          instance across all @Controllers. This can be achieved easily by using
          the Spring MVC namespace: </p>

        <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:mvc</span>=<span class="hl-value">"http://www.springframework.org/schema/mvc"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;mvc:annotation-driven</span> <span class="hl-attribute">validator</span>=<span class="hl-value">"globalValidator"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

        <p> To combine a global and a local validator, configure the
        global validator as shown above and then add a local validator:</p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Controller</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyController {

    <i><span class="hl-annotation" style="color: gray">@InitBinder</span></i>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> initBinder(WebDataBinder binder) {
        binder.addValidators(<span class="hl-keyword">new</span> FooValidator());
    }

}</pre>

      </div>

      <div class="section" title="Configuring a JSR-303 Validator for use by Spring MVC"><div class="titlepage"><div><div><h4 class="title"><a name="validation-mvc-jsr303"></a>Configuring a JSR-303 Validator for use by Spring MVC</h4></div></div></div>
        

        <p> With JSR-303, a single <code class="code">javax.validation.Validator</code>
          instance typically validates <span class="emphasis"><em>all</em></span> model objects
          that declare validation constraints. To configure a JSR-303-backed
          Validator with Spring MVC, simply add a JSR-303 Provider, such as
          Hibernate Validator, to your classpath. Spring MVC will detect it and
          automatically enable JSR-303 support across all Controllers. </p>

        <p> The Spring MVC configuration required to enable JSR-303 support
          is shown below: </p>

        <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:mvc</span>=<span class="hl-value">"http://www.springframework.org/schema/mvc"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- JSR-303 support will be detected on classpath and enabled automatically --&gt;</span>
    <span class="hl-tag">&lt;mvc:annotation-driven/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

        <p> With this minimal configuration, anytime a @Valid @Controller
          input is encountered, it will be validated by the JSR-303 provider.
          JSR-303, in turn, will enforce any constraints declared against the
          input. Any ConstraintViolations will automatically be exposed as
          errors in the BindingResult renderable by standard Spring MVC form
          tags. </p>
      </div>
    </div>
  </div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="resources.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-core.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="expressions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">6.&nbsp;Resources&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;8.&nbsp;Spring Expression Language (SpEL)</td></tr></table></div></body></html>