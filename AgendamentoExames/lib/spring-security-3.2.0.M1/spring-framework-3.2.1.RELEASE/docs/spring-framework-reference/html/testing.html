<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>11.&nbsp;Testing</title><link rel="stylesheet" href="css/manual-multipage.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-core.html" title="Part&nbsp;III.&nbsp;Core Technologies"><link rel="prev" href="aop-api.html" title="10.&nbsp;Spring AOP APIs"><link rel="next" href="spring-data-tier.html" title="Part&nbsp;IV.&nbsp;Data Access"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">11.&nbsp;Testing</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="aop-api.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;III.&nbsp;Core Technologies</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="spring-data-tier.html">Next</a></td></tr></table><hr></div><div class="chapter" title="11.&nbsp;Testing"><div class="titlepage"><div><div><h2 class="title"><a name="testing"></a>11.&nbsp;Testing</h2></div></div></div>
  

  <div class="section" title="11.1&nbsp;Introduction to Spring Testing"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing-introduction"></a>11.1&nbsp;Introduction to Spring Testing</h2></div></div></div>
    

    <p>Testing is an integral part of enterprise software development. This
    chapter focuses on the value-add of the IoC principle to <a class="link" href="testing.html#unit-testing" title="11.2&nbsp;Unit Testing">unit testing</a> and on the benefits of the
    Spring Framework's support for <a class="link" href="testing.html#integration-testing" title="11.3&nbsp;Integration Testing">integration testing</a>. <span class="emphasis"><em>(A
    thorough treatment of testing in the enterprise is beyond the scope of
    this reference manual.)</em></span></p>
  </div>

  <div class="section" title="11.2&nbsp;Unit Testing"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="unit-testing"></a>11.2&nbsp;Unit Testing</h2></div></div></div>
    

    <p>Dependency Injection should make your code less dependent on the
    container than it would be with traditional Java EE development. The POJOs
    that make up your application should be testable in JUnit or TestNG tests,
    with objects simply instantiated using the <code class="literal">new</code>
    operator, <span class="emphasis"><em>without Spring or any other container</em></span>. You
    can use <a class="link" href="testing.html#mock-objects" title="11.2.1&nbsp;Mock Objects">mock objects</a> (in conjunction
    with other valuable testing techniques) to test your code in isolation. If
    you follow the architecture recommendations for Spring, the resulting
    clean layering and componentization of your codebase will facilitate
    easier unit testing. For example, you can test service layer objects by
    stubbing or mocking DAO or Repository interfaces, without needing to
    access persistent data while running unit tests.</p>

    <p>True unit tests typically run extremely quickly, as there is no
    runtime infrastructure to set up. Emphasizing true unit tests as part of
    your development methodology will boost your productivity. You may not
    need this section of the testing chapter to help you write effective unit
    tests for your IoC-based applications. For certain unit testing scenarios,
    however, the Spring Framework provides the following mock objects and
    testing support classes.</p>

    <div class="section" title="11.2.1&nbsp;Mock Objects"><div class="titlepage"><div><div><h3 class="title"><a name="mock-objects"></a>11.2.1&nbsp;Mock Objects</h3></div></div></div>
      

      <div class="section" title="Environment"><div class="titlepage"><div><div><h4 class="title"><a name="mock-objects-env"></a>Environment</h4></div></div></div>
        

        <p>The <code class="literal">org.springframework.mock.env</code> package
        contains mock implementations of the
        <code class="interfacename">Environment</code> and
        <code class="interfacename">PropertySource</code> abstractions introduced
        in Spring 3.1 (see <a class="xref" href="new-in-3.1.html#new-in-3.1-environment-abstraction" title="3.3&nbsp;Environment Abstraction">Section&nbsp;3.3, &#8220;Environment Abstraction&#8221;</a> and <a class="xref" href="new-in-3.1.html#new-in-3.1-property-source-abstraction" title="3.4&nbsp;PropertySource Abstraction">Section&nbsp;3.4, &#8220;PropertySource Abstraction&#8221;</a>).
        <code class="classname">MockEnvironment</code> and
        <code class="classname">MockPropertySource</code> are useful for developing
        <span class="emphasis"><em>out-of-container</em></span> tests for code that depends on
        environment-specific properties.</p>
      </div>

      <div class="section" title="JNDI"><div class="titlepage"><div><div><h4 class="title"><a name="mock-objects-jndi"></a>JNDI</h4></div></div></div>
        

        <p>The <code class="literal">org.springframework.mock.jndi</code> package
        contains an implementation of the JNDI SPI, which you can use to set
        up a simple JNDI environment for test suites or stand-alone
        applications. If, for example, JDBC <code class="classname">DataSource</code>s
        get bound to the same JNDI names in test code as within a Java EE
        container, you can reuse both application code and configuration in
        testing scenarios without modification.</p>
      </div>

      <div class="section" title="Servlet API"><div class="titlepage"><div><div><h4 class="title"><a name="mock-objects-servlet"></a>Servlet API</h4></div></div></div>
        

        <p>The <code class="literal">org.springframework.mock.web</code> package
        contains a comprehensive set of Servlet API mock objects, targeted at
        usage with Spring's Web MVC framework, which are useful for testing
        web contexts and controllers. These mock objects are generally more
        convenient to use than dynamic mock objects such as <a class="ulink" href="http://www.easymock.org" target="_top">EasyMock</a> or existing Servlet
        API mock objects such as <a class="ulink" href="http://www.mockobjects.com" target="_top">MockObjects</a>.</p>
      </div>

      <div class="section" title="Portlet API"><div class="titlepage"><div><div><h4 class="title"><a name="mock-objects-portlet"></a>Portlet API</h4></div></div></div>
        

        <p>The <code class="literal">org.springframework.mock.web.portlet</code>
        package contains a set of Portlet API mock objects, targeted at usage
        with Spring's Portlet MVC framework.</p>
      </div>
    </div>

    <div class="section" title="11.2.2&nbsp;Unit Testing support Classes"><div class="titlepage"><div><div><h3 class="title"><a name="unit-testing-support-classes"></a>11.2.2&nbsp;Unit Testing support Classes</h3></div></div></div>
      

      <div class="section" title="General utilities"><div class="titlepage"><div><div><h4 class="title"><a name="unit-testing-utilities"></a>General utilities</h4></div></div></div>
        

        <p>The <code class="literal">org.springframework.test.util</code> package
        contains <code class="classname">ReflectionTestUtils</code>, which is a
        collection of reflection-based utility methods. Developers use these
        methods in unit and integration testing scenarios in which they need
        to set a non-<code class="literal">public</code> field or invoke a
        non-<code class="literal">public</code> setter method when testing application
        code involving, for example:</p>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p>ORM frameworks such as JPA and Hibernate that condone
            <code class="literal">private</code> or <code class="literal">protected</code> field
            access as opposed to <code class="literal">public</code> setter methods for
            properties in a domain entity.</p>
          </li><li class="listitem">
            <p>Spring's support for annotations such as
            <code class="interfacename">@Autowired</code>,
            <code class="interfacename">@Inject</code>, and
            <code class="interfacename">@Resource,</code> which provides
            dependency injection for <code class="literal">private</code> or
            <code class="literal">protected</code> fields, setter methods, and
            configuration methods.</p>
          </li></ul></div>
      </div>

      <div class="section" title="Spring MVC"><div class="titlepage"><div><div><h4 class="title"><a name="unit-testing-spring-mvc"></a>Spring MVC</h4></div></div></div>
        

        <p>The <code class="literal">org.springframework.test.web</code> package
        contains <code class="classname">ModelAndViewAssert</code>, which you can use
        in combination with JUnit, TestNG, or any other testing framework for
        unit tests dealing with Spring MVC <code class="classname">ModelAndView</code>
        objects.</p>

        <div class="tip" title="Unit testing Spring MVC Controllers" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Unit testing Spring MVC Controllers"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Unit testing Spring MVC Controllers</th></tr><tr><td align="left" valign="top">
          

          <p>To test your Spring MVC <code class="literal">Controller</code>s, use
          <code class="classname">ModelAndViewAssert</code> combined with
          <code class="literal">MockHttpServletRequest</code>,
          <code class="literal">MockHttpSession</code>, and so on from the <a class="link" href="testing.html#mock-objects-servlet" title="Servlet API">
          <code class="literal">org.springframework.mock.web</code></a>
          package.</p>
        </td></tr></table></div>
      </div>
    </div>
  </div>

  <div class="section" title="11.3&nbsp;Integration Testing"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-testing"></a>11.3&nbsp;Integration Testing</h2></div></div></div>
    

    <div class="section" title="11.3.1&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-overview"></a>11.3.1&nbsp;Overview</h3></div></div></div>
      

      <p>It is important to be able to perform some integration testing
      without requiring deployment to your application server or connecting to
      other enterprise infrastructure. This will enable you to test things
      such as:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>The correct wiring of your Spring IoC container
          contexts.</p>
        </li><li class="listitem">
          <p>Data access using JDBC or an ORM tool. This would include such
          things as the correctness of SQL statements, Hibernate queries, JPA
          entity mappings, etc.</p>
        </li></ul></div>

      <p>The Spring Framework provides first-class support for integration
      testing in the <code class="filename">spring-test</code>
      module. The name of the actual JAR file might include the release
      version and might also be in the long
      <code class="filename">org.springframework.test</code> form, depending on where
      you get it from (see the <a class="link" href="overview.html#dependency-management" title="1.3.1&nbsp;Dependency Management and Naming Conventions">section
      on Dependency Management</a> for an explanation). This library
      includes the <code class="literal">org.springframework.test</code> package, which
      contains valuable classes for integration testing with a Spring
      container. This testing does not rely on an application server or other
      deployment environment. Such tests are slower to run than unit tests but
      much faster than the equivalent Cactus tests or remote tests that rely
      on deployment to an application server.</p>

      <p>In Spring 2.5 and later, unit and integration testing support is
      provided in the form of the annotation-driven <a class="link" href="testing.html#testcontext-framework" title="11.3.5&nbsp;Spring TestContext Framework">Spring TestContext Framework</a>. The
      TestContext framework is agnostic of the actual testing framework in
      use, thus allowing instrumentation of tests in various environments
      including JUnit, TestNG, and so on.</p>

      <div class="warning" title="JUnit 3.8 support is deprecated" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning: JUnit 3.8 support is deprecated"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">JUnit 3.8 support is deprecated</th></tr><tr><td align="left" valign="top">
        

        <p>As of Spring 3.0, the legacy JUnit 3.8 base class hierarchy
        (i.e.,
        <code class="classname">AbstractDependencyInjectionSpringContextTests</code>,
        <code class="classname">AbstractTransactionalDataSourceSpringContextTests</code>,
        etc.) is officially deprecated and will be removed in a later release.
        Any test classes based on this code should be migrated to the <a class="link" href="testing.html#testcontext-framework" title="11.3.5&nbsp;Spring TestContext Framework">Spring TestContext
        Framework</a>.</p>

        <p>As of Spring 3.1, the JUnit 3.8 base classes in the Spring
        TestContext Framework (i.e.,
        <code class="classname">AbstractJUnit38SpringContextTests</code> and
        <code class="classname">AbstractTransactionalJUnit38SpringContextTests</code>)
        and <code class="interfacename">@ExpectedException</code> have been
        officially deprecated and will be removed in a later release. Any test
        classes based on this code should be migrated to the JUnit 4 or TestNG
        support provided by the <a class="link" href="testing.html#testcontext-framework" title="11.3.5&nbsp;Spring TestContext Framework">Spring
        TestContext Framework</a>. Similarly, any test methods annotated
        with <code class="interfacename">@ExpectedException</code> should be
        modified to use the built-in support for expected exceptions in JUnit
        and TestNG.</p>
      </td></tr></table></div>
    </div>

    <div class="section" title="11.3.2&nbsp;Goals of Integration Testing"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-goals"></a>11.3.2&nbsp;Goals of Integration Testing</h3></div></div></div>
      

      <p>Spring's integration testing support has the following primary
      goals:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>To manage <a class="link" href="testing.html#testing-ctx-management" title="Context management and caching">Spring IoC
          container caching</a> between test execution.</p>
        </li><li class="listitem">
          <p>To provide <a class="link" href="testing.html#testing-fixture-di" title="Dependency Injection of test fixtures">Dependency
          Injection of test fixture instances</a>.</p>
        </li><li class="listitem">
          <p>To provide <a class="link" href="testing.html#testing-tx" title="Transaction management">transaction
          management</a> appropriate to integration testing.</p>
        </li><li class="listitem">
          <p>To supply <a class="link" href="testing.html#testing-support-classes" title="Support classes for integration testing">Spring-specific base
          classes</a> that assist developers in writing integration
          tests.</p>
        </li></ul></div>

      <p>The next few sections describe each goal and provide links to
      implementation and configuration details.</p>

      <div class="section" title="Context management and caching"><div class="titlepage"><div><div><h4 class="title"><a name="testing-ctx-management"></a>Context management and caching</h4></div></div></div>
        

        <p>The Spring TestContext Framework provides consistent loading of
        Spring <code class="classname">ApplicationContext</code>s and
        <code class="classname">WebApplicationContext</code>s as well as caching of
        those contexts. Support for the caching of loaded contexts is
        important, because startup time can become an issue &#8212; not because of
        the overhead of Spring itself, but because the objects instantiated by
        the Spring container take time to instantiate. For example, a project
        with 50 to 100 Hibernate mapping files might take 10 to 20 seconds to
        load the mapping files, and incurring that cost before running every
        test in every test fixture leads to slower overall test runs that
        reduce developer productivity.</p>

        <p>Test classes typically declare either an array of
        <span class="emphasis"><em>resource locations</em></span> for XML configuration metadata
        &#8212; often in the classpath &#8212; or an array of <span class="emphasis"><em>annotated
        classes</em></span> that is used to configure the application. These
        locations or classes are the same as or similar to those specified in
        <code class="literal">web.xml</code> or other deployment configuration
        files.</p>

        <p>By default, once loaded, the configured
        <code class="interfacename">ApplicationContext</code> is reused for each
        test. Thus the setup cost is incurred only once per test suite, and
        subsequent test execution is much faster. In this context, the term
        <span class="emphasis"><em>test suite</em></span> means all tests run in the same JVM &#8212;
        for example, all tests run from an Ant, Maven, or Gradle build for a
        given project or module. In the unlikely case that a test corrupts the
        application context and requires reloading &#8212; for example, by modifying
        a bean definition or the state of an application object &#8212; the
        TestContext framework can be configured to reload the configuration
        and rebuild the application context before executing the next
        test.</p>

        <p>See context management and caching with the <a class="link" href="testing.html#testcontext-ctx-management" title="Context management">TestContext
        framework</a>.</p>
      </div>

      <div class="section" title="Dependency Injection of test fixtures"><div class="titlepage"><div><div><h4 class="title"><a name="testing-fixture-di"></a>Dependency Injection of test fixtures</h4></div></div></div>
        

        <p>When the TestContext framework loads your application context,
        it can optionally configure instances of your test classes via
        Dependency Injection. This provides a convenient mechanism for setting
        up test fixtures using preconfigured beans from your application
        context. A strong benefit here is that you can reuse application
        contexts across various testing scenarios (e.g., for configuring
        Spring-managed object graphs, transactional proxies,
        <code class="classname">DataSource</code>s, etc.), thus avoiding the need to
        duplicate complex test fixture setup for individual test cases.</p>

        <p>As an example, consider the scenario where we have a class,
        <code class="classname">HibernateTitleRepository</code>, that implements data
        access logic for a <code class="classname">Title</code> domain entity. We want
        to write integration tests that test the following areas:</p>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p>The Spring configuration: basically, is everything related
            to the configuration of the
            <code class="classname">HibernateTitleRepository</code> bean correct and
            present?</p>
          </li><li class="listitem">
            <p>The Hibernate mapping file configuration: is everything
            mapped correctly, and are the correct lazy-loading settings in
            place?</p>
          </li><li class="listitem">
            <p>The logic of the
            <code class="classname">HibernateTitleRepository</code>: does the
            configured instance of this class perform as anticipated?</p>
          </li></ul></div>

        <p>See dependency injection of test fixtures with the <a class="link" href="testing.html#testcontext-fixture-di" title="Dependency injection of test fixtures">TestContext framework</a>.</p>
      </div>

      <div class="section" title="Transaction management"><div class="titlepage"><div><div><h4 class="title"><a name="testing-tx"></a>Transaction management</h4></div></div></div>
        

        <p>One common issue in tests that access a real database is their
        effect on the state of the persistence store. Even when you're using a
        development database, changes to the state may affect future tests.
        Also, many operations &#8212; such as inserting or modifying persistent data
        &#8212; cannot be performed (or verified) outside a transaction.</p>

        <p>The TestContext framework addresses this issue. By default, the
        framework will create and roll back a transaction for each test. You
        simply write code that can assume the existence of a transaction. If
        you call transactionally proxied objects in your tests, they will
        behave correctly, according to their configured transactional
        semantics. In addition, if a test method deletes the contents of
        selected tables while running within the transaction managed for the
        test, the transaction will roll back by default, and the database will
        return to its state prior to execution of the test. Transactional
        support is provided to a test via a
        <code class="classname">PlatformTransactionManager</code> bean defined in the
        test's application context.</p>

        <p>If you want a transaction to commit &#8212; unusual, but occasionally
        useful when you want a particular test to populate or modify the
        database &#8212; the TestContext framework can be instructed to cause the
        transaction to commit instead of roll back via the <a class="link" href="testing.html#integration-testing-annotations" title="11.3.4&nbsp;Annotations"><code class="interfacename">@TransactionConfiguration</code></a>
        and <a class="link" href="testing.html#integration-testing-annotations" title="11.3.4&nbsp;Annotations"><code class="interfacename">@Rollback</code></a>
        annotations.</p>

        <p>See transaction management with the <a class="link" href="testing.html#testcontext-tx" title="Transaction management">TestContext framework</a>.</p>
      </div>

      <div class="section" title="Support classes for integration testing"><div class="titlepage"><div><div><h4 class="title"><a name="testing-support-classes"></a>Support classes for integration testing</h4></div></div></div>
        

        <p>The Spring TestContext Framework provides several
        <code class="literal">abstract</code> support classes that simplify the writing
        of integration tests. These base test classes provide well-defined
        hooks into the testing framework as well as convenient instance
        variables and methods, which enable you to access:</p>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p>The <code class="literal">ApplicationContext</code>, for performing
            explicit bean lookups or testing the state of the context as a
            whole.</p>
          </li><li class="listitem">
            <p>A <code class="classname">JdbcTemplate</code>, for executing SQL
            statements to query the database. Such queries can be used to
            confirm database state both <span class="emphasis"><em>prior to</em></span> and
            <span class="emphasis"><em>after</em></span> execution of database-related
            application code, and Spring ensures that such queries run in the
            scope of the same transaction as the application code. When used
            in conjunction with an ORM tool, be sure to avoid <a class="link" href="testing.html#testcontext-tx-false-positives">false
            positives</a>.</p>
          </li></ul></div>

        <p>In addition, you may want to create your own custom,
        application-wide superclass with instance variables and methods
        specific to your project.</p>

        <p>See support classes for the <a class="link" href="testing.html#testcontext-support-classes" title="TestContext Framework support classes">TestContext
        framework</a>.</p>
      </div>
    </div>

    <div class="section" title="11.3.3&nbsp;JDBC Testing Support"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-support-jdbc"></a>11.3.3&nbsp;JDBC Testing Support</h3></div></div></div>
      

      <p>The <code class="literal">org.springframework.test.jdbc</code> package
      contains <code class="classname">JdbcTestUtils</code>, which is a collection of
      JDBC related utility functions intended to simplify standard database
      testing scenarios. <span class="emphasis"><em>Note that <a class="link" href="testing.html#testcontext-support-classes-junit4" title="JUnit support classes"><code class="classname">AbstractTransactionalJUnit4SpringContextTests</code></a>
      and <a class="link" href="testing.html#testcontext-support-classes-testng" title="TestNG support classes"><code class="classname">AbstractTransactionalTestNGSpringContextTests</code></a>
      provide convenience methods which delegate to
      <code class="classname">JdbcTestUtils</code> internally.</em></span></p>

      <p>The <code class="literal">spring-jdbc</code> module provides support for
      configuring and launching an embedded database which can be used in
      integration tests that interact with a database. For details, see <a class="xref" href="jdbc.html#jdbc-embedded-database-support" title="14.8&nbsp;Embedded database support">Section&nbsp;14.8, &#8220;Embedded database support&#8221;</a> and <a class="xref" href="jdbc.html#jdbc-embedded-database-dao-testing" title="14.8.8&nbsp;Testing data access logic with an embedded database">Section&nbsp;14.8.8, &#8220;Testing data access logic with an embedded database&#8221;</a>.</p>
    </div>

    <div class="section" title="11.3.4&nbsp;Annotations"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-annotations"></a>11.3.4&nbsp;Annotations</h3></div></div></div>
      

      <div class="section" title="Spring Testing Annotations"><div class="titlepage"><div><div><h4 class="title"><a name="integration-testing-annotations-spring"></a>Spring Testing Annotations</h4></div></div></div>
        

        <p>The Spring Framework provides the following set of
        <span class="emphasis"><em>Spring-specific</em></span> annotations that you can use in
        your unit and integration tests in conjunction with the TestContext
        framework. Refer to the respective Javadoc for further information,
        including default attribute values, attribute aliases, and so
        on.</p>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@ContextConfiguration</code>
            </strong></span></p>

            <p>Defines class-level metadata that is used to determine how
            to load and configure an
            <code class="interfacename">ApplicationContext</code> for integration
            tests. Specifically,
            <code class="interfacename">@ContextConfiguration</code> declares
            <span class="emphasis"><em>either</em></span> the application context resource
            <code class="varname">locations</code> <span class="emphasis"><em>or</em></span> the annotated
            <code class="varname">classes</code> that will be used to load the
            context.</p>

            <p>Resource locations are typically XML configuration files
            located in the classpath; whereas, annotated classes are typically
            <code class="interfacename">@Configuration</code> classes. However,
            resource locations can also refer to files in the file system, and
            annotated classes can be component classes, etc.</p>

            <pre class="programlisting"><span class="bold"><strong>@ContextConfiguration</strong></span>(<span class="hl-string">"/test-config.xml"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> XmlApplicationContextTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <pre class="programlisting"><span class="bold"><strong>@ContextConfiguration</strong></span>(<span class="bold"><strong>classes</strong></span>=TestConfig.<span class="hl-keyword">class</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ConfigClassApplicationContextTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <p>As an alternative or in addition to declaring resource
            locations or annotated classes,
            <code class="interfacename">@ContextConfiguration</code> may be used
            to declare
            <code class="interfacename">ApplicationContextInitializer</code>
            classes.</p>

            <pre class="programlisting"><span class="bold"><strong>@ContextConfiguration</strong></span>(<span class="bold"><strong>initializers</strong></span>=CustomContextIntializer.<span class="hl-keyword">class</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContextInitializerTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <p><code class="interfacename">@ContextConfiguration</code> may
            optionally be used to declare the
            <code class="interfacename">ContextLoader</code> strategy as well.
            Note, however, that you typically do not need to explicitly
            configure the loader since the default loader supports either
            resource <code class="varname">locations</code> or annotated
            <code class="varname">classes</code> as well as
            <code class="varname">initializers</code>.</p>

            <pre class="programlisting"><span class="bold"><strong>@ContextConfiguration</strong></span>(<span class="bold"><strong>locations</strong></span>=<span class="hl-string">"/test-context.xml"</span>, <span class="bold"><strong>loader</strong></span>=CustomContextLoader.<span class="hl-keyword">class</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomLoaderXmlApplicationContextTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
              <p><code class="interfacename">@ContextConfiguration</code>
              provides support for <span class="emphasis"><em>inheriting</em></span> resource
              locations or configuration classes as well as context
              initializers declared by superclasses by default.</p>
            </td></tr></table></div>

            <p>See <a class="link" href="testing.html#testcontext-ctx-management" title="Context management">Context
            management and caching</a> and the Javadoc for
            <code class="interfacename">@ContextConfiguration</code> for further
            details.</p>
          </li><li class="listitem">
            <p><span class="bold"><strong><code class="interfacename">@WebAppConfiguration</code></strong></span></p>

            <p>A class-level annotation that is used to declare that the
            <code class="interfacename">ApplicationContext</code> loaded for an
            integration test should be a
            <code class="interfacename">WebApplicationContext</code>. The mere
            presence of <code class="interfacename">@WebAppConfiguration</code> on
            a test class ensures that a
            <code class="interfacename">WebApplicationContext</code> will be
            loaded for the test, using the default value of
            <code class="literal">"file:src/main/webapp"</code> for the path to the root
            of the web application (i.e., the <span class="emphasis"><em>resource base
            path</em></span>). The resource base path is used behind the scenes
            to create a <code class="classname">MockServletContext</code> which serves
            as the <code class="interfacename">ServletContext</code> for the
            test's
            <code class="interfacename">WebApplicationContext</code>.</p>

            <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="bold"><strong>@WebAppConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebAppTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <p>To override the default, specify a different base resource
            path via the <span class="emphasis"><em>implicit</em></span>
            <code class="interfacename">value</code> attribute. Both
            <code class="literal">classpath:</code> and <code class="literal">file:</code>
            resource prefixes are supported. If no resource prefix is supplied
            the path is assumed to be a file system resource.</p>

            <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="bold"><strong>@WebAppConfiguration("classpath:test-web-resources")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebAppTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <p>Note that
            <code class="interfacename">@WebAppConfiguration</code> must be used
            in conjunction with
            <code class="interfacename">@ContextConfiguration</code>, either
            within a single test class or within a test class hierarchy. See
            the Javadoc for
            <code class="interfacename">@WebAppConfiguration</code> for further
            details.</p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@ActiveProfiles</code> </strong></span></p>

            <p>A class-level annotation that is used to declare which
            <span class="emphasis"><em>bean definition profiles</em></span> should be active
            when loading an <code class="interfacename">ApplicationContext</code>
            for test classes.</p>

            <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="bold"><strong>@ActiveProfiles</strong></span>(<span class="hl-string">"dev"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DeveloperTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="bold"><strong>@ActiveProfiles</strong></span>({<span class="hl-string">"dev"</span>, <span class="hl-string">"integration"</span>})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DeveloperIntegrationTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
              <p><code class="interfacename">@ActiveProfiles</code> provides
              support for <span class="emphasis"><em>inheriting</em></span> active bean
              definition profiles declared by superclasses by default.</p>
            </td></tr></table></div>

            <p>See <a class="link" href="testing.html#testcontext-ctx-management-env-profiles" title="Context configuration with environment profiles">Context
            configuration with environment profiles</a> and the Javadoc for
            <code class="interfacename">@ActiveProfiles</code> for examples and
            further details.</p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@DirtiesContext</code> </strong></span></p>

            <p>Indicates that the underlying Spring
            <code class="interfacename">ApplicationContext</code> has been
            <span class="emphasis"><em>dirtied</em></span> (i.e., modified or corrupted in some
            manner) during the execution of a test and should be closed,
            regardless of whether the test passed.
            <code class="interfacename">@DirtiesContext</code> is supported in the
            following scenarios:</p>

            <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <p>After the current test class, when declared on a class
                with class mode set to <code class="literal">AFTER_CLASS</code>, which
                is the default class mode.</p>
              </li><li class="listitem">
                <p>After each test method in the current test class, when
                declared on a class with class mode set to
                <code class="literal">AFTER_EACH_TEST_METHOD.</code></p>
              </li><li class="listitem">
                <p>After the current test, when declared on a
                method.</p>
              </li></ul></div>

            <p>Use this annotation if a test has modified the context (for
            example, by replacing a bean definition). Subsequent tests are
            supplied a new context.</p>

            <p>With JUnit 4.5+ or TestNG you can use
            <code class="interfacename">@DirtiesContext</code> as both a
            class-level and method-level annotation within the same test
            class. In such scenarios, the
            <code class="interfacename">ApplicationContext</code> is marked as
            <span class="emphasis"><em>dirty</em></span> after any such annotated method as well
            as after the entire class. If the <code class="classname">ClassMode</code>
            is set to <code class="literal">AFTER_EACH_TEST_METHOD</code>, the context
            is marked dirty after each test method in the class.</p>

            <pre class="programlisting"><span class="bold"><strong>@DirtiesContext</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContextDirtyingTests {
    <em class="lineannotation"><span class="lineannotation">// some tests that result in the Spring container being dirtied</span></em>
}</pre>

            <pre class="programlisting"><span class="bold"><strong>@DirtiesContext</strong></span>(<span class="bold"><strong>classMode</strong></span> = ClassMode.AFTER_EACH_TEST_METHOD)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContextDirtyingTests {
    <em class="lineannotation"><span class="lineannotation">// some tests that result in the Spring container being dirtied</span></em>
}</pre>

            <pre class="programlisting"><span class="bold"><strong>@DirtiesContext</strong></span>
<i><span class="hl-annotation" style="color: gray">@Test</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWhichDirtiesAppCtx() {
    <em class="lineannotation"><span class="lineannotation">// some logic that results in the Spring container being dirtied</span></em>
}</pre>

            <p>When an application context is marked
            <span class="emphasis"><em>dirty</em></span>, it is removed from the testing
            framework's cache and closed; thus the underlying Spring container
            is rebuilt for any subsequent test that requires a context with
            the same set of resource locations.</p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@TestExecutionListeners</code>
            </strong></span></p>

            <p>Defines class-level metadata for configuring which
            <code class="interfacename">TestExecutionListener</code>s should be
            registered with the <code class="classname">TestContextManager</code>.
            Typically, <code class="interfacename">@TestExecutionListeners</code>
            is used in conjunction with
            <code class="interfacename">@ContextConfiguration</code>.</p>

            <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="bold"><strong>@TestExecutionListeners</strong></span>({CustomTestExecutionListener.<span class="hl-keyword">class</span>, AnotherTestExecutionListener.<span class="hl-keyword">class</span>})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomTestExecutionListenerTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <p><code class="interfacename">@TestExecutionListeners</code>
            supports <span class="emphasis"><em>inherited</em></span> listeners by default. See
            the Javadoc for an example and further details.</p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@TransactionConfiguration</code>
            </strong></span></p>

            <p>Defines class-level metadata for configuring transactional
            tests. Specifically, the bean name of the
            <code class="interfacename">PlatformTransactionManager</code> that
            should be used to drive transactions can be explicitly specified
            if there are multiple beans of type
            <code class="interfacename">PlatformTransactionManager</code> in the
            test's <code class="interfacename">ApplicationContext</code> and if
            the bean name of the desired
            <code class="interfacename">PlatformTransactionManager</code> is not
            "transactionManager". In addition, you can change the
            <code class="literal">defaultRollback</code> flag to
            <code class="literal">false</code>. Typically,
            <code class="interfacename">@TransactionConfiguration</code> is used
            in conjunction with
            <code class="interfacename">@ContextConfiguration</code>.</p>

            <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="bold"><strong>@TransactionConfiguration</strong></span>(<span class="bold"><strong>transactionManager</strong></span>=<span class="hl-string">"txMgr"</span>, <span class="bold"><strong>defaultRollback</strong></span>=false)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomConfiguredTransactionalTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

            <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
              <p>If the default conventions are sufficient for your test
              configuration, you can avoid using
              <code class="interfacename">@TransactionConfiguration</code>
              altogether. In other words, if you have only one transaction
              manger &#8212; or if you have multiple transaction mangers but the
              transaction manager for tests is named "transactionManager" or
              specified via a
              <code class="interfacename">TransactionManagementConfigurer</code> &#8212;
              and if you want transactions to roll back automatically, then
              there is no need to annotate your test class with
              <code class="interfacename">@TransactionConfiguration</code>.</p>
            </td></tr></table></div>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@Rollback</code> </strong></span></p>

            <p>Indicates whether the transaction for the annotated test
            method should be <span class="emphasis"><em>rolled back</em></span> after the test
            method has completed. If <code class="literal">true</code>, the transaction
            is rolled back; otherwise, the transaction is committed. Use
            <code class="interfacename">@Rollback</code> to override the default
            rollback flag configured at the class level.</p>

            <pre class="programlisting"><span class="bold"><strong>@Rollback</strong></span>(false)
<i><span class="hl-annotation" style="color: gray">@Test</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWithoutRollback() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@BeforeTransaction</code>
            </strong></span></p>

            <p>Indicates that the annotated <code class="literal">public void</code>
            method should be executed <span class="emphasis"><em>before</em></span> a
            transaction is started for test methods configured to run within a
            transaction via the <code class="interfacename">@Transactional</code>
            annotation.</p>

            <pre class="programlisting"><span class="bold"><strong>@BeforeTransaction
</strong></span><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> beforeTransaction() {
    <em class="lineannotation"><span class="lineannotation">// logic to be executed before a transaction is started</span></em>
}</pre>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@AfterTransaction</code>
            </strong></span></p>

            <p>Indicates that the annotated <code class="literal">public void</code>
            method should be executed <span class="emphasis"><em>after</em></span> a transaction
            has ended for test methods configured to run within a transaction
            via the <code class="interfacename">@Transactional</code>
            annotation.</p>

            <pre class="programlisting"><span class="bold"><strong>@AfterTransaction
</strong></span><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> afterTransaction() {
    <em class="lineannotation"><span class="lineannotation">// logic to be executed after a transaction has ended</span></em>
}</pre>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@NotTransactional</code>
            </strong></span></p>

            <p>The presence of this annotation indicates that the annotated
            test method must <span class="emphasis"><em>not</em></span> execute in a
            transactional context.</p>

            <pre class="programlisting"><span class="bold"><strong>@NotTransactional</strong></span>
<i><span class="hl-annotation" style="color: gray">@Test</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWithoutTransaction() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>

            <div class="warning" title="@NotTransactional is deprecated" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning: @NotTransactional is deprecated"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">@NotTransactional is deprecated</th></tr><tr><td align="left" valign="top">
              

              <p>As of Spring 3.0,
              <code class="interfacename">@NotTransactional</code> is deprecated
              in favor of moving the <span class="emphasis"><em>non-transactional</em></span>
              test method to a separate (non-transactional) test class or to a
              <code class="interfacename">@BeforeTransaction</code> or
              <code class="interfacename">@AfterTransaction</code> method. As an
              alternative to annotating an entire class with
              <code class="interfacename">@Transactional</code>, consider
              annotating individual methods with
              <code class="interfacename">@Transactional</code>; doing so allows a
              mix of transactional and non-transactional methods in the same
              test class without the need for using
              <code class="interfacename">@NotTransactional</code>.</p>
            </td></tr></table></div>
          </li></ul></div>
      </div>

      <div class="section" title="Standard Annotation Support"><div class="titlepage"><div><div><h4 class="title"><a name="integration-testing-annotations-standard"></a>Standard Annotation Support</h4></div></div></div>
        

        <p>The following annotations are supported with standard semantics
        for all configurations of the Spring TestContext Framework. Note that
        these annotations are not specific to tests and can be used anywhere
        in the Spring Framework.</p>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@Autowired</code> </strong></span></p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@Qualifier</code> </strong></span></p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@Resource</code> </strong></span>
            (javax.annotation) <span class="emphasis"><em>if JSR-250 is
            present</em></span></p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@Inject</code> </strong></span> (javax.inject)
            <span class="emphasis"><em>if JSR-330 is present</em></span></p>
          </li><li class="listitem">
            <p><span class="bold"><strong> <code class="interfacename">@Named</code>
            </strong></span> (javax.inject) <span class="emphasis"><em>if JSR-330 is
            present</em></span></p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@PersistenceContext</code> </strong></span>
            (javax.persistence) <span class="emphasis"><em>if JPA is present</em></span></p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@PersistenceUnit</code> </strong></span>
            (javax.persistence) <span class="emphasis"><em>if JPA is present</em></span></p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@Required</code> </strong></span></p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@Transactional</code> </strong></span></p>
          </li></ul></div>

        <div class="note" title="JSR-250 Lifecycle Annotations" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: JSR-250 Lifecycle Annotations"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">JSR-250 Lifecycle Annotations</th></tr><tr><td align="left" valign="top">
          

          <p>In the Spring TestContext Framework
          <code class="interfacename">@PostConstruct</code> and
          <code class="interfacename">@PreDestroy</code> may be used with standard
          semantics on any application components configured in the
          <code class="interfacename">ApplicationContext</code>; however, these
          lifecycle annotations have limited usage within an actual test
          class.</p>

          <p>If a method within a test class is annotated with
          <code class="interfacename">@PostConstruct</code>, that method will be
          executed before any <span class="emphasis"><em>before</em></span> methods of the
          underlying test framework (e.g., methods annotated with JUnit's
          <code class="interfacename">@Before</code>), and that will apply for
          every test method in the test class. On the other hand, if a method
          within a test class is annotated with
          <code class="interfacename">@PreDestroy</code>, that method will
          <span class="bold"><strong>never</strong></span> be executed. Within a test
          class it is therefore recommended to use test lifecycle callbacks
          from the underlying test framework instead of
          <code class="interfacename">@PostConstruct</code> and
          <code class="interfacename">@PreDestroy</code>.</p>
        </td></tr></table></div>
      </div>

      <div class="section" title="Spring JUnit Testing Annotations"><div class="titlepage"><div><div><h4 class="title"><a name="integration-testing-annotations-junit"></a>Spring JUnit Testing Annotations</h4></div></div></div>
        

        <p>The following annotations are <span class="emphasis"><em>only</em></span>
        supported when used in conjunction with the <a class="link" href="testing.html#testcontext-junit4-runner" title="Spring JUnit Runner">SpringJUnit4ClassRunner</a> or
        the <a class="link" href="testing.html#testcontext-support-classes-junit4" title="JUnit support classes">JUnit</a>
        support classes.</p>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@IfProfileValue</code> </strong></span></p>

            <p>Indicates that the annotated test is enabled for a specific
            testing environment. If the configured
            <code class="classname">ProfileValueSource</code> returns a matching
            <code class="literal">value</code> for the provided <code class="literal">name</code>,
            the test is enabled. This annotation can be applied to an entire
            class or to individual methods. Class-level usage overrides
            method-level usage.</p>

            <pre class="programlisting"><span class="bold"><strong>@IfProfileValue</strong></span>(<span class="bold"><strong>name</strong></span>=<span class="hl-string">"java.vendor"</span>, <span class="bold"><strong>value</strong></span>=<span class="hl-string">"Sun Microsystems Inc."</span>)
<i><span class="hl-annotation" style="color: gray">@Test</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWhichRunsOnlyOnSunJvm() {
    <em class="lineannotation"><span class="lineannotation">// some logic that should run only on Java VMs from Sun Microsystems</span></em>
}</pre>

            <p>Alternatively, you can configure
            <code class="interfacename">@IfProfileValue</code> with a list of
            <code class="literal">values</code> (with <span class="emphasis"><em>OR</em></span> semantics)
            to achieve TestNG-like support for <span class="emphasis"><em>test
            groups</em></span> in a JUnit environment. Consider the following
            example:</p>

            <pre class="programlisting"><span class="bold"><strong>@IfProfileValue</strong></span>(<span class="bold"><strong>name</strong></span>=<span class="hl-string">"test-groups"</span>, <span class="bold"><strong>values</strong></span>={<span class="hl-string">"unit-tests"</span>, <span class="hl-string">"integration-tests"</span>})
<i><span class="hl-annotation" style="color: gray">@Test</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    <em class="lineannotation"><span class="lineannotation">// some logic that should run only for unit and integration test groups</span></em>
}</pre>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@ProfileValueSourceConfiguration</code>
            </strong></span></p>

            <p>Class-level annotation that specifies what type of
            <code class="literal">ProfileValueSource</code> to use when retrieving
            <span class="emphasis"><em>profile values</em></span> configured through the
            <code class="interfacename">@IfProfileValue</code> annotation. If
            <code class="interfacename">@ProfileValueSourceConfiguration</code> is
            not declared for a test,
            <code class="classname">SystemProfileValueSource</code> is used by
            default.</p>

            <pre class="programlisting"><span class="bold"><strong>@ProfileValueSourceConfiguration</strong></span>(CustomProfileValueSource.<span class="hl-keyword">class</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomProfileValueSourceTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
          </li><li class="listitem">
            <p><span class="bold"><strong> <code class="interfacename">@Timed</code>
            </strong></span></p>

            <p>Indicates that the annotated test method must finish
            execution in a specified time period (in milliseconds). If the
            text execution time exceeds the specified time period, the test
            fails.</p>

            <p>The time period includes execution of the test method
            itself, any repetitions of the test (see
            <code class="interfacename">@Repeat</code>), as well as any
            <span class="emphasis"><em>set up</em></span> or <span class="emphasis"><em>tear down</em></span> of
            the test fixture.</p>

            <pre class="programlisting"><span class="bold"><strong>@Timed</strong></span>(millis=<span class="hl-number">1000</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWithOneSecondTimeout() {
    <em class="lineannotation"><span class="lineannotation">// some logic that should not take longer than 1 second to execute</span></em>
}</pre>

            <p>Spring's <code class="interfacename">@Timed</code> annotation
            has different semantics than JUnit's
            <code class="interfacename">@Test(timeout=...)</code> support.
            Specifically, due to the manner in which JUnit handles test
            execution timeouts (that is, by executing the test method in a
            separate <code class="classname">Thread</code>),
            <code class="interfacename">@Test(timeout=...)</code> applies to
            <span class="emphasis"><em>each iteration</em></span> in the case of repetitions and
            preemptively fails the test if the test takes too long. Spring's
            <code class="interfacename">@Timed</code>, on the other hand, times
            the <span class="emphasis"><em>total</em></span> test execution time (including all
            repetitions) and does not preemptively fail the test but rather
            waits for the test to complete before failing.</p>
          </li><li class="listitem">
            <p><span class="bold"><strong>
            <code class="interfacename">@Repeat</code> </strong></span></p>

            <p>Indicates that the annotated test method must be executed
            repeatedly. The number of times that the test method is to be
            executed is specified in the annotation.</p>

            <p>The scope of execution to be repeated includes execution of
            the test method itself as well as any <span class="emphasis"><em>set up</em></span>
            or <span class="emphasis"><em>tear down</em></span> of the test fixture.</p>

            <pre class="programlisting"><span class="bold"><strong>@Repeat</strong></span>(<span class="hl-number">10</span>)
<i><span class="hl-annotation" style="color: gray">@Test</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessRepeatedly() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
          </li></ul></div>
      </div>
    </div>

    <div class="section" title="11.3.5&nbsp;Spring TestContext Framework"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-framework"></a>11.3.5&nbsp;Spring TestContext Framework</h3></div></div></div>
      

      <p>The <span class="emphasis"><em>Spring <code class="classname">TestContext</code>
      Framework</em></span> (located in the
      <code class="literal">org.springframework.test.context</code> package) provides
      generic, annotation-driven unit and integration testing support that is
      agnostic of the testing framework in use. The TestContext framework also
      places a great deal of importance on <span class="emphasis"><em>convention over
      configuration</em></span> with reasonable defaults that can be overridden
      through annotation-based configuration.</p>

      <p>In addition to generic testing infrastructure, the TestContext
      framework provides explicit support for JUnit and TestNG in the form of
      <code class="literal">abstract</code> support classes. For JUnit, Spring also
      provides a custom JUnit <code class="interfacename">Runner</code> that
      allows one to write so-called <span class="emphasis"><em>POJO test classes</em></span>.
      POJO test classes are not required to extend a particular class
      hierarchy.</p>

      <p>The following section provides an overview of the internals of the
      TestContext framework. If you are only interested in using the framework
      and not necessarily interested in extending it with your own custom
      listeners or custom loaders, feel free to go directly to the
      configuration (<a class="link" href="testing.html#testcontext-ctx-management" title="Context management">context
      management</a>, <a class="link" href="testing.html#testcontext-fixture-di" title="Dependency injection of test fixtures">dependency
      injection</a>, <a class="link" href="testing.html#testcontext-tx" title="Transaction management">transaction
      management</a>), <a class="link" href="testing.html#testcontext-support-classes" title="TestContext Framework support classes">support
      classes</a>, and <a class="link" href="testing.html#integration-testing-annotations" title="11.3.4&nbsp;Annotations">annotation support</a>
      sections.</p>

      <div class="section" title="Key abstractions"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-key-abstractions"></a>Key abstractions</h4></div></div></div>
        

        <p>The core of the framework consists of the
        <code class="classname">TestContext</code> and
        <code class="classname">TestContextManager</code> classes and the
        <code class="interfacename">TestExecutionListener</code>,
        <code class="interfacename">ContextLoader</code>, and
        <code class="interfacename">SmartContextLoader</code> interfaces. A
        <code class="classname">TestContextManager</code> is created on a per-test
        basis (e.g., for the execution of a single test method in JUnit). The
        <code class="classname">TestContextManager</code> in turn manages a
        <code class="classname">TestContext</code> that holds the context of the
        current test. The <code class="classname">TestContextManager</code> also
        updates the state of the <code class="classname">TestContext</code> as the
        test progresses and delegates to
        <code class="interfacename">TestExecutionListener</code>s, which
        instrument the actual test execution by providing dependency
        injection, managing transactions, and so on. A
        <code class="interfacename">ContextLoader</code> (or
        <code class="interfacename">SmartContextLoader</code>) is responsible for
        loading an <code class="interfacename">ApplicationContext</code> for a
        given test class. Consult the Javadoc and the Spring test suite for
        further information and examples of various implementations.</p>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p><code class="classname">TestContext</code>: Encapsulates the context
            in which a test is executed, agnostic of the actual testing
            framework in use, and provides context management and caching
            support for the test instance for which it is responsible. The
            <code class="classname">TestContext</code> also delegates to a
            <code class="interfacename">ContextLoader</code> (or
            <code class="interfacename">SmartContextLoader</code>) to load an
            <code class="interfacename">ApplicationContext</code> if
            requested.</p>
          </li><li class="listitem">
            <p><code class="classname">TestContextManager</code>: The main entry
            point into the <span class="emphasis"><em>Spring TestContext Framework</em></span>,
            which manages a single <code class="classname">TestContext</code> and
            signals events to all registered
            <code class="interfacename">TestExecutionListener</code>s at
            well-defined test execution points:</p>

            <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <p>prior to any <span class="emphasis"><em>before class methods</em></span>
                of a particular testing framework</p>
              </li><li class="listitem">
                <p>test instance preparation</p>
              </li><li class="listitem">
                <p>prior to any <span class="emphasis"><em>before methods</em></span> of a
                particular testing framework</p>
              </li><li class="listitem">
                <p>after any <span class="emphasis"><em>after methods</em></span> of a
                particular testing framework</p>
              </li><li class="listitem">
                <p>after any <span class="emphasis"><em>after class methods</em></span> of a
                particular testing framework</p>
              </li></ul></div>
          </li><li class="listitem">
            <p><code class="interfacename">TestExecutionListener</code>:
            Defines a <span class="emphasis"><em>listener</em></span> API for reacting to test
            execution events published by the
            <code class="classname">TestContextManager</code> with which the listener
            is registered.</p>

            <p>Spring provides four
            <code class="interfacename">TestExecutionListener</code>
            implementations that are configured by default:
            <code class="classname">ServletTestExecutionListener</code>,
            <code class="classname">DependencyInjectionTestExecutionListener</code>,
            <code class="classname">DirtiesContextTestExecutionListener</code>, and
            <code class="classname">TransactionalTestExecutionListener</code>.
            Respectively, they support Servlet API mocks for a
            <code class="interfacename">WebApplicationContext</code>, dependency
            injection of the test instance, handling of the
            <code class="interfacename">@DirtiesContext</code> annotation, and
            transactional test execution with default rollback
            semantics.</p>
          </li><li class="listitem">
            <p><code class="interfacename">ContextLoader</code>: Strategy
            interface introduced in Spring 2.5 for loading an
            <code class="interfacename">ApplicationContext</code> for an
            integration test managed by the Spring TestContext
            Framework.</p>

            <p>As of Spring 3.1, implement
            <code class="interfacename">SmartContextLoader</code> instead of this
            interface in order to provide support for annotated classes and
            active bean definition profiles.</p>
          </li><li class="listitem">
            <p><code class="interfacename">SmartContextLoader</code>: Extension
            of the <code class="interfacename">ContextLoader</code> interface
            introduced in Spring 3.1.</p>

            <p>The <code class="interfacename">SmartContextLoader</code> SPI
            supersedes the <code class="interfacename">ContextLoader</code> SPI
            that was introduced in Spring 2.5. Specifically, a
            <code class="interfacename">SmartContextLoader</code> can choose to
            process resource <code class="varname">locations</code>, annotated
            <code class="varname">classes</code>, or context
            <code class="varname">initializers</code>. Furthermore, a
            <code class="interfacename">SmartContextLoader</code> can set active
            bean definition profiles in the context that it loads.</p>

            <p>Spring provides the following implementations:</p>

            <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <p><code class="classname">DelegatingSmartContextLoader</code>: one
                of two default loaders which delegates internally to an
                <code class="classname">AnnotationConfigContextLoader</code> or a
                <code class="classname">GenericXmlContextLoader</code> depending
                either on the configuration declared for the test class or on
                the presence of default locations or default configuration
                classes.</p>
              </li><li class="listitem">
                <p><code class="classname">WebDelegatingSmartContextLoader</code>:
                one of two default loaders which delegates internally to an
                <code class="classname">AnnotationConfigWebContextLoader</code> or a
                <code class="classname">GenericXmlWebContextLoader</code> depending
                either on the configuration declared for the test class or on
                the presence of default locations or default configuration
                classes. A web <code class="interfacename">ContextLoader</code>
                will only be used if
                <code class="interfacename">@WebAppConfiguration</code> is present
                on the test class.</p>
              </li><li class="listitem">
                <p><code class="classname">AnnotationConfigContextLoader</code>:
                loads a standard
                <code class="interfacename">ApplicationContext</code> from
                <span class="emphasis"><em>annotated classes</em></span>.</p>
              </li><li class="listitem">
                <p><code class="classname">AnnotationConfigWebContextLoader</code>:
                loads a <code class="interfacename">WebApplicationContext</code>
                from <span class="emphasis"><em>annotated classes</em></span>.</p>
              </li><li class="listitem">
                <p><code class="classname">GenericXmlContextLoader</code>: loads a
                standard <code class="interfacename">ApplicationContext</code>
                from XML <span class="emphasis"><em>resource locations</em></span>.</p>
              </li><li class="listitem">
                <p><code class="classname">GenericXmlWebContextLoader</code>: loads
                a <code class="interfacename">WebApplicationContext</code> from
                XML <span class="emphasis"><em>resource locations</em></span>.</p>
              </li><li class="listitem">
                <p><code class="classname">GenericPropertiesContextLoader</code>:
                loads a standard
                <code class="interfacename">ApplicationContext</code> from Java
                Properties files.</p>
              </li></ul></div>
          </li></ul></div>

        <p>The following sections explain how to configure the
        <code class="classname">TestContext</code> framework through annotations and
        provide working examples of how to write unit and integration tests
        with the framework.</p>
      </div>

      <div class="section" title="Context management"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management"></a>Context management</h4></div></div></div>
        

        <p>Each <code class="classname">TestContext</code> provides context
        management and caching support for the test instance it is responsible
        for. Test instances do not automatically receive access to the
        configured <code class="interfacename">ApplicationContext</code>. However,
        if a test class implements the
        <code class="interfacename">ApplicationContextAware</code> interface, a
        reference to the <code class="classname">ApplicationContext</code> is supplied
        to the test instance. Note that
        <code class="classname">AbstractJUnit4SpringContextTests</code> and
        <code class="classname">AbstractTestNGSpringContextTests</code> implement
        <code class="interfacename">ApplicationContextAware</code> and therefore
        provide access to the <code class="classname">ApplicationContext</code>
        automatically.</p>

        <div class="tip" title="@Autowired ApplicationContext" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: @Autowired ApplicationContext"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">@Autowired ApplicationContext</th></tr><tr><td align="left" valign="top">
          

          <p>As an alternative to implementing the
          <code class="interfacename">ApplicationContextAware</code> interface,
          you can inject the application context for your test class through
          the <code class="interfacename">@Autowired</code> annotation on either a
          field or setter method. For example:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {

    <span class="bold"><strong>@Autowired</strong></span>
    <span class="hl-keyword">private</span> ApplicationContext applicationContext;

    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

          <p>Similarly, if your test is configured to load a
          <code class="interfacename">WebApplicationContext</code>, you can inject
          the web application context into your test as follows:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<span class="bold"><strong>@WebAppConfiguration</strong></span>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyWebAppTest {

    <span class="bold"><strong>@Autowired</strong></span>
    <span class="hl-keyword">private</span> WebApplicationContext wac;

    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

          <p>Dependency injection via
          <code class="interfacename">@Autowired</code> is provided by the
          <code class="classname">DependencyInjectionTestExecutionListener</code>
          which is configured by default (see <a class="xref" href="testing.html#testcontext-fixture-di" title="Dependency injection of test fixtures">the section called &#8220;Dependency injection of test fixtures&#8221;</a>).</p>
        </td></tr></table></div>

        <p>Test classes that use the TestContext framework do not need to
        extend any particular class or implement a specific interface to
        configure their application context. Instead, configuration is
        achieved simply by declaring the
        <code class="interfacename">@ContextConfiguration</code> annotation at the
        class level. If your test class does not explicitly declare
        application context resource <code class="literal">locations</code> or annotated
        <code class="varname">classes</code>, the configured
        <code class="interfacename">ContextLoader</code> determines how to load a
        context from a default location or default configuration classes. In
        addition to context resource <code class="varname">locations</code> and
        annotated <code class="varname">classes</code>, an application context can also
        be configured via application context
        <code class="varname">initializers</code>.</p>

        <p>The following sections explain how to configure an
        <code class="interfacename">ApplicationContext</code> via XML
        configuration files, annotated classes (typically
        <code class="interfacename">@Configuration</code> classes), or context
        initializers using Spring's
        <code class="interfacename">@ContextConfiguration</code> annotation.
        Alternatively, you can implement and configure your own custom
        <code class="interfacename">SmartContextLoader</code> for advanced use
        cases.</p>

        <div class="section" title="Context configuration with XML resources"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-ctx-management-xml"></a>Context configuration with XML resources</h5></div></div></div>
          

          <p>To load an <code class="interfacename">ApplicationContext</code>
          for your tests using XML configuration files, annotate your test
          class with <code class="interfacename">@ContextConfiguration</code> and
          configure the <code class="literal">locations</code> attribute with an array
          that contains the resource locations of XML configuration metadata.
          A plain or relative path &#8212; for example
          <code class="literal">"context.xml"</code> &#8212; will be treated as a classpath
          resource that is relative to the package in which the test class is
          defined. A path starting with a slash is treated as an absolute
          classpath location, for example
          <code class="literal">"/org/example/config.xml"</code>. A path which
          represents a resource URL (i.e., a path prefixed with
          <code class="literal">classpath:</code>, <code class="literal">file:</code>,
          <code class="literal">http:</code>, etc.) will be used <span class="emphasis"><em>as
          is</em></span>.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath</span></em>
<span class="bold"><strong>@ContextConfiguration(locations={"/app-config.xml", "/test-config.xml"})</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

          <p><code class="interfacename">@ContextConfiguration</code> supports
          an alias for the <code class="literal">locations</code> attribute through the
          standard Java <code class="literal">value</code> attribute. Thus, if you do
          not need to declare additional attributes in
          <code class="interfacename">@ContextConfiguration</code>, you can omit
          the declaration of the <code class="literal">locations</code> attribute name
          and declare the resource locations by using the shorthand format
          demonstrated in the following example.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<span class="bold"><strong>@ContextConfiguration({"/app-config.xml", "/test-config.xml"})</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

          <p>If you omit both the <code class="varname">locations</code> and
          <code class="varname">value</code> attributes from the
          <code class="interfacename">@ContextConfiguration</code> annotation, the
          TestContext framework will attempt to detect a default XML resource
          location. Specifically,
          <code class="classname">GenericXmlContextLoader</code> detects a default
          location based on the name of the test class. If your class is named
          <code class="literal">com.example.MyTest</code>,
          <code class="classname">GenericXmlContextLoader</code> loads your
          application context from
          <code class="literal">"classpath:/com/example/MyTest-context.xml"</code>.</p>

          <pre class="programlisting"><span class="hl-keyword">package</span> com.example;

<i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from
// "classpath:/com/example/MyTest-context.xml"</span></em>
<span class="bold"><strong>@ContextConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
        </div>

        <div class="section" title="Context configuration with annotated classes"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-ctx-management-javaconfig"></a>Context configuration with annotated classes</h5></div></div></div>
          

          <p>To load an <code class="interfacename">ApplicationContext</code>
          for your tests using <span class="emphasis"><em>annotated classes</em></span> (see
          <a class="xref" href="beans.html#beans-java" title="5.12&nbsp;Java-based container configuration">Section&nbsp;5.12, &#8220;Java-based container configuration&#8221;</a>), annotate your test class with
          <code class="interfacename">@ContextConfiguration</code> and configure
          the <code class="literal">classes</code> attribute with an array that contains
          references to annotated classes.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from AppConfig and TestConfig</span></em>
<span class="bold"><strong>@ContextConfiguration(classes = {AppConfig.class, TestConfig.class})</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

          <p>If you omit the <code class="varname">classes</code> attribute from the
          <code class="interfacename">@ContextConfiguration</code> annotation, the
          TestContext framework will attempt to detect the presence of default
          configuration classes. Specifically,
          <code class="classname">AnnotationConfigContextLoader</code> will detect all
          static inner classes of the test class that meet the requirements
          for configuration class implementations as specified in the Javadoc
          for <code class="interfacename">@Configuration</code>. In the following
          example, the <code class="classname">OrderServiceTest</code> class declares
          a static inner configuration class named
          <code class="classname">Config</code> that will be automatically used to
          load the <code class="interfacename">ApplicationContext</code> for the
          test class. Note that the name of the configuration class is
          arbitrary. In addition, a test class can contain more than one
          static inner configuration class if desired.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from the
// static inner Config class</span></em>
<span class="bold"><strong>@ContextConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OrderServiceTest {

    <i><span class="hl-annotation" style="color: gray">@Configuration</span></i>
    <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> Config {

        <em class="lineannotation"><span class="lineannotation">// this bean will be injected into the OrderServiceTest class</span></em>
        <i><span class="hl-annotation" style="color: gray">@Bean</span></i>
        <span class="hl-keyword">public</span> OrderService orderService() {
            OrderService orderService = <span class="hl-keyword">new</span> OrderServiceImpl();
            <em class="lineannotation"><span class="lineannotation">// set properties, etc.</span></em>
            <span class="hl-keyword">return</span> orderService;
        }
    }

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">private</span> OrderService orderService;

    <i><span class="hl-annotation" style="color: gray">@Test</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testOrderService() {
        <em class="lineannotation"><span class="lineannotation">// test the orderService</span></em>
    }

}</pre>
        </div>

        <div class="section" title="Mixing XML resources and annotated classes"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-ctx-management-mixed-config"></a>Mixing XML resources and annotated classes</h5></div></div></div>
          

          <p>It may sometimes be desirable to mix XML resources and
          annotated classes (i.e., typically
          <code class="interfacename">@Configuration</code> classes) to configure
          an <code class="interfacename">ApplicationContext</code> for your tests.
          For example, if you use XML configuration in production, you may
          decide that you want to use
          <code class="interfacename">@Configuration</code> classes to configure
          specific Spring-managed components for your tests, or vice versa. As
          mentioned in <a class="xref" href="testing.html#integration-testing-annotations-spring" title="Spring Testing Annotations">the section called &#8220;Spring Testing Annotations&#8221;</a> the TestContext
          framework does not allow you to declare <span class="emphasis"><em>both</em></span>
          via <code class="interfacename">@ContextConfiguration</code>, but this
          does not mean that you cannot use both.</p>

          <p>If you want to use XML <span class="bold"><strong>and</strong></span>
          <code class="interfacename">@Configuration</code> classes to configure
          your tests, you will have to pick one as the <span class="emphasis"><em>entry
          point</em></span>, and that one will have to include or import the
          other. For example, in XML you can include
          <code class="interfacename">@Configuration</code> classes via component
          scanning or define them as normal Spring beans in XML; whereas, in a
          <code class="interfacename">@Configuration</code> class you can use
          <code class="interfacename">@ImportResource</code> to import XML
          configuration files. Note that this behavior is semantically
          equivalent to how you configure your application in production: in
          production configuration you will define either a set of XML
          resource locations or a set of
          <code class="interfacename">@Configuration</code> classes that your
          production <code class="interfacename">ApplicationContext</code> will be
          loaded from, but you still have the freedom to include or import the
          other type of configuration.</p>
        </div>

        <div class="section" title="Context configuration with context initializers"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-ctx-management-initializers"></a>Context configuration with context initializers</h5></div></div></div>
          

          <p>To configure an
          <code class="interfacename">ApplicationContext</code> for your tests
          using context initializers, annotate your test class with
          <code class="interfacename">@ContextConfiguration</code> and configure
          the <code class="literal">initializers</code> attribute with an array that
          contains references to classes that implement
          <code class="interfacename">ApplicationContextInitializer</code>. The
          declared context initializers will then be used to initialize the
          <code class="interfacename">ConfigurableApplicationContext</code> that
          is loaded for your tests. Note that the concrete
          <code class="interfacename">ConfigurableApplicationContext</code> type
          supported by each declared initializer must be compatible with the
          type of <code class="interfacename">ApplicationContext</code> created by
          the <code class="interfacename">SmartContextLoader</code> in use (i.e.,
          typically a <code class="classname">GenericApplicationContext</code>).
          Furthermore, the order in which the initializers are invoked depends
          on whether they implement Spring's
          <code class="interfacename">Ordered</code> interface or are annotated
          with Spring's <code class="interfacename">@Order</code>
          annotation.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from TestConfig
</span></em><em class="lineannotation"><span class="lineannotation">// and initialized by TestAppCtxInitializer</span></em>
<span class="bold"><strong>@ContextConfiguration(
    classes = TestConfig.class,
    initializers = TestAppCtxInitializer.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

          <p>It is also possible to omit the declaration of XML
          configuration files or annotated classes in
          <code class="interfacename">@ContextConfiguration</code> entirely and
          instead declare only
          <code class="interfacename">ApplicationContextInitializer</code> classes
          which are then responsible for registering beans in the context &#8212;
          for example, by programmatically loading bean definitions from XML
          files or configuration classes.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be initialized by EntireAppInitializer
</span></em><em class="lineannotation"><span class="lineannotation">// which presumably registers beans in the context</span></em>
<span class="bold"><strong>@ContextConfiguration(initializers = EntireAppInitializer.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
        </div>

        <div class="section" title="Context configuration inheritance"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-ctx-management-inheritance"></a>Context configuration inheritance</h5></div></div></div>
          

          <p><code class="interfacename">@ContextConfiguration</code> supports
          boolean <code class="varname">inheritLocations</code> and
          <code class="varname">inheritInitializers</code> attributes that denote
          whether resource locations or annotated classes and context
          initializers declared by superclasses should be
          <span class="emphasis"><em>inherited</em></span>. The default value for both flags is
          <code class="literal">true</code>. This means that a test class inherits the
          resource locations or annotated classes as well as the context
          initializers declared by any superclasses. Specifically, the
          resource locations or annotated classes for a test class are
          appended to the list of resource locations or annotated classes
          declared by superclasses. Similarly, the initializers for a given
          test class will be added to the set of initializers defined by test
          superclasses. Thus, subclasses have the option of
          <span class="emphasis"><em>extending</em></span> the resource locations, annotated
          classes, or context initializers.</p>

          <p>If <code class="interfacename">@ContextConfiguration</code>'s
          <code class="literal">inheritLocations</code> or
          <code class="varname">inheritInitializers</code> attribute is set to
          <code class="literal">false</code>, the resource locations or annotated
          classes and the context initializers, respectively, for the test
          class <span class="emphasis"><em>shadow</em></span> and effectively replace the
          configuration defined by superclasses.</p>

          <p>In the following example that uses XML resource locations, the
          <code class="interfacename">ApplicationContext</code> for
          <code class="classname">ExtendedTest</code> will be loaded from
          <span class="emphasis"><em>"base-config.xml"</em></span> <span class="bold"><strong>and</strong></span>
          <span class="emphasis"><em>"extended-config.xml"</em></span>, in that order. Beans
          defined in <span class="emphasis"><em>"extended-config.xml"</em></span> may therefore
          <span class="emphasis"><em>override</em></span> (i.e., replace) those defined in
          <span class="emphasis"><em>"base-config.xml"</em></span>.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath</span></em>
<span class="bold"><strong>@ContextConfiguration("/base-config.xml")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}

<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" </span></em><em class="lineannotation"><span class="lineannotation">in the root of the classpath</span></em>
<span class="bold"><strong>@ContextConfiguration("/extended-config.xml")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTest <span class="hl-keyword">extends</span> BaseTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

          <p>Similarly, in the following example that uses annotated
          classes, the <code class="interfacename">ApplicationContext</code> for
          <code class="classname">ExtendedTest</code> will be loaded from the
          <code class="classname">BaseConfig</code> <span class="bold"><strong>and</strong></span> <code class="classname">ExtendedConfig</code>
          classes, in that order. Beans defined in
          <code class="classname">ExtendedConfig</code> may therefore override (i.e.,
          replace) those defined in <code class="classname">BaseConfig</code>.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from BaseConfig</span></em>
<span class="bold"><strong>@ContextConfiguration(classes = BaseConfig.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}

<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from BaseConfig and ExtendedConfig</span></em>
<span class="bold"><strong>@ContextConfiguration(classes = ExtendedConfig.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTest <span class="hl-keyword">extends</span> BaseTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>

          <p>In the following example that uses context initializers, the
          <code class="interfacename">ApplicationContext</code> for
          <code class="classname">ExtendedTest</code> will be initialized using
          <code class="classname">BaseInitializer</code> <span class="bold"><strong>and</strong></span>
          <code class="classname">ExtendedInitializer</code>. Note, however, that the
          order in which the initializers are invoked depends on whether they
          implement Spring's <code class="interfacename">Ordered</code> interface
          or are annotated with Spring's <code class="interfacename">@Order</code>
          annotation.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be initialized by BaseInitializer</span></em>
<span class="bold"><strong>@ContextConfiguration(initializers=BaseInitializer.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}

<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer</span></em>
<span class="bold"><strong>@ContextConfiguration(initializers=ExtendedInitializer.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTest <span class="hl-keyword">extends</span> BaseTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
        </div>

        <div class="section" title="Context configuration with environment profiles"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-ctx-management-env-profiles"></a>Context configuration with environment profiles</h5></div></div></div>
          

          <p>Spring 3.1 introduced first-class support in the framework for
          the notion of environments and profiles (a.k.a., <span class="emphasis"><em>bean
          definition profiles</em></span>), and integration tests can be
          configured to activate particular bean definition profiles for
          various testing scenarios. This is achieved by annotating a test
          class with the <code class="interfacename">@ActiveProfiles</code>
          annotation and supplying a list of profiles that should be activated
          when loading the <code class="interfacename">ApplicationContext</code>
          for the test.</p>

          <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
            <p><code class="interfacename">@ActiveProfiles</code> may be used
            with any implementation of the new
            <code class="interfacename">SmartContextLoader</code> SPI, but
            <code class="interfacename">@ActiveProfiles</code> is not supported
            with implementations of the older
            <code class="interfacename">ContextLoader</code> SPI.</p>
          </td></tr></table></div>

          <p>Let's take a look at some examples with XML configuration and
          <code class="interfacename">@Configuration</code> classes.</p>

          <pre class="programlisting"><span class="hl-comment">&lt;!-- app-config.xml --&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:jdbc</span>=<span class="hl-value">"http://www.springframework.org/schema/jdbc"</span>
    <span class="hl-attribute">xmlns:jee</span>=<span class="hl-value">"http://www.springframework.org/schema/jee"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"..."</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transferService"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"com.bank.service.internal.DefaultTransferService"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accountRepository"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"feePolicy"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"accountRepository"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"com.bank.repository.internal.JdbcAccountRepository"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"feePolicy"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"com.bank.service.internal.ZeroFeePolicy"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;beans</span> <span class="hl-attribute">profile</span>=<span class="hl-value">"dev"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;jdbc:embedded-database</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;jdbc:script</span>
                <span class="hl-attribute">location</span>=<span class="hl-value">"classpath:com/bank/config/sql/schema.sql"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;jdbc:script</span>
                <span class="hl-attribute">location</span>=<span class="hl-value">"classpath:com/bank/config/sql/test-data.sql"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/jdbc:embedded-database&gt;</span>
    <span class="hl-tag">&lt;/beans&gt;</span>

    <span class="hl-tag">&lt;beans</span> <span class="hl-attribute">profile</span>=<span class="hl-value">"production"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span>
            <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"java:comp/env/jdbc/datasource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/beans&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

          <pre class="programlisting"><span class="hl-keyword">package</span> com.bank.service;

<i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<span class="hl-comment">// ApplicationContext will be loaded from "classpath:/app-config.xml"</span>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration("/app-config.xml")</span></i>
<i><span class="hl-annotation" style="color: gray">@ActiveProfiles("dev")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransferServiceTest {

   <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
   <span class="hl-keyword">private</span> TransferService transferService;

   <i><span class="hl-annotation" style="color: gray">@Test</span></i>
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testTransferService() {
       <span class="hl-comment">// test the transferService</span>
   }
}</pre>

          <p>When <code class="classname">TransferServiceTest</code> is run, its
          <code class="interfacename">ApplicationContext</code> will be loaded
          from the <code class="filename">app-config.xml</code> configuration file in
          the root of the classpath. If you inspect
          <code class="filename">app-config.xml</code> you'll notice that the
          <code class="varname">accountRepository</code> bean has a dependency on a
          <code class="varname">dataSource</code> bean; however,
          <code class="varname">dataSource</code> is not defined as a top-level bean.
          Instead, <code class="varname">dataSource</code> is defined twice: once in the
          <span class="emphasis"><em>production</em></span> profile and once in the
          <span class="emphasis"><em>dev</em></span> profile.</p>

          <p>By annotating <code class="classname">TransferServiceTest</code> with
          <code class="interfacename">@ActiveProfiles("dev")</code> we instruct
          the Spring TestContext Framework to load the
          <code class="interfacename">ApplicationContext</code> with the active
          profiles set to <code class="literal">{"dev"}</code>. As a result, an embedded
          database will be created, and the
          <code class="varname">accountRepository</code> bean will be wired with a
          reference to the development
          <code class="interfacename">DataSource</code>. And that's likely what we
          want in an integration test.</p>

          <p>The following code listings demonstrate how to implement the
          same configuration and integration test but using
          <code class="interfacename">@Configuration</code> classes instead of
          XML.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Configuration</span></i>
<i><span class="hl-annotation" style="color: gray">@Profile("dev")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> StandaloneDataConfig {

    <i><span class="hl-annotation" style="color: gray">@Bean</span></i>
    <span class="hl-keyword">public</span> DataSource dataSource() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(<span class="hl-string">"classpath:com/bank/config/sql/schema.sql"</span>)
            .addScript(<span class="hl-string">"classpath:com/bank/config/sql/test-data.sql"</span>)
            .build();
    }
}</pre>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Configuration</span></i>
<i><span class="hl-annotation" style="color: gray">@Profile("production")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JndiDataConfig {

    <i><span class="hl-annotation" style="color: gray">@Bean</span></i>
    <span class="hl-keyword">public</span> DataSource dataSource() <span class="hl-keyword">throws</span> Exception {
        Context ctx = <span class="hl-keyword">new</span> InitialContext();
        <span class="hl-keyword">return</span> (DataSource) ctx.lookup(<span class="hl-string">"java:comp/env/jdbc/datasource"</span>);
    }
}</pre>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Configuration</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransferServiceConfig {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> DataSource dataSource;

    <i><span class="hl-annotation" style="color: gray">@Bean</span></i>
    <span class="hl-keyword">public</span> TransferService transferService() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DefaultTransferService(accountRepository(),
            feePolicy());
    }

    <i><span class="hl-annotation" style="color: gray">@Bean</span></i>
    <span class="hl-keyword">public</span> AccountRepository accountRepository() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> JdbcAccountRepository(dataSource);
    }

    <i><span class="hl-annotation" style="color: gray">@Bean</span></i>
    <span class="hl-keyword">public</span> FeePolicy feePolicy() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> ZeroFeePolicy();
    }

}</pre>

          <pre class="programlisting"><span class="hl-keyword">package</span> com.bank.service;

<i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration(
   classes = {
       TransferServiceConfig.class,
       StandaloneDataConfig.class,
       JndiDataConfig.class})</span></i>
<i><span class="hl-annotation" style="color: gray">@ActiveProfiles("dev")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransferServiceTest {

   <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
   <span class="hl-keyword">private</span> TransferService transferService;

   <i><span class="hl-annotation" style="color: gray">@Test</span></i>
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testTransferService() {
       <span class="hl-comment">// test the transferService</span>
   }
}</pre>

          <p>In this variation, we have split the XML configuration into
          three independent <code class="interfacename">@Configuration</code>
          classes:</p>

          <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <p><code class="classname">TransferServiceConfig</code>: acquires a
              <code class="varname">dataSource</code> via dependency injection using
              <code class="interfacename">@Autowired</code></p>
            </li><li class="listitem">
              <p><code class="classname">StandaloneDataConfig</code>: defines a
              <code class="varname">dataSource</code> for an embedded database suitable
              for developer tests</p>
            </li><li class="listitem">
              <p><code class="classname">JndiDataConfig</code>: defines a
              <code class="varname">dataSource</code> that is retrieved from JNDI in a
              production environment</p>
            </li></ul></div>

          <p>As with the XML-based configuration example, we still annotate
          <code class="classname">TransferServiceTest</code> with
          <code class="interfacename">@ActiveProfiles("dev")</code>, but this time
          we specify all three configuration classes via the
          <code class="interfacename">@ContextConfiguration </code>annotation. The
          body of the test class itself remains completely unchanged.</p>

          
        </div>

        <div class="section" title="Loading a WebApplicationContext"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-ctx-management-web"></a>Loading a WebApplicationContext</h5></div></div></div>
          

          <p>Spring 3.2 introduces support for loading a
          <code class="interfacename">WebApplicationContext</code> in integration
          tests. To instruct the TestContext framework to load a
          <code class="interfacename">WebApplicationContext</code> instead of a
          standard <code class="interfacename">ApplicationContext</code>, simply
          annotate the respective test class with
          <code class="interfacename">@WebAppConfiguration</code>.</p>

          <p>The presence of
          <code class="interfacename">@WebAppConfiguration</code> on your test
          class instructs the TestContext framework (TCF) that a
          <code class="interfacename">WebApplicationContext</code> (WAC) should be
          loaded for your integration tests. In the background the TCF makes
          sure that a <code class="interfacename">MockServletContext</code> is
          created and supplied to your test's WAC. By default the base
          resource path for your
          <code class="interfacename">MockServletContext</code> will be set to
          <span class="emphasis"><em>"src/main/webapp"</em></span>. This is interpreted as a
          path relative to the root of your JVM (i.e., normally the path to
          your project). If you're familiar with the directory structure of a
          web application in a Maven project, you'll know that
          <span class="emphasis"><em>"src/main/webapp"</em></span> is the default location for
          the root of your WAR. If you need to override this default, simply
          provide an alternate path to the
          <code class="interfacename">@WebAppConfiguration</code> annotation
          (e.g.,
          <code class="interfacename">@WebAppConfiguration("src/test/webapp")</code>).
          If you wish to reference a base resource path from the classpath
          instead of the file system, just use Spring's
          <span class="emphasis"><em>classpath:</em></span> prefix.</p>

          <p>Please note that Spring's testing support for
          <code class="interfacename">WebApplicationContexts</code> is on par with
          its support for standard
          <code class="interfacename">ApplicationContexts</code>. When testing
          with a <code class="interfacename">WebApplicationContext</code> you are
          free to declare either XML configuration files or
          <code class="interfacename">@Configuration</code> classes via
          <code class="interfacename">@ContextConfiguration</code>. You are of
          course also free to use any other test annotations such as
          <code class="interfacename">@TestExecutionListeners</code>,
          <code class="interfacename">@TransactionConfiguration</code>,
          <code class="interfacename">@ActiveProfiles</code>, etc.</p>

          <p>The following examples demonstrate some of the various
          configuration options for loading a
          <code class="interfacename">WebApplicationContext</code>.</p>

          <div class="example"><a name="d4e9075"></a><p class="title"><b>Example&nbsp;11.1.&nbsp;Conventions</b></p><div class="example-contents">
            

            <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>

<span class="hl-comment">// defaults to "file:src/main/webapp"</span>
<i><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></i>

<span class="hl-comment">// detects "WacTests-context.xml" in same package</span>
<span class="hl-comment">// or static nested @Configuration class</span>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WacTests {
    <span class="hl-comment">//...</span>
}</pre>
          </div></div><br class="example-break">

          <p>The above example demonstrates the TestContext framework's
          support for <span class="emphasis"><em>convention over configuration</em></span>. If
          you annotate a test class with
          <code class="interfacename">@WebAppConfiguration</code> without
          specifying a resource base path, the resource path will effectively
          default to <span class="emphasis"><em>"file:src/main/webapp"</em></span>. Similarly,
          if you declare <code class="interfacename">@ContextConfiguration</code>
          without specifying resource
          <code class="interfacename">locations</code>, annotated
          <code class="interfacename">classes</code>, or context
          <code class="interfacename">initializers</code>, Spring will attempt to
          detect the presence of your configuration using conventions (i.e.,
          <span class="emphasis"><em>"WacTests-context.xml"</em></span> in the same package as
          the <code class="interfacename">WacTests</code> class or static nested
          <code class="interfacename">@Configuration</code> classes).</p>

          <div class="example"><a name="d4e9089"></a><p class="title"><b>Example&nbsp;11.2.&nbsp;Default Resource Semantics</b></p><div class="example-contents">
            

            <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>

<span class="hl-comment">// file system resource</span>
<i><span class="hl-annotation" style="color: gray">@WebAppConfiguration("webapp")</span></i>

<span class="hl-comment">// classpath resource</span>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration("/spring/test-servlet-config.xml")</span></i>

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WacTests {
    <span class="hl-comment">//...</span>
}</pre>
          </div></div><br class="example-break">

          <p>This example demonstrates how to explicitly declare a resource
          base path with <code class="interfacename">@WebAppConfiguration</code>
          and an XML resource location with
          <code class="interfacename">@ContextConfiguration</code>. The important
          thing to note here is the different semantics for paths with these
          two annotations. By default,
          <code class="interfacename">@WebAppConfiguration</code> resource paths
          are file system based; whereas,
          <code class="interfacename">@ContextConfiguration</code> resource
          locations are classpath based.</p>

          <div class="example"><a name="d4e9097"></a><p class="title"><b>Example&nbsp;11.3.&nbsp;Explicit Resource Semantics</b></p><div class="example-contents">
            

            <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>

<span class="hl-comment">// classpath resource</span>
<i><span class="hl-annotation" style="color: gray">@WebAppConfiguration("classpath:test-web-resources")</span></i>

<span class="hl-comment">// file system resource</span>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")</span></i>

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WacTests {
    <span class="hl-comment">//...</span>
}</pre>
          </div></div><br class="example-break">

          <p>In this third example, we see that we can override the default
          resource semantics for both annotations by specifying a Spring
          resource prefix. Contrast the comments in this example with the
          previous example.</p>

          <div class="section" title="Working with Web Mocks"><div class="titlepage"><div><div><h6 class="title"><a name="testcontext-ctx-management-web-mocks"></a>Working with Web Mocks</h6></div></div></div>
            

            <p>To provide comprehensive web testing support, Spring 3.2
            introduces a new
            <code class="interfacename">ServletTestExecutionListener</code> that
            is enabled by default. When testing against a
            <code class="interfacename">WebApplicationContext</code> this <a class="link" href="testing.html#testcontext-key-abstractions" title="Key abstractions">TestExecutionListener</a>
            sets up default thread-local state via Spring Web's
            <code class="interfacename">RequestContextHolder</code> before each
            test method and creates a
            <code class="interfacename">MockHttpServletRequest</code>,
            <code class="interfacename">MockHttpServletResponse</code>, and
            <code class="interfacename">ServletWebRequest</code> based on the base
            resource path configured via
            <code class="interfacename">@WebAppConfiguration</code>.
            <code class="interfacename">ServletTestExecutionListener</code> also
            ensures that the
            <code class="interfacename">MockHttpServletResponse</code> and
            <code class="interfacename">ServletWebRequest</code> can be injected
            into the test instance, and once the test is complete it cleans up
            thread-local state.</p>

            <p>Once you have a
            <code class="interfacename">WebApplicationContext</code> loaded for
            your test you might find that you need to interact with the web
            mocks &#8212; for example, to set up your test fixture or to perform
            assertions after invoking your web component. The following
            example demonstrates which mocks can be autowired into your test
            instance. Note that the
            <code class="interfacename">WebApplicationContext</code> and
            <code class="interfacename">MockServletContext</code> are both cached
            across the test suite; whereas, the other mocks are managed per
            test method by the
            <code class="interfacename">ServletTestExecutionListener</code>.</p>

            <div class="example"><a name="d4e9120"></a><p class="title"><b>Example&nbsp;11.4.&nbsp;Injecting Mocks</b></p><div class="example-contents">
              

              <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></i>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WacTests {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> WebApplicationContext wac; <span class="hl-comment">// cached</span>

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> MockServletContext servletContext; <span class="hl-comment">// cached</span>

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> MockHttpSession session;

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> MockHttpServletRequest request;

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> MockHttpServletResponse response;

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> ServletWebRequest webRequest;

    <span class="hl-comment">//...</span>
}</pre>
            </div></div><br class="example-break">
          </div>
        </div>

        <div class="section" title="Context caching"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-ctx-management-caching"></a>Context caching</h5></div></div></div>
          

          <p>Once the TestContext framework loads an
          <code class="interfacename">ApplicationContext</code> (or
          <code class="interfacename">WebApplicationContext</code>) for a test,
          that context will be cached and reused for <span class="bold"><strong>all</strong></span> subsequent tests that declare the same
          unique context configuration within the same test suite. To
          understand how caching works, it is important to understand what is
          meant by <span class="emphasis"><em>unique</em></span> and <span class="emphasis"><em>test
          suite</em></span>.</p>

          <p>An <code class="interfacename">ApplicationContext</code> can be
          <span class="emphasis"><em>uniquely</em></span> identified by the combination of
          configuration parameters that are used to load it. Consequently, the
          unique combination of configuration parameters are used to generate
          a <span class="emphasis"><em>key</em></span> under which the context is cached. The
          TestContext framework uses the following configuration parameters to
          build the context cache key:</p>

          <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <p><code class="varname">locations</code> <span class="emphasis"><em>(from
              @ContextConfiguration)</em></span></p>
            </li><li class="listitem">
              <p><code class="varname">classes</code> <span class="emphasis"><em>(from
              @ContextConfiguration)</em></span></p>
            </li><li class="listitem">
              <p><code class="varname">contextInitializerClasses</code>
              <span class="emphasis"><em>(from @ContextConfiguration)</em></span></p>
            </li><li class="listitem">
              <p><code class="varname">contextLoader</code> <span class="emphasis"><em>(from
              @ContextConfiguration)</em></span></p>
            </li><li class="listitem">
              <p><code class="varname">activeProfiles</code> <span class="emphasis"><em>(from
              @ActiveProfiles)</em></span></p>
            </li><li class="listitem">
              <p><code class="varname">resourceBasePath</code> <span class="emphasis"><em>(from
              @WebAppConfiguration)</em></span></p>
            </li></ul></div>

          <p>For example, if <code class="classname">TestClassA</code> specifies
          <code class="literal">{"app-config.xml", "test-config.xml"}</code> for the
          <code class="varname">locations</code> (or <code class="varname">value</code>) attribute
          of <code class="interfacename">@ContextConfiguration</code>, the
          TestContext framework will load the corresponding
          <code class="interfacename">ApplicationContext</code> and store it in a
          <code class="varname">static</code> context cache under a key that is based
          solely on those locations. So if <code class="classname">TestClassB</code>
          also defines <code class="literal">{"app-config.xml",
          "test-config.xml"}</code> for its locations (either explicitly or
          implicitly through inheritance) but does not define
          <code class="interfacename">@WebAppConfiguration</code>, a different
          <code class="interfacename">ContextLoader</code>, different active
          profiles, or different context initializers, then the same
          <code class="interfacename">ApplicationContext</code> will be shared by
          both test classes. This means that the setup cost for loading an
          application context is incurred only once (per test suite), and
          subsequent test execution is much faster.</p>

          <div class="note" title="Test suites and forked processes" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Test suites and forked processes"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Test suites and forked processes</th></tr><tr><td align="left" valign="top">
            

            <p>The Spring TestContext framework stores application contexts
            in a <span class="emphasis"><em>static</em></span> cache. This means that the
            context is literally stored in a <code class="varname">static</code>
            variable. In other words, if tests execute in separate processes
            the static cache will be cleared between each test execution, and
            this will effectively disable the caching mechanism.</p>

            <p>To benefit from the caching mechanism, all tests must run
            within the same process or test suite. This can be achieved by
            executing all tests as a group within an IDE. Similarly, when
            executing tests with a build framework such as Ant, Maven, or
            Gradle it is important to make sure that the build framework does
            not <span class="emphasis"><em>fork</em></span> between tests. For example, if the
            <a class="ulink" href="http://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode" target="_top">forkMode</a>
            for the Maven Surefire plug-in is set to <code class="literal">always</code>
            or <code class="literal">pertest</code>, the TestContext framework will not
            be able to cache application contexts between test classes and the
            build process will run significantly slower as a result.</p>
          </td></tr></table></div>

          <p>In the unlikely case that a test corrupts the application
          context and requires reloading &#8212; for example, by modifying a bean
          definition or the state of an application object &#8212; you can annotate
          your test class or test method with
          <code class="interfacename">@DirtiesContext</code> (see the discussion
          of <code class="interfacename">@DirtiesContext</code> in <a class="xref" href="testing.html#integration-testing-annotations-spring" title="Spring Testing Annotations">the section called &#8220;Spring Testing Annotations&#8221;</a>). This instructs
          Spring to remove the context from the cache and rebuild the
          application context before executing the next test. Note that
          support for the <code class="interfacename">@DirtiesContext</code>
          annotation is provided by the
          <code class="classname">DirtiesContextTestExecutionListener</code> which is
          enabled by default.</p>
        </div>
      </div>

      <div class="section" title="Dependency injection of test fixtures"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-fixture-di"></a>Dependency injection of test fixtures</h4></div></div></div>
        

        <p>When you use the
        <code class="classname">DependencyInjectionTestExecutionListener</code> &#8212;
        which is configured by default &#8212; the dependencies of your test
        instances are <span class="emphasis"><em>injected</em></span> from beans in the
        application context that you configured with
        <code class="interfacename">@ContextConfiguration</code>. You may use
        setter injection, field injection, or both, depending on which
        annotations you choose and whether you place them on setter methods or
        fields. For consistency with the annotation support introduced in
        Spring 2.5 and 3.0, you can use Spring's
        <code class="interfacename">@Autowired</code> annotation or the
        <code class="interfacename">@Inject</code> annotation from JSR 300.</p>

        <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
          <p>The TestContext framework does not instrument the manner in
          which a test instance is instantiated. Thus the use of
          <code class="interfacename">@Autowired</code> or
          <code class="interfacename">@Inject</code> for constructors has no
          effect for test classes.</p>
        </td></tr></table></div>

        <p>Because <code class="interfacename">@Autowired</code> is used to
        perform <a class="link" href="beans.html#beans-factory-autowire" title="5.4.5&nbsp;Autowiring collaborators"> <span class="emphasis"><em>autowiring
        by type</em></span> </a>, if you have multiple bean definitions of
        the same type, you cannot rely on this approach for those particular
        beans. In that case, you can use
        <code class="interfacename">@Autowired</code> in conjunction with
        <code class="interfacename">@Qualifier</code>. As of Spring 3.0 you may
        also choose to use <code class="interfacename">@Inject</code> in
        conjunction with <code class="interfacename">@Named</code>. Alternatively,
        if your test class has access to its
        <code class="classname">ApplicationContext</code>, you can perform an explicit
        lookup by using (for example) a call to
        <code class="methodname">applicationContext.getBean("titleRepository")</code>.</p>

        <p>If you do not want dependency injection applied to your test
        instances, simply do not annotate fields or setter methods with
        <code class="interfacename">@Autowired</code> or
        <code class="interfacename">@Inject</code>. Alternatively, you can disable
        dependency injection altogether by explicitly configuring your class
        with <code class="interfacename">@TestExecutionListeners</code> and
        omitting
        <code class="literal">DependencyInjectionTestExecutionListener.class</code> from
        the list of listeners.</p>

        <p>Consider the scenario of testing a
        <code class="classname">HibernateTitleRepository</code> class, as outlined in
        the <a class="link" href="testing.html#integration-testing-goals" title="11.3.2&nbsp;Goals of Integration Testing">Goals</a> section.
        The next two code listings demonstrate the use of
        <code class="interfacename">@Autowired</code> on fields and setter
        methods. The application context configuration is presented after all
        sample code listings.</p>

        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p>The dependency injection behavior in the following code
          listings is not specific to JUnit. The same DI techniques can be
          used in conjunction with any testing framework.</p>

          <p>The following examples make calls to static assertion methods
          such as <code class="literal">assertNotNull()</code> but without prepending
          the call with <code class="literal">Assert</code>. In such cases, assume that
          the method was properly imported through an <code class="literal">import
          static</code> declaration that is not shown in the
          example.</p>
        </td></tr></table></div>

        <p>The first code listing shows a JUnit-based implementation of the
        test class that uses <code class="interfacename">@Autowired</code> for
        field injection.</p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></em>
<span class="bold"><strong>@ContextConfiguration("repository-config.xml")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HibernateTitleRepositoryTests {

    <em class="lineannotation"><span class="lineannotation">// this instance will be dependency injected by type</span></em>
    <span class="bold"><strong>@Autowired</strong></span>
    <span class="hl-keyword">private</span> HibernateTitleRepository titleRepository;

    <i><span class="hl-annotation" style="color: gray">@Test</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> findById() {
        Title title = titleRepository.findById(<span class="hl-keyword">new</span> Long(<span class="hl-number">10</span>));
        assertNotNull(title);
    }
}</pre>

        <p>Alternatively, you can configure the class to use
        <code class="interfacename">@Autowired</code> for setter injection as seen
        below.</p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<em class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></em>
<span class="bold"><strong>@ContextConfiguration("repository-config.xml")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HibernateTitleRepositoryTests {

    <em class="lineannotation"><span class="lineannotation">// this instance will be dependency injected by type</span></em>
    <span class="hl-keyword">private</span> HibernateTitleRepository titleRepository;

    <span class="bold"><strong>@Autowired</strong></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTitleRepository(HibernateTitleRepository titleRepository) {
        <span class="hl-keyword">this</span>.titleRepository = titleRepository;
    }

    <i><span class="hl-annotation" style="color: gray">@Test</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> findById() {
        Title title = titleRepository.findById(<span class="hl-keyword">new</span> Long(<span class="hl-number">10</span>));
        assertNotNull(title);
    }
}</pre>

        <p>The preceding code listings use the same XML context file
        referenced by the <code class="interfacename">@ContextConfiguration</code>
        annotation (that is, <code class="literal">repository-config.xml</code>), which
        looks like this:</p>

        <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="hl-tag">&gt;</span>

    <em class="lineannotation"><span class="lineannotation">&lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --&gt;</span></em>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"</span><span class="bold"><strong>titleRepository</strong></span>" class="<span class="bold"><strong>com.foo.repository.hibernate.HibernateTitleRepository</strong></span>"&gt;
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sessionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sessionFactory"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span><span class="hl-tag">&gt;</span>
        <em class="lineannotation"><span class="lineannotation">&lt;!-- configuration elided for brevity --&gt;</span></em>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p>If you are extending from a Spring-provided test base class
          that happens to use <code class="interfacename">@Autowired</code> on one
          of its setter methods, you might have multiple beans of the affected
          type defined in your application context: for example, multiple
          <code class="interfacename">DataSource</code> beans. In such a case, you
          can override the setter method and use the
          <code class="interfacename">@Qualifier</code> annotation to indicate a
          specific target bean as follows, but make sure to delegate to the
          overridden method in the superclass as well.</p>

          <pre class="programlisting"><em class="lineannotation"><span class="lineannotation">// ...</span></em>

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <i><span class="hl-annotation" style="color: gray">@Override</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(<span class="bold"><strong>@Qualifier("myDataSource")</strong></span> DataSource dataSource) {
        <span class="bold"><strong>super</strong></span>.setDataSource(dataSource);
    }

<em class="lineannotation"><span class="lineannotation">// ...</span></em></pre>

          <p>The specified qualifier value indicates the specific
          <code class="interfacename">DataSource</code> bean to inject, narrowing
          the set of type matches to a specific bean. Its value is matched
          against <code class="literal">&lt;qualifier&gt;</code> declarations within the
          corresponding <code class="literal">&lt;bean&gt;</code> definitions. The bean
          name is used as a fallback qualifier value, so you may effectively
          also point to a specific bean by name there (as shown above,
          assuming that "myDataSource" is the bean id).</p>
        </td></tr></table></div>
      </div>

      <div class="section" title="Testing request and session scoped beans"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-web-scoped-beans"></a>Testing request and session scoped beans</h4></div></div></div>
        

        <p><a class="link" href="beans.html#beans-factory-scopes-other" title="5.5.4&nbsp;Request, session, and global session scopes">Request and session
        scoped beans</a> have been supported by Spring for several years
        now, but it's always been a bit non-trivial to test them. As of Spring
        3.2 it's now a breeze to test your request-scoped and session-scoped
        beans by following these steps.</p>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p>Ensure that a
            <code class="interfacename">WebApplicationContext</code> is loaded for
            your test by annotating your test class with
            <code class="interfacename">@WebAppConfiguration</code>.</p>
          </li><li class="listitem">
            <p>Inject the mock request or session into your test instance
            and prepare your test fixture as appropriate.</p>
          </li><li class="listitem">
            <p>Invoke your web component that you retrieved from the
            configured <code class="interfacename">WebApplicationContext</code>
            (i.e., via dependency injection).</p>
          </li><li class="listitem">
            <p>Perform assertions against the mocks.</p>
          </li></ul></div>

        <p>The following code snippet displays the XML configuration for a
        login use case. Note that the <code class="literal">userService</code> bean has
        a dependency on a request-scoped <code class="literal">loginAction</code> bean.
        Also, the <code class="classname">LoginAction</code> is instantiated using
        <a class="link" href="expressions.html" title="8.&nbsp;Spring Expression Language (SpEL)">SpEL expressions</a> that retrieve the
        username and password from the current HTTP request. In our test, we
        will want to configure these request parameters via the mock managed
        by the TestContext framework.</p>

        <div class="example"><a name="d4e9283"></a><p class="title"><b>Example&nbsp;11.5.&nbsp;Request-scoped bean configuration</b></p><div class="example-contents">
          

          <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"userService"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"com.example.SimpleUserService"</span>
      <span class="hl-attribute">c:loginAction-ref</span>=<span class="hl-value">"loginAction"</span><span class="hl-tag"> /&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"loginAction"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.example.LoginAction"</span>
      <span class="hl-attribute">c:username</span>=<span class="hl-value">"#{request.getParameter('user')}"</span>
      <span class="hl-attribute">c:password</span>=<span class="hl-value">"#{request.getParameter('pswd')}"</span>
      <span class="hl-attribute">scope</span>=<span class="hl-value">"request"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;aop:scoped-proxy /&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
        </div></div><br class="example-break">

        <p>In <code class="classname">RequestScopedBeanTests</code> we inject both
        the <code class="classname">UserService</code> (i.e., the subject under test)
        and the <code class="classname">MockHttpServletRequest</code> into our test
        instance. Within our <code class="function">requestScope()</code> test method
        we set up our test fixture by setting request parameters in the
        provided <code class="classname">MockHttpServletRequest</code>. When the
        <code class="function">loginUser()</code> method is invoked on our
        <code class="literal">userService</code> we are assured that the user service
        has access to the request-scoped <code class="literal">loginAction</code> for
        the current <code class="classname">MockHttpServletRequest</code> (i.e., the
        one we just set parameters in). We can then perform assertions against
        the results based on the known inputs for the username and
        password.</p>

        <div class="example"><a name="d4e9296"></a><p class="title"><b>Example&nbsp;11.6.&nbsp;Request-scoped bean test</b></p><div class="example-contents">
          

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<i><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RequestScopedBeanTests {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> UserService userService;
    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> MockHttpServletRequest request;

    <i><span class="hl-annotation" style="color: gray">@Test</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> requestScope() {

        request.setParameter(<span class="hl-string">"user"</span>, <span class="hl-string">"enigma"</span>);
        request.setParameter(<span class="hl-string">"pswd"</span>, <span class="hl-string">"$pr!ng"</span>);

        LoginResults results = userService.loginUser();

        <span class="hl-comment">// assert results</span>
    }
}</pre>
        </div></div><br class="example-break">

        <p>The following code snippet is similar to the one we saw above
        for a request-scoped bean; however, this time the
        <code class="literal">userService</code> bean has a dependency on a
        session-scoped <code class="literal">userPreferences</code> bean. Note that the
        <code class="classname">UserPreferences</code> bean is instantiated using a
        SpEL expression that retrieves the <span class="emphasis"><em>theme</em></span> from the
        current HTTP session. In our test, we will need to configure a theme
        in the mock session managed by the TestContext framework.</p>

        <div class="example"><a name="d4e9304"></a><p class="title"><b>Example&nbsp;11.7.&nbsp;Session-scoped bean configuration</b></p><div class="example-contents">
          

          <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"userService"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"com.example.SimpleUserService"</span>
      <span class="hl-attribute">c:userPreferences-ref</span>=<span class="hl-value">"userPreferences"</span><span class="hl-tag"> /&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"userPreferences"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"com.example.UserPreferences"</span>
      <span class="hl-attribute">c:theme</span>=<span class="hl-value">"#{session.getAttribute('theme')}"</span>
      <span class="hl-attribute">scope</span>=<span class="hl-value">"session"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;aop:scoped-proxy /&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
        </div></div><br class="example-break">

        <p>In <code class="classname">SessionScopedBeanTests</code> we inject the
        <code class="classname">UserService</code> and the
        <code class="classname">MockHttpSession</code> into our test instance. Within
        our <code class="function">sessionScope()</code> test method we set up our test
        fixture by setting the expected "theme" attribute in the provided
        <code class="classname">MockHttpSession</code>. When the
        <code class="function">processUserPreferences()</code> method is invoked on our
        <code class="literal">userService</code> we are assured that the user service
        has access to the session-scoped <code class="literal">userPreferences</code>
        for the current <code class="classname">MockHttpSession</code>, and we can
        perform assertions against the results based on the configured
        theme.</p>

        <div class="example"><a name="d4e9317"></a><p class="title"><b>Example&nbsp;11.8.&nbsp;Session-scoped bean test</b></p><div class="example-contents">
          

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<i><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SessionScopedBeanTests {

  <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> UserService userService;
  <i><span class="hl-annotation" style="color: gray">@Autowired</span></i> MockHttpSession session;

  <i><span class="hl-annotation" style="color: gray">@Test</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> sessionScope() <span class="hl-keyword">throws</span> Exception {

    session.setAttribute(<span class="hl-string">"theme"</span>, <span class="hl-string">"blue"</span>);

    Results results = userService.processUserPreferences();

    <span class="hl-comment">// assert results</span>
  }
}</pre>
        </div></div><br class="example-break">
      </div>

      <div class="section" title="Transaction management"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tx"></a>Transaction management</h4></div></div></div>
        

        <p>In the TestContext framework, transactions are managed by the
        <code class="classname">TransactionalTestExecutionListener</code>. Note that
        <code class="classname">TransactionalTestExecutionListener</code> is
        configured by default, even if you do not explicitly declare
        <code class="interfacename">@TestExecutionListeners</code> on your test
        class. To enable support for transactions, however, you must provide a
        <code class="classname">PlatformTransactionManager</code> bean in the
        application context loaded by
        <code class="interfacename">@ContextConfiguration</code> semantics. In
        addition, you must declare
        <code class="interfacename">@Transactional</code> either at the class or
        method level for your tests.</p>

        <p>For class-level transaction configuration (i.e., setting an
        explicit bean name for the transaction manager and the default
        rollback flag), see the
        <code class="interfacename">@TransactionConfiguration</code> entry in the
        <a class="link" href="testing.html#integration-testing-annotations" title="11.3.4&nbsp;Annotations">annotation
        support</a> section.</p>

        <p>If transactions are not enabled for the entire test class, you
        can annotate methods explicitly with
        <code class="interfacename">@Transactional</code>. To control whether a
        transaction should commit for a particular test method, you can use
        the <code class="interfacename">@Rollback</code> annotation to override
        the class-level default rollback setting.</p>

        <p><span class="emphasis"><em><a class="link" href="testing.html#testcontext-support-classes-junit4" title="JUnit support classes">
        <code class="classname">AbstractTransactionalJUnit4SpringContextTests</code>
        </a> and <a class="link" href="testing.html#testcontext-support-classes-testng" title="TestNG support classes">
        <code class="classname">AbstractTransactionalTestNGSpringContextTests</code>
        </a> are preconfigured for transactional support at the class
        level.</em></span></p>

        <p>Occasionally you need to execute certain code before or after a
        transactional test method but outside the transactional context, for
        example, to verify the initial database state prior to execution of
        your test or to verify expected transactional commit behavior after
        test execution (if the test was configured not to roll back the
        transaction).
        <code class="classname">TransactionalTestExecutionListener</code> supports the
        <code class="interfacename">@BeforeTransaction</code> and
        <code class="interfacename">@AfterTransaction</code> annotations exactly
        for such scenarios. Simply annotate any <code class="literal">public void</code>
        method in your test class with one of these annotations, and the
        <code class="classname">TransactionalTestExecutionListener</code> ensures that
        your <span class="emphasis"><em>before transaction method</em></span> or <span class="emphasis"><em>after
        transaction method</em></span> is executed at the appropriate
        time.</p>

        <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
          <p>Any <span class="emphasis"><em>before methods</em></span> (such as methods
          annotated with JUnit's <code class="interfacename">@Before</code>) and
          any <span class="emphasis"><em>after methods</em></span> (such as methods annotated
          with JUnit's <code class="interfacename">@After</code>) are executed
          <span class="bold"><strong>within</strong></span> a transaction. In addition,
          methods annotated with
          <code class="interfacename">@BeforeTransaction</code> or
          <code class="interfacename">@AfterTransaction</code> are naturally not
          executed for tests annotated with
          <code class="interfacename">@NotTransactional</code>. However,
          <code class="interfacename">@NotTransactional</code> is deprecated as of
          Spring 3.0.</p>
        </td></tr></table></div>

        <p>The following JUnit-based example displays a fictitious
        integration testing scenario highlighting several transaction-related
        annotations. Consult the <a class="link" href="testing.html#integration-testing-annotations" title="11.3.4&nbsp;Annotations">annotation support</a>
        section for further information and configuration examples.</p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></i>
<span class="bold"><strong>@TransactionConfiguration(transactionManager="txMgr", defaultRollback=false)</strong></span>
<span class="bold"><strong>@Transactional</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FictitiousTransactionalTest {

    <span class="bold"><strong>@BeforeTransaction</strong></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> verifyInitialDatabaseState() {
        <em class="lineannotation"><span class="lineannotation">// logic to verify the initial state before a transaction is started</span></em>
    }

    <i><span class="hl-annotation" style="color: gray">@Before</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setUpTestDataWithinTransaction() {
        <em class="lineannotation"><span class="lineannotation">// set up test data within the transaction</span></em>
    }

    <i><span class="hl-annotation" style="color: gray">@Test</span></i>
    <em class="lineannotation"><span class="lineannotation">// overrides the class-level defaultRollback setting</span></em>
    <span class="bold"><strong>@Rollback(true)</strong></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> modifyDatabaseWithinTransaction() {
        <em class="lineannotation"><span class="lineannotation">// logic which uses the test data and modifies database state</span></em>
    }

    <i><span class="hl-annotation" style="color: gray">@After</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> tearDownWithinTransaction() {
        <em class="lineannotation"><span class="lineannotation">// execute "tear down" logic within the transaction</span></em>
    }

    <span class="bold"><strong>@AfterTransaction</strong></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> verifyFinalDatabaseState() {
        <em class="lineannotation"><span class="lineannotation">// logic to verify the final state after transaction has rolled back</span></em>
    }

}</pre>

        <a name="testcontext-tx-false-positives"></a>

        <div class="note" title="Avoid false positives when testing ORM code" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Avoid false positives when testing ORM code"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Avoid false positives when testing ORM code</th></tr><tr><td align="left" valign="top">
          

          <p>When you test application code that manipulates the state of
          the Hibernate session, make sure to <span class="emphasis"><em>flush</em></span> the
          underlying session within test methods that execute that code.
          Failing to flush the underlying session can produce <span class="emphasis"><em>false
          positives</em></span>: your test may pass, but the same code throws
          an exception in a live, production environment. In the following
          Hibernate-based example test case, one method demonstrates a false
          positive, and the other method correctly exposes the results of
          flushing the session. Note that this applies to JPA and any other
          ORM frameworks that maintain an in-memory <span class="emphasis"><em>unit of
          work</em></span>.</p>

          <pre class="programlisting"><em class="lineannotation"><span class="lineannotation">// ...</span></em>

<i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
<span class="hl-keyword">private</span> SessionFactory sessionFactory;

<i><span class="hl-annotation" style="color: gray">@Test</span></i> <span class="hl-comment">// no expected exception!</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> falsePositive() {
    updateEntityInHibernateSession();
    <span class="hl-comment">// False positive: an exception will be thrown once the session is</span>
    <span class="hl-comment">// finally flushed (i.e., in production code)</span>
}

<i><span class="hl-annotation" style="color: gray">@Test(expected = GenericJDBCException.class)</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateWithSessionFlush() {
    updateEntityInHibernateSession();
    <span class="hl-comment">// Manual flush is required to avoid false positive in test</span>
    sessionFactory.getCurrentSession().flush();
}

<em class="lineannotation"><span class="lineannotation">// ...</span></em></pre>
        </td></tr></table></div>
      </div>

      <div class="section" title="TestContext Framework support classes"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-support-classes"></a>TestContext Framework support classes</h4></div></div></div>
        

        <div class="section" title="JUnit support classes"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-support-classes-junit4"></a>JUnit support classes</h5></div></div></div>
          

          <p>The <code class="literal">org.springframework.test.context.junit4</code>
          package provides support classes for JUnit 4.5+ based test
          cases.</p>

          <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <p><code class="classname">AbstractJUnit4SpringContextTests</code>:
              Abstract base test class that integrates the <span class="emphasis"><em>Spring
              TestContext Framework</em></span> with explicit
              <code class="classname">ApplicationContext</code> testing support in a
              JUnit 4.5+ environment.</p>

              <p>When you extend
              <code class="classname">AbstractJUnit4SpringContextTests</code>, you can
              access the following <code class="literal">protected</code> instance
              variable:</p>

              <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                  <p><code class="literal">applicationContext</code>: Use this
                  variable to perform explicit bean lookups or to test the
                  state of the context as a whole.</p>
                </li></ul></div>
            </li><li class="listitem">
              <p><code class="classname">AbstractTransactionalJUnit4SpringContextTests</code>:
              Abstract <span class="emphasis"><em>transactional</em></span> extension of
              <code class="classname">AbstractJUnit4SpringContextTests</code> that
              also adds some convenience functionality for JDBC access.
              Expects a <code class="classname">javax.sql.DataSource</code> bean and a
              <code class="interfacename">PlatformTransactionManager</code> bean
              to be defined in the <code class="classname">ApplicationContext</code>.
              When you extend
              <code class="classname">AbstractTransactionalJUnit4SpringContextTests</code>
              you can access the following <code class="literal">protected</code>
              instance variables:</p>

              <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                  <p><code class="literal">applicationContext</code>: Inherited from
                  the <code class="classname">AbstractJUnit4SpringContextTests</code>
                  superclass. Use this variable to perform explicit bean
                  lookups or to test the state of the context as a
                  whole.</p>
                </li><li class="listitem">
                  <p><code class="literal">jdbcTemplate</code>: Use this variable to
                  execute SQL statements to query the database. Such queries
                  can be used to confirm database state both <span class="emphasis"><em>prior
                  to</em></span> and <span class="emphasis"><em>after</em></span> execution of
                  database-related application code, and Spring ensures that
                  such queries run in the scope of the same transaction as the
                  application code. When used in conjunction with an ORM tool,
                  be sure to avoid <a class="link" href="testing.html#testcontext-tx-false-positives">false
                  positives</a>.</p>
                </li></ul></div>
            </li></ul></div>

          <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
            <p>These classes are a convenience for extension. If you do not
            want your test classes to be tied to a Spring-specific class
            hierarchy &#8212; for example, if you want to directly extend the class
            you are testing &#8212; you can configure your own custom test classes
            by using
            <code class="interfacename">@RunWith(SpringJUnit4ClassRunner.class)</code>,
            <code class="interfacename">@ContextConfiguration</code>,
            <code class="interfacename">@TestExecutionListeners</code>, and so
            on.</p>
          </td></tr></table></div>
        </div>

        <div class="section" title="Spring JUnit Runner"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-junit4-runner"></a>Spring JUnit Runner</h5></div></div></div>
          

          <p>The <span class="emphasis"><em>Spring TestContext Framework</em></span> offers
          full integration with JUnit 4.5+ through a custom runner (tested on
          JUnit 4.5 &#8211; 4.10). By annotating test classes with
          <code class="literal">@RunWith(SpringJUnit4ClassRunner.class)</code>,
          developers can implement standard JUnit-based unit and integration
          tests and simultaneously reap the benefits of the TestContext
          framework such as support for loading application contexts,
          dependency injection of test instances, transactional test method
          execution, and so on. The following code listing displays the
          minimal requirements for configuring a test class to run with the
          custom Spring Runner.
          <code class="interfacename">@TestExecutionListeners</code> is configured
          with an empty list in order to disable the default listeners, which
          otherwise would require an ApplicationContext to be configured
          through <code class="interfacename">@ContextConfiguration</code>.</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<i><span class="hl-annotation" style="color: gray">@TestExecutionListeners({})</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimpleTest {

    <i><span class="hl-annotation" style="color: gray">@Test</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testMethod() {
        <em class="lineannotation"><span class="lineannotation">// execute test logic...</span></em>
    }
}</pre>
        </div>

        <div class="section" title="TestNG support classes"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-support-classes-testng"></a>TestNG support classes</h5></div></div></div>
          

          <p>The <code class="literal">org.springframework.test.context.testng</code>
          package provides support classes for TestNG based test cases.</p>

          <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <p><code class="classname">AbstractTestNGSpringContextTests</code>:
              Abstract base test class that integrates the <span class="emphasis"><em>Spring
              TestContext Framework</em></span> with explicit
              <code class="classname">ApplicationContext</code> testing support in a
              TestNG environment.</p>

              <p>When you extend
              <code class="classname">AbstractTestNGSpringContextTests</code>, you can
              access the following <code class="literal">protected</code> instance
              variable:</p>

              <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                  <p><code class="literal">applicationContext</code>: Use this
                  variable to perform explicit bean lookups or to test the
                  state of the context as a whole.</p>
                </li></ul></div>
            </li><li class="listitem">
              <p><code class="classname">AbstractTransactionalTestNGSpringContextTests</code>:
              Abstract <span class="emphasis"><em>transactional</em></span> extension of
              <code class="classname">AbstractTestNGSpringContextTests</code> that
              adds some convenience functionality for JDBC access. Expects a
              <code class="classname">javax.sql.DataSource</code> bean and a
              <code class="interfacename">PlatformTransactionManager</code> bean
              to be defined in the <code class="classname">ApplicationContext</code>.
              When you extend
              <code class="classname">AbstractTransactionalTestNGSpringContextTests</code>,
              you can access the following <code class="literal">protected</code>
              instance variables:</p>

              <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                  <p><code class="literal">applicationContext</code>: Inherited from
                  the <code class="classname">AbstractTestNGSpringContextTests</code>
                  superclass. Use this variable to perform explicit bean
                  lookups or to test the state of the context as a
                  whole.</p>
                </li><li class="listitem">
                  <p><code class="literal">jdbcTemplate</code>: Use this variable to
                  execute SQL statements to query the database. Such queries
                  can be used to confirm database state both <span class="emphasis"><em>prior
                  to</em></span> and <span class="emphasis"><em>after</em></span> execution of
                  database-related application code, and Spring ensures that
                  such queries run in the scope of the same transaction as the
                  application code. When used in conjunction with an ORM tool,
                  be sure to avoid <a class="link" href="testing.html#testcontext-tx-false-positives">false
                  positives</a>.</p>
                </li></ul></div>
            </li></ul></div>

          <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
            <p>These classes are a convenience for extension. If you do not
            want your test classes to be tied to a Spring-specific class
            hierarchy &#8212; for example, if you want to directly extend the class
            you are testing &#8212; you can configure your own custom test classes
            by using <code class="interfacename">@ContextConfiguration</code>,
            <code class="interfacename">@TestExecutionListeners</code>, and so on,
            and by manually instrumenting your test class with a
            <code class="classname">TestContextManager</code>. See the source code of
            <code class="classname">AbstractTestNGSpringContextTests</code> for an
            example of how to instrument your test class.</p>
          </td></tr></table></div>
        </div>
      </div>
    </div>

    <div class="section" title="11.3.6&nbsp;Spring MVC Test Framework"><div class="titlepage"><div><div><h3 class="title"><a name="spring-mvc-test-framework"></a>11.3.6&nbsp;Spring MVC Test Framework</h3></div></div></div>
      

      <div class="sidebar" title="Standalone project"><a name="spring-mvc-test-origins"></a><p class="title"><b>Standalone project</b></p>
        

        <p>Before inclusion in Spring Framework 3.2, the Spring MVC Test
        framework had already existed as a separate project on GitHub where it
        grew and evolved through actual use, feedback, and the contribution of
        many.</p>

        <p>The standalone <a class="ulink" href="https://github.com/SpringSource/spring-test-mvc" target="_top">spring-test-mvc
        project</a> is still available on GitHub and can be used in
        conjunction with Spring Framework 3.1.x. Applications upgrading to 3.2
        should replace the <code class="filename">spring-test-mvc</code> dependency
        with a dependency on <code class="filename">spring-test</code>.</p>

        <p>The <code class="filename">spring-test</code> module uses a different
        package <code class="classname">org.springframework.test.web</code> but
        otherwise is nearly identical with two exceptions. One is support for
        features new in 3.2 (e.g. asynchronous web requests). The other
        relates to the options for creating a <code class="classname">MockMvc</code>
        instance. In Spring Framework 3.2, this can only be done through the
        TestContext framework, which provides caching benefits for the loaded
        configuration.</p>
      </div>

      <p>The <span class="emphasis"><em>Spring MVC Test framework</em></span> provides first
      class JUnit support for testing client and server-side Spring MVC code
      through a fluent API. Typically it loads the actual Spring configuration
      through the <span class="emphasis"><em>TestContext framework</em></span> and always uses
      the <code class="classname">DispatcherServlet</code> to process requests thus
      approximating full integration tests without requiring a running Servlet
      container.</p>

      <p>Client-side tests are <code class="classname">RestTemplate</code>-based
      and allow tests for code that relies on the
      <code class="classname">RestTemplate</code> without requiring a running server
      to respond to the requests.</p>

      <div class="section" title="Server-Side Tests"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server"></a>Server-Side Tests</h4></div></div></div>
        

        <p>Before Spring Framework 3.2, the most likely way to test a
        Spring MVC controller was to write a unit test that instantiates the
        controller, injects it with mock or stub dependencies, and then calls
        its methods directly, using a
        <code class="classname">MockHttpServletRequest</code> and
        <code class="classname">MockHttpServletResponse</code> where necessary.</p>

        <p>Although this is pretty easy to do, controllers have many
        annotations, and much remains untested. Request mappings, data
        binding, type conversion, and validation are just a few examples of
        what isn't tested. Furthermore, there are other types of annotated
        methods such as <code class="interfacename">@InitBinder</code>,
        <code class="interfacename">@ModelAttribute</code>, and
        <code class="interfacename">@ExceptionHandler</code> that get invoked as
        part of request processing.</p>

        <p>The idea behind Spring MVC Test is to be able to re-write those
        controller tests by performing actual requests and generating
        responses, as they would be at runtime, along the way invoking
        controllers through the Spring MVC
        <code class="classname">DispatcherServlet</code>. Controllers can still be
        injected with mock dependencies, so tests can remain focused on the
        web layer.</p>

        <p>Spring MVC Test builds on the familiar "mock" implementations of
        the Servlet API available in the <code class="filename">spring-test</code>
        module. This allows performing requests and generating responses
        without the need for running in a Servlet container. For the most part
        everything should work as it does at runtime with the exception of JSP
        rendering, which is not available outside a Servlet container.
        Furthermore, if you are familiar with how the
        <code class="classname">MockHttpServletResponse</code> works, you'll know that
        forwards and redirects are not actually executed. Instead "forwarded"
        and "redirected" URLs are saved and can be asserted in tests. This
        means if you are using JSPs, you can verify the JSP page to which the
        request was forwarded.</p>

        <p>All other means of rendering including
        <code class="interfacename">@ResponseBody</code> methods and
        <code class="interfacename">View</code> types (besides JSPs) such as
        Freemarker, Velocity, Thymeleaf, and others for rendering HTML, JSON,
        XML, and so on should work as expected, and the response will contain
        the generated content.</p>

        <p>Below is an example of a test requesting account information in
        JSON format:</p>

        <pre class="programlisting"><span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

<i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<i><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></i>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration("test-servlet-context.xml")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExampleTests {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">private</span> WebApplicationContext wac;

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <i><span class="hl-annotation" style="color: gray">@Before</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
        <span class="hl-keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(<span class="hl-keyword">this</span>.wac).build();
    }

    <i><span class="hl-annotation" style="color: gray">@Test</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getAccount() <span class="hl-keyword">throws</span> Exception {
        <span class="hl-keyword">this</span>.mockMvc.perform(get(<span class="hl-string">"/accounts/1"</span>).accept(<span class="hl-string">"application/json;charset=UTF-8"</span>))
          .andExpect(status().isOk())
          .andExpect(content().contentType(<span class="hl-string">"application/json"</span>))
          .andExpect(jsonPath(<span class="hl-string">"$.name"</span>).value(<span class="hl-string">"Lee"</span>);
    }

}</pre>

        <p>The test relies on the
        <code class="interfacename">WebApplicationContext</code> support of the
        <span class="emphasis"><em>TestContext framework</em></span>. It loads Spring
        configuration from an XML configuration file located in the same
        package as the test class (also supports JavaConfig) and injects the
        created <code class="interfacename">WebApplicationContext</code> into the
        test so a <code class="classname">MockMvc</code> instance can be created with
        it.</p>

        <p>The <code class="classname">MockMvc</code> is then used to perform a
        request to <code class="filename">"/accounts/1"</code> and verify the resulting
        response status is 200, the response content type is
        <code class="filename">"application/json"</code>, and response content has a
        JSON property called "name" with the value "Lee". JSON content is
        inspected with the help of Jayway's <a class="ulink" href="https://github.com/jayway/JsonPath" target="_top">JsonPath project</a>.
        There are lots of other options for verifying the result of the
        performed request and those will be discussed later.</p>

        <div class="section" title="Static Imports"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-static-imports"></a>Static Imports</h5></div></div></div>
          

          <p>The fluent API in the example above requires a few static
          imports such as <code class="classname">MockMvcRequestBuilders.*</code>,
          <code class="classname">MockMvcResultMatchers.*</code>, and
          <code class="classname">MockMvcBuilders.*</code>. An easy way to find these
          classes is to search for types matching
          <span class="emphasis"><em>"MockMvc*"</em></span>. If using Eclipse, be sure to add
          them as "favorite static members" in the Eclipse preferences under
          <span class="emphasis"><em>Java -&gt; Editor -&gt; Content Assist -&gt;
          Favorites</em></span>. That will allow use of content assist after
          typing the first character of the static method name. Other IDEs
          (e.g. IntelliJ) may not require any additional configuration. Just
          check the support for code completion on static members.</p>
        </div>

        <div class="section" title="Setup Options"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-setup-options"></a>Setup Options</h5></div></div></div>
          

          <p>The goal of server-side test setup is to create an instance of
          <code class="classname">MockMvc</code> that can be used to perform requests.
          There are two main options.</p>

          <p>The first option is to point to Spring MVC configuration
          through the <span class="emphasis"><em>TestContext framework</em></span>, which loads
          the Spring configuration and injects a
          <code class="interfacename">WebApplicationContext</code> into the test
          to use to create a <code class="classname">MockMvc</code>:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<i><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></i>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration("my-servlet-context.xml")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyWebTests {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">private</span> WebApplicationContext wac;

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <i><span class="hl-annotation" style="color: gray">@Before</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
        <span class="hl-keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(<span class="hl-keyword">this</span>.wac).build();
    }

    <span class="hl-comment">// ...</span>

}</pre>

          <p>The second option is to simply register a controller instance
          without loading any Spring configuration. Instead basic Spring MVC
          configuration suitable for testing annotated controllers is
          automatically created. The created configuration is comparable to
          that of the MVC JavaConfig (and the MVC namespace) and can be
          customized to a degree through builder-style methods:</p>

          <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyWebTests {

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <i><span class="hl-annotation" style="color: gray">@Before</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
        <span class="hl-keyword">this</span>.mockMvc = MockMvcBuilders.standaloneSetup(<span class="hl-keyword">new</span> AccountController()).build();
    }

    <span class="hl-comment">// ...</span>

}</pre>

          <p>Which option should you use?</p>

          <p>The <span class="emphasis"><em>"webAppContextSetup"</em></span> loads the actual
          Spring MVC configuration resulting in a more complete integration
          test. Since the <span class="emphasis"><em>TestContext framework</em></span> caches
          the loaded Spring configuration, it helps to keep tests running fast
          even as more tests get added. Furthermore, you can inject mock
          services into controllers through Spring configuration, in order to
          remain focused on testing the web layer. Here is an example of
          declaring a mock service with Mockito:</p>

          <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"accountService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.mockito.Mockito"</span> <span class="hl-attribute">factory-method</span>=<span class="hl-value">"mock"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.example.AccountService"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre>

          <p>Then you can inject the mock service into the test in order
          set up and verify expectations:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></i>
<i><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></i>
<i><span class="hl-annotation" style="color: gray">@ContextConfiguration("test-servlet-context.xml")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AccountTests {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">private</span> WebApplicationContext wac;

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">private</span> AccountService accountService;

    <span class="hl-comment">// ...</span>

}</pre>

          <p>The <span class="emphasis"><em>"standaloneSetup"</em></span> on the other hand
          is a little closer to a unit test. It tests one controller at a
          time, the controller can be injected with mock dependencies
          manually, and it doesn't involve loading Spring configuration. Such
          tests are more focused in style and make it easier to see which
          controller is being tested, whether any specific Spring MVC
          configuration is required to work, and so on. The "standaloneSetup"
          is also a very convenient way to write ad-hoc tests to verify some
          behavior or to debug an issue.</p>

          <p>Just like with integration vs unit testing, there is no right
          or wrong answer. Using the "standaloneSetup" does imply the need for
          some additional "webAppContextSetup" tests to verify the Spring MVC
          configuration. Alternatively, you can decide write all tests with
          "webAppContextSetup" and always test against actual Spring MVC
          configuration.</p>
        </div>

        <div class="section" title="Performing Requests"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-performing-requests"></a>Performing Requests</h5></div></div></div>
          

          <p>To perform requests, use the appropriate HTTP method and
          additional builder-style methods corresponding to properties of
          <code class="classname">MockHttpServletRequest</code>. For example:</p>

          <pre class="programlisting">mockMvc.perform(post(<span class="hl-string">"/hotels/{id}"</span>, <span class="hl-number">42</span>).accept(MediaType.APPLICATION_JSON));
</pre>

          <p>In addition to all the HTTP methods, you can also perform file
          upload requests, which internally creates an instance of
          <code class="classname">MockMultipartHttpServletRequest</code>:</p>

          <pre class="programlisting">mockMvc.perform(fileUpload(<span class="hl-string">"/doc"</span>).file(<span class="hl-string">"a1"</span>, <span class="hl-string">"ABC"</span>.getBytes(<span class="hl-string">"UTF-8"</span>)));
</pre>

          <p>Query string parameters can be specified in the URI
          template:</p>

          <pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/hotels?foo={foo}"</span>, <span class="hl-string">"bar"</span>));
</pre>

          <p>Or by adding Servlet request parameters:</p>

          <pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/hotels"</span>).param(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>));
</pre>

          <p>If application code relies on Servlet request parameters, and
          doesn't check the query string, as is most often the case, then it
          doesn't matter how parameters are added. Keep in mind though that
          parameters provided in the URI template will be decoded while
          parameters provided through the <code class="function">param(...)</code>
          method are expected to be decoded.</p>

          <p>In most cases it's preferable to leave out the context path
          and the Servlet path from the request URI. If you must test with the
          full request URI, be sure to set the
          <code class="function">contextPath</code> and
          <code class="function">servletPath</code> accordingly so that request
          mappings will work:</p>

          <pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/app/main/hotels/{id}"</span>).contextPath(<span class="hl-string">"/app"</span>).servletPath(<span class="hl-string">"/main"</span>))
</pre>

          <p>Looking at the above example, it would be cumbersome to set
          the contextPath and servletPath with every performed request. That's
          why you can define default request properties when building the
          <code class="classname">MockMvc</code>:</p>

          <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyWebTests {

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <i><span class="hl-annotation" style="color: gray">@Before</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
        mockMvc = standaloneSetup(<span class="hl-keyword">new</span> AccountController())
            .defaultRequest(get(<span class="hl-string">"/"</span>)
                .contextPath(<span class="hl-string">"/app"</span>).servletPath(<span class="hl-string">"/main"</span>)
                .accept(MediaType.APPLICATION_JSON).build();
    }

}</pre>

          <p>The above properties will apply to every request performed
          through the <code class="classname">MockMvc</code>. If the same property is
          also specified on a given request, it will override the default
          value. That is why, the HTTP method and URI don't matter, when
          setting default request properties, since they must be specified on
          every request.</p>
        </div>

        <div class="section" title="Defining Expectations"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-defining-expectations"></a>Defining Expectations</h5></div></div></div>
          

          <p>Expectations can be defined by appending one or more
          <code class="function">.andExpect(..)</code> after call to perform the
          request:</p>

          <pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/accounts/1"</span>)).andExpect(status().isOk());
</pre>

          <p><code class="literal">MockMvcResultMatchers.*</code> defines a number of
          static members, some of which return types with additional methods,
          for asserting the result of the performed request. The assertions
          fall in two general categories.</p>

          <p>The first category of assertions verify properties of the
          response, i.e the response status, headers, and content. Those are
          the most important things to test for.</p>

          <p>The second category of assertions go beyond the response, and
          allow inspecting Spring MVC specific constructs such as which
          controller method processed the request, whether an exception was
          raised and handled, what the content of the model is, what view was
          selected, what flash attributes were added, and so on. It is also
          possible to verify Servlet specific constructs such as request and
          session attributes. The following test asserts that
          binding/validation failed:</p>

          <pre class="programlisting">
mockMvc.perform(post(<span class="hl-string">"/persons"</span>))
  .andExpect(status().isOk())
  .andExpect(model().attributeHasErrors(<span class="hl-string">"person"</span>));
</pre>

          <p>Many times when writing tests, it's useful to dump the result
          of the performed request. This can be done as follows, where
          <code class="function">print()</code> is a static import from
          <code class="classname">MockMvcResultHandlers</code>:</p>

          <pre class="programlisting">mockMvc.perform(post(<span class="hl-string">"/persons"</span>))
  .andDo(print())
  .andExpect(status().isOk())
  .andExpect(model().attributeHasErrors(<span class="hl-string">"person"</span>));</pre>

          <p>As long as request processing causes an unhandled exception,
          the <code class="function">print()</code> method will print all the available
          result data to <code class="literal">System.out</code>.</p>

          <p>In some cases, you may want to get direct access to the result
          and verify something that cannot be verified otherwise. This can be
          done by appending <code class="function">.andReturn()</code> at the end after
          all expectations:</p>

          <pre class="programlisting">MvcResult mvcResult = mockMvc.perform(post(<span class="hl-string">"/persons"</span>)).andExpect(status().isOk()).andReturn();
<span class="hl-comment">// ...</span></pre>

          <p>When all tests repeat the same expectations, you can define
          the common expectations once when building the
          <code class="classname">MockMvc</code>:</p>

          <pre class="programlisting">standaloneSetup(<span class="hl-keyword">new</span> SimpleController())
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType(<span class="hl-string">"application/json;charset=UTF-8"</span>))
    .build()</pre>

          <p>Note that the expectation is <span class="emphasis"><em>always</em></span>
          applied and cannot be overridden without creating a separate
          <code class="classname">MockMvc</code> instance.</p>

          <p>When JSON response content contains hypermedia links created
          with <a class="ulink" href="https://github.com/SpringSource/spring-hateoas" target="_top">Spring
          HATEOAS</a>, the resulting links can be verified:</p>

          <pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/people"</span>).accept(MediaType.APPLICATION_JSON))
  .andExpect(jsonPath(<span class="hl-string">"$.links[?(@.rel == 'self')].href"</span>).value(<span class="hl-string">"http://localhost:8080/people"</span>));</pre>

          <p>When XML response content contains hypermedia links created
          with <a class="ulink" href="https://github.com/SpringSource/spring-hateoas" target="_top">Spring
          HATEOAS</a>, the resulting links can be verified:</p>

          <pre class="programlisting">Map&lt;String, String&gt; ns = Collections.singletonMap(<span class="hl-string">"ns"</span>, <span class="hl-string">"http://www.w3.org/2005/Atom"</span>);
mockMvc.perform(get(<span class="hl-string">"/handle"</span>).accept(MediaType.APPLICATION_XML))
  .andExpect(xpath(<span class="hl-string">"/person/ns:link[@rel='self']/@href"</span>, ns).string(<span class="hl-string">"http://localhost:8080/people"</span>));</pre>
        </div>

        <div class="section" title="Filter Registrations"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-filters"></a>Filter Registrations</h5></div></div></div>
          

          <p>When setting up a <code class="classname">MockMvc</code>, you can
          register one or more <code class="interfacename">Filter</code>
          instances:</p>

          <pre class="programlisting">mockMvc = standaloneSetup(<span class="hl-keyword">new</span> PersonController()).addFilters(<span class="hl-keyword">new</span> CharacterEncodingFilter()).build();</pre>

          <p>Registered filters will be invoked through
          <code class="classname">MockFilterChain</code> from
          <code class="filename">spring-test</code> and the last filter will delegates
          to the <code class="classname">DispatcherServlet</code>.</p>
        </div>

        <div class="section" title="Further Server-Side Test Examples"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-resources"></a>Further Server-Side Test Examples</h5></div></div></div>
          

          <p>The framework's own tests include <a class="ulink" href="https://github.com/SpringSource/spring-framework/tree/master/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples" target="_top">many
          sample tests</a> intended to demonstrate how to use Spring MVC
          Test. Browse these examples for further ideas. Also the <a class="ulink" href="https://github.com/SpringSource/spring-mvc-showcase" target="_top">spring-mvc-showcase</a>
          has full test coverage based on Spring MVC Test.</p>
        </div>
      </div>

      <div class="section" title="Client-Side REST Tests"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-client"></a>Client-Side REST Tests</h4></div></div></div>
        

        <p>Client-side tests are for code using the
        <code class="classname">RestTemplate</code>. The goal is to define expected
        requests and provide "stub" responses:</p>

        <pre class="programlisting">RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

MockRestServiceServer mockServer =  MockRestServiceServer.createServer(restTemplate);
mockServer.expect(requestTo(<span class="hl-string">"/greeting"</span>)).andRespond(withSuccess(<span class="hl-string">"Hello world"</span>, <span class="hl-string">"text/plain"</span>));

<span class="hl-comment">// use RestTemplate ...</span>

mockServer.verify();</pre>

        <p>In the above example,
        <code class="classname">MockRestServiceServer</code> -- the central class for
        client-side REST tests -- configures the
        <code class="classname">RestTemplate</code> with a custom
        <code class="interfacename">ClientHttpRequestFactory</code> that asserts
        actual requests against expectations and returns "stub" responses. In
        this case we expect a single request to "/greeting" and want to return
        a 200 response with "text/plain" content. We could define as many
        additional requests and stub responses as necessary.</p>

        <p>Once expected requests and stub responses have been defined, the
        <code class="classname">RestTemplate</code> can be used in client-side code as
        usual. At the end of the tests <code class="literal">mockServer.verify()</code>
        can be used to verify that all expected requests were
        performed.</p>

        <div class="section" title="Static Imports"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-client-static-imports"></a>Static Imports</h5></div></div></div>
          

          <p>Just like with server-side tests, the fluent API for
          client-side tests requires a few static imports. Those are easy to
          find by searching <span class="emphasis"><em>"MockRest*"</em></span>. Eclipse users
          should add <code class="classname">"MockRestRequestMatchers.*"</code> and
          <code class="classname">"MockRestResponseCreators.*"</code> as "favorite
          static members" in the Eclipse preferences under <span class="emphasis"><em>Java
          -&gt; Editor -&gt; Content Assist -&gt; Favorites</em></span>. That
          allows using content assist after typing the first character of the
          static method name. Other IDEs (e.g. IntelliJ) may not require any
          additional configuration. Just check the support for code completion
          on static members.</p>
        </div>

        <div class="section" title="Further Examples of Client-side REST Tests"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-client-resources"></a>Further Examples of Client-side REST Tests</h5></div></div></div>
          

          <p>Spring MVC Test's own tests include <a class="ulink" href="https://github.com/SpringSource/spring-framework/tree/master/spring-test-mvc/src/test/java/org/springframework/test/web/client/samples" target="_top">example
          tests</a> of client-side REST tests.</p>
        </div>
      </div>
    </div>

    <div class="section" title="11.3.7&nbsp;PetClinic Example"><div class="titlepage"><div><div><h3 class="title"><a name="testing-examples-petclinic"></a>11.3.7&nbsp;PetClinic Example</h3></div></div></div>
      

      <p>The PetClinic application, available from the <a class="link" href="new-in-3.0.html#new-in-3.0-samples">samples repository</a>, illustrates
      several features of the <span class="emphasis"><em>Spring TestContext
      Framework</em></span> in a JUnit 4.5+ environment. Most test
      functionality is included in the
      <code class="classname">AbstractClinicTests</code>, for which a partial listing
      is shown below:</p>

      <pre class="programlisting"><span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.junit.Assert.assertEquals;
<em class="lineannotation"><span class="lineannotation">// import ...</span></em>

<span class="bold"><strong>@ContextConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> AbstractClinicTests <span class="bold"><strong>extends AbstractTransactionalJUnit4SpringContextTests</strong></span> {

    <span class="bold"><strong>@Autowired</strong></span>
    <span class="hl-keyword">protected</span> Clinic clinic;

    <i><span class="hl-annotation" style="color: gray">@Test</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getVets() {
        Collection&lt;Vet&gt; vets = <span class="hl-keyword">this</span>.clinic.getVets();
        assertEquals(<span class="hl-string">"JDBC query must show the same number of vets"</span>,
            <span class="bold"><strong>super.countRowsInTable("VETS")</strong></span>, vets.size());
        Vet v1 = EntityUtils.getById(vets, Vet.<span class="hl-keyword">class</span>, <span class="hl-number">2</span>);
        assertEquals(<span class="hl-string">"Leary"</span>, v1.getLastName());
        assertEquals(<span class="hl-number">1</span>, v1.getNrOfSpecialties());
        assertEquals(<span class="hl-string">"radiology"</span>, (v1.getSpecialties().get(<span class="hl-number">0</span>)).getName());
        <em class="lineannotation"><span class="lineannotation">// ...</span></em>
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>

      <p>Notes:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>This test case extends the
          <code class="classname">AbstractTransactionalJUnit4SpringContextTests</code>
          class, from which it inherits configuration for Dependency Injection
          (through the
          <code class="classname">DependencyInjectionTestExecutionListener</code>) and
          transactional behavior (through the
          <code class="classname">TransactionalTestExecutionListener</code>).</p>
        </li><li class="listitem">
          <p>The <code class="literal">clinic</code> instance variable &#8212; the
          application object being tested &#8212; is set by Dependency Injection
          through <code class="interfacename">@Autowired</code> semantics.</p>
        </li><li class="listitem">
          <p>The <code class="methodname">testGetVets()</code> method illustrates
          how you can use the inherited
          <code class="methodname">countRowsInTable()</code> method to easily verify
          the number of rows in a given table, thus verifying correct behavior
          of the application code being tested. This allows for stronger tests
          and lessens dependency on the exact test data. For example, you can
          add additional rows in the database without breaking tests.</p>
        </li><li class="listitem">
          <p>Like many integration tests that use a database, most of the
          tests in <code class="classname">AbstractClinicTests</code> depend on a
          minimum amount of data already in the database before the test cases
          run. Alternatively, you might choose to populate the database within
          the test fixture set up of your test cases &#8212; again, within the same
          transaction as the tests.</p>
        </li></ul></div>

      <p>The PetClinic application supports three data access technologies:
      JDBC, Hibernate, and JPA. By declaring
      <code class="interfacename">@ContextConfiguration</code> without any
      specific resource locations, the
      <code class="classname">AbstractClinicTests</code> class will have its
      application context loaded from the default location,
      <code class="literal">AbstractClinicTests-context.xml</code>, which declares a
      common <code class="classname">DataSource</code>. Subclasses specify additional
      context locations that must declare a
      <code class="interfacename">PlatformTransactionManager</code> and a concrete
      implementation of <code class="interfacename">Clinic</code>.</p>

      <p>For example, the Hibernate implementation of the PetClinic tests
      contains the following implementation. For this example,
      <code class="classname">HibernateClinicTests</code> does not contain a single
      line of code: we only need to declare
      <code class="interfacename">@ContextConfiguration</code>, and the tests are
      inherited from <code class="classname">AbstractClinicTests</code>. Because
      <code class="interfacename">@ContextConfiguration</code> is declared without
      any specific resource locations, the <span class="emphasis"><em>Spring TestContext
      Framework</em></span> loads an application context from all the beans
      defined in <code class="literal">AbstractClinicTests-context.xml</code> (i.e., the
      inherited locations) and
      <code class="literal">HibernateClinicTests-context.xml</code>, with
      <code class="literal">HibernateClinicTests-context.xml</code> possibly overriding
      beans defined in
      <code class="literal">AbstractClinicTests-context.xml</code>.</p>

      <pre class="programlisting"><span class="bold"><strong>@ContextConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HibernateClinicTests <span class="hl-keyword">extends</span> AbstractClinicTests { }
</pre>

      <p>In a large-scale application, the Spring configuration is often
      split across multiple files. Consequently, configuration locations are
      typically specified in a common base class for all application-specific
      integration tests. Such a base class may also add useful instance
      variables &#8212; populated by Dependency Injection, naturally &#8212; such as a
      <code class="classname">SessionFactory</code> in the case of an application
      using Hibernate.</p>

      <p>As far as possible, you should have exactly the same Spring
      configuration files in your integration tests as in the deployed
      environment. One likely point of difference concerns database connection
      pooling and transaction infrastructure. If you are deploying to a
      full-blown application server, you will probably use its connection pool
      (available through JNDI) and JTA implementation. Thus in production you
      will use a <code class="classname">JndiObjectFactoryBean</code> or
      <code class="literal">&lt;jee:jndi-lookup&gt;</code> for the
      <code class="classname">DataSource</code> and
      <code class="classname">JtaTransactionManager</code>. JNDI and JTA will not be
      available in out-of-container integration tests, so you should use a
      combination like the Commons DBCP <code class="classname">BasicDataSource</code>
      and <code class="classname">DataSourceTransactionManager</code> or
      <code class="classname">HibernateTransactionManager</code> for them. You can
      factor out this variant behavior into a single XML file, having the
      choice between application server and a 'local' configuration separated
      from all other configuration, which will not vary between the test and
      production environments. In addition, it is advisable to use properties
      files for connection settings. See the PetClinic application for an
      example.</p>
    </div>
  </div>

  <div class="section" title="11.4&nbsp;Further Resources"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing-resources"></a>11.4&nbsp;Further Resources</h2></div></div></div>
    

    <p>Consult the following resources for more information about
    testing:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><a class="ulink" href="http://www.junit.org/" target="_top">JUnit</a>: <span class="quote">&#8220;<span class="quote">
        <span class="emphasis"><em>A programmer-oriented testing framework for Java</em></span>
        </span>&#8221;</span>. Used by the Spring Framework in its test suite.</p>
      </li><li class="listitem">
        <p><a class="ulink" href="http://testng.org/" target="_top">TestNG</a>: A testing
        framework inspired by JUnit with added support for Java 5 annotations,
        test groups, data-driven testing, distributed testing, etc.</p>
      </li><li class="listitem">
        <p><a class="ulink" href="http://www.mockobjects.com/" target="_top">MockObjects.com</a>: Web site
        dedicated to mock objects, a technique for improving the design of
        code within test-driven development.</p>
      </li><li class="listitem">
        <p><a class="ulink" href="http://en.wikipedia.org/wiki/Mock_Object" target="_top">"Mock
        Objects"</a>: Article in Wikipedia.</p>
      </li><li class="listitem">
        <p><a class="ulink" href="http://www.easymock.org/" target="_top">EasyMock</a>: Java
        library <span class="quote">&#8220;<span class="quote"> <span class="emphasis"><em>that provides Mock Objects for interfaces
        (and objects through the class extension) by generating them on the
        fly using Java's proxy mechanism.</em></span> </span>&#8221;</span> Used by the
        Spring Framework in its test suite.</p>
      </li><li class="listitem">
        <p><a class="ulink" href="http://www.jmock.org/" target="_top">JMock</a>: Library that
        supports test-driven development of Java code with mock
        objects.</p>
      </li><li class="listitem">
        <p><a class="ulink" href="http://mockito.org/" target="_top">Mockito</a>: Java mock
        library based on the <a class="ulink" href="http://xunitpatterns.com/Test%20Spy.html" target="_top">test spy</a>
        pattern.</p>
      </li><li class="listitem">
        <p><a class="ulink" href="http://dbunit.sourceforge.net/" target="_top">DbUnit</a>:
        JUnit extension (also usable with Ant and Maven) targeted for
        database-driven projects that, among other things, puts your database
        into a known state between test runs.</p>
      </li><li class="listitem">
        <p><a class="ulink" href="http://grinder.sourceforge.net/" target="_top">The
        Grinder</a>: Java load testing framework.</p>
      </li></ul></div>
  </div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="aop-api.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-core.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="spring-data-tier.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">10.&nbsp;Spring AOP APIs&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;IV.&nbsp;Data Access</td></tr></table></div></body></html>