<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>20.&nbsp;Portlet MVC Framework</title><link rel="stylesheet" href="css/manual-multipage.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-web.html" title="Part&nbsp;V.&nbsp;The Web"><link rel="prev" href="web-integration.html" title="19.&nbsp;Integrating with other web frameworks"><link rel="next" href="spring-integration.html" title="Part&nbsp;VI.&nbsp;Integration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">20.&nbsp;Portlet MVC Framework</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="web-integration.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;The Web</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="spring-integration.html">Next</a></td></tr></table><hr></div><div class="chapter" title="20.&nbsp;Portlet MVC Framework"><div class="titlepage"><div><div><h2 class="title"><a name="portlet"></a>20.&nbsp;Portlet MVC Framework</h2></div></div></div>
  

  <div class="section" title="20.1&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-introduction"></a>20.1&nbsp;Introduction</h2></div></div></div>
    

    <div class="sidebar" title="JSR-168 The Java Portlet Specification"><p class="title"><b>JSR-168 The Java Portlet Specification</b></p>
      
      <p>For more general information about portlet development, please
      review a whitepaper from Sun entitled
      <a class="ulink" href="http://developers.sun.com/prodtech/portalserver/reference/techart/jsr168/" target="_top">"Introduction to JSR 168"</a>,
      and of course the
      <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr168/" target="_top">JSR-168 Specification</a> itself.</p>
    </div>

    <p>In addition to supporting conventional (servlet-based) Web development,
    Spring also supports JSR-168 Portlet development. As much as possible, the
    Portlet MVC framework is a mirror image of the Web MVC framework, and also
    uses the same underlying view abstractions and integration technology. So, be
    sure to review the chapters entitled <a class="xref" href="mvc.html" title="17.&nbsp;Web MVC framework">Chapter&nbsp;17, <i>Web MVC framework</i></a> and
    <a class="xref" href="view.html" title="18.&nbsp;View technologies">Chapter&nbsp;18, <i>View technologies</i></a> before continuing with this chapter.</p>

    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      <p>Bear in mind that while the concepts of Spring MVC are the
      same in Spring Portlet MVC, there are some notable differences
      created by the unique workflow of JSR-168 portlets.</p>
    </td></tr></table></div>

    <p>The main way in which portlet workflow differs from servlet
    workflow is that the request to the portlet can have two distinct
    phases: the action phase and the render phase. The action phase is
    executed only once and is where any 'backend' changes or actions occur,
    such as making changes in a database. The render phase then produces
    what is displayed to the user each time the display is refreshed.
    The critical point here is that for a single overall request, the action
    phase is executed only once, but the render phase may be executed
    multiple times. This provides (and requires) a clean separation between
    the activities that modify the persistent state of your system and the
    activities that generate what is displayed to the user.</p>

    
    <div class="sidebar" title="Spring Web Flow"><p class="title"><b>Spring Web Flow</b></p>
  

  <p>Spring Web Flow (SWF) aims to be the best solution for the management
  of web application page flow.</p>

  <p>SWF integrates with existing frameworks like Spring MVC, Struts, and
  JSF, in both servlet and portlet environments. If you have a business
  process (or processes) that would benefit from a conversational model as
  opposed to a purely request model, then SWF may be the solution.</p>

  <p>SWF allows you to capture logical page flows as self-contained modules
  that are reusable in different situations, and as such is ideal for building
  web application modules that guide the user through controlled navigations
  that drive business processes.</p>

  <p>For more information about SWF, consult the
  <a class="ulink" href="http://www.springframework.org/webflow" target="_top">Spring Web Flow website</a>.
  </p>
</div>

    <p>The dual phases of portlet requests are one of the real strengths
    of the JSR-168 specification. For example, dynamic search results can be
    updated routinely on the display without the user explicitly rerunning
    the search. Most other portlet MVC frameworks attempt to completely
    hide the two phases from the developer and make it look as much like
    traditional servlet development as possible - we think this
    approach removes one of the main benefits of using portlets. So, the
    separation of the two phases is preserved throughout the Spring Portlet
    MVC framework. The primary manifestation of this approach is that where
    the servlet version of the MVC classes will have one method that deals
    with the request, the portlet version of the MVC classes will have two
    methods that deal with the request: one for the action phase and one for
    the render phase. For example, where the servlet version of
    <code class="classname">AbstractController</code> has the
    <code class="methodname">handleRequestInternal(..)</code> method, the portlet
    version of <code class="classname">AbstractController</code> has
    <code class="methodname">handleActionRequestInternal(..)</code> and
    <code class="methodname">handleRenderRequestInternal(..)</code> methods.</p>

    <p>The framework is designed around a
    <code class="classname">DispatcherPortlet</code> that dispatches requests to
    handlers, with configurable handler mappings and view resolution, just
    as the <code class="classname">DispatcherServlet</code> in the web framework
    does. File upload is also supported in the same way.</p>

    <p>Locale resolution and theme resolution are not supported in
    Portlet MVC - these areas are in the purview of the
    portal/portlet container and are not appropriate at the Spring level.
    However, all mechanisms in Spring that depend on the locale (such as
    internationalization of messages) will still function properly because
    <code class="classname">DispatcherPortlet</code> exposes the current locale in
    the same way as <code class="classname">DispatcherServlet</code>.</p>

    <div class="section" title="20.1.1&nbsp;Controllers - The C in MVC"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-introduction-controller"></a>20.1.1&nbsp;Controllers - The C in MVC</h3></div></div></div>
      
      <p>The default handler is still a very simple
      <code class="interfacename">Controller</code> interface, offering just two
      methods:</p>
      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><code class="methodname">void handleActionRequest(request,response)</code> </p>
        </li><li class="listitem">
          <p><code class="methodname">ModelAndView handleRenderRequest(request,response)</code> </p>
        </li></ul></div>
      <p>The framework also includes most of the same controller
      implementation hierarchy, such as <code class="classname">AbstractController</code>,
      <code class="classname">SimpleFormController</code>, and so on. Data binding,
      command object usage, model handling, and view resolution are all the
      same as in the servlet framework.</p>
    </div>

    <div class="section" title="20.1.2&nbsp;Views - The V in MVC"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-introduction-view"></a>20.1.2&nbsp;Views - The V in MVC</h3></div></div></div>
      
      <p>All the view rendering capabilities of the servlet framework are
      used directly via a special bridge servlet named
      <code class="classname">ViewRendererServlet</code>. By using this servlet, the
      portlet request is converted into a servlet request and the view can be
      rendered using the entire normal servlet infrastructure. This means all
      the existing renderers, such as JSP, Velocity, etc., can still be used
      within the portlet.</p>
    </div>

    <div class="section" title="20.1.3&nbsp;Web-scoped beans"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-introduction-scope"></a>20.1.3&nbsp;Web-scoped beans</h3></div></div></div>
      
      <p>Spring Portlet MVC supports beans whose lifecycle is scoped to the
      current HTTP request or HTTP <code class="interfacename">Session</code> (both
      normal and global). This is not a specific feature of Spring Portlet MVC
      itself, but rather of the <code class="interfacename">WebApplicationContext</code>
      container(s) that Spring Portlet MVC uses. These bean scopes are described
      in detail in <a class="xref" href="beans.html#beans-factory-scopes-other" title="5.5.4&nbsp;Request, session, and global session scopes">Section&nbsp;5.5.4, &#8220;Request, session, and global session scopes&#8221;</a></p>
    </div>

    
    
  </div>

  <div class="section" title="20.2&nbsp;The DispatcherPortlet"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-dispatcher"></a>20.2&nbsp;The <code class="classname">DispatcherPortlet</code></h2></div></div></div>
    

    <p>Portlet MVC is a request-driven web MVC framework, designed around
    a portlet that dispatches requests to controllers and offers other
    functionality facilitating the development of portlet applications.
    Spring's <code class="classname">DispatcherPortlet</code> however, does more
    than just that. It is completely integrated with the Spring
    <code class="interfacename">ApplicationContext</code> and allows you to use
    every other feature Spring has.</p>

    <p>Like ordinary portlets, the
    <code class="classname">DispatcherPortlet</code> is declared in the
    <code class="literal">portlet.xml</code> file of your web application:</p>

    <pre class="programlisting"><span class="hl-tag">&lt;portlet&gt;</span>
    <span class="hl-tag">&lt;portlet-name&gt;</span>sample<span class="hl-tag">&lt;/portlet-name&gt;</span>
    <span class="hl-tag">&lt;portlet-class&gt;</span>org.springframework.web.portlet.DispatcherPortlet<span class="hl-tag">&lt;/portlet-class&gt;</span>
    <span class="hl-tag">&lt;supports&gt;</span>
        <span class="hl-tag">&lt;mime-type&gt;</span>text/html<span class="hl-tag">&lt;/mime-type&gt;</span>
        <span class="hl-tag">&lt;portlet-mode&gt;</span>view<span class="hl-tag">&lt;/portlet-mode&gt;</span>
    <span class="hl-tag">&lt;/supports&gt;</span>
    <span class="hl-tag">&lt;portlet-info&gt;</span>
        <span class="hl-tag">&lt;title&gt;</span>Sample Portlet<span class="hl-tag">&lt;/title&gt;</span>
    <span class="hl-tag">&lt;/portlet-info&gt;</span>
<span class="hl-tag">&lt;/portlet&gt;</span></pre>

    <p>The <code class="classname">DispatcherPortlet</code> now needs to be
    configured.</p>

    <p>In the Portlet MVC framework, each
    <code class="classname">DispatcherPortlet</code> has its own
    <code class="interfacename">WebApplicationContext</code>, which inherits all
    the beans already defined in the Root
    <code class="interfacename">WebApplicationContext</code>. These inherited
    beans can be overridden in the portlet-specific scope, and new
    scope-specific beans can be defined local to a given portlet instance.</p>

    <p>The framework will, on initialization of a
    <code class="classname">DispatcherPortlet</code>, look for a file named
    <code class="literal">[portlet-name]-portlet.xml</code> in the <code class="literal">WEB-INF</code>
    directory of your web application and create the beans defined there
    (overriding the definitions of any beans defined with the same name in
    the global scope).</p>

    <p>The config location used by the
    <code class="classname">DispatcherPortlet</code> can be modified through a
    portlet initialization parameter (see below for details).</p>

    <p>The Spring <code class="classname">DispatcherPortlet</code> has a few
    special beans it uses, in order to be able to process requests and
    render the appropriate views. These beans are included in the Spring
    framework and can be configured in the
    <code class="interfacename">WebApplicationContext</code>, just as any other
    bean would be configured. Each of those beans is described in more
    detail below. Right now, we'll just mention them, just to let you know
    they exist and to enable us to go on talking about the
    <code class="classname">DispatcherPortlet</code>. For most of the beans,
    defaults are provided so you don't have to worry about configuring
    them.</p>

    <div class="table"><a name="portlet-webappctx-special-beans-tbl"></a><p class="title"><b>Table&nbsp;20.1.&nbsp;Special beans in the <code class="interfacename">WebApplicationContext</code></b></p><div class="table-contents">
      
      <table summary="Special beans in the WebApplicationContext" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Expression</th><th style="border-bottom: 0.5pt solid ; ">Explanation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">handler mapping(s)</td><td style="border-bottom: 0.5pt solid ; ">(<a class="xref" href="portlet.html#portlet-handlermapping" title="20.5&nbsp;Handler mappings">Section&nbsp;20.5, &#8220;Handler mappings&#8221;</a>) a
            list of pre- and post-processors and controllers that
            will be executed if they match certain criteria (for
            instance a matching portlet mode specified with the
            controller)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">controller(s)</td><td style="border-bottom: 0.5pt solid ; ">(<a class="xref" href="portlet.html#portlet-controller" title="20.4&nbsp;Controllers">Section&nbsp;20.4, &#8220;Controllers&#8221;</a>) the beans
            providing the actual functionality (or at least, access
            to the functionality) as part of the MVC triad</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">view resolver</td><td style="border-bottom: 0.5pt solid ; ">(<a class="xref" href="portlet.html#portlet-viewresolver" title="20.6&nbsp;Views and resolving them">Section&nbsp;20.6, &#8220;Views and resolving them&#8221;</a>) capable
            of resolving view names to view definitions</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">multipart resolver</td><td style="border-bottom: 0.5pt solid ; ">(<a class="xref" href="portlet.html#portlet-multipart" title="20.7&nbsp;Multipart (file upload) support">Section&nbsp;20.7, &#8220;Multipart (file upload) support&#8221;</a>) offers
            functionality to process file uploads from HTML
            forms</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left">handler exception resolver</td><td style="">(<a class="xref" href="portlet.html#portlet-exceptionresolver" title="20.8&nbsp;Handling exceptions">Section&nbsp;20.8, &#8220;Handling exceptions&#8221;</a>)
            offers functionality to map exceptions to views or
            implement other more complex exception handling
            code</td></tr></tbody></table>
    </div></div><br class="table-break">

    <p>When a <code class="classname">DispatcherPortlet</code> is setup for use
    and a request comes in for that specific
    <code class="classname">DispatcherPortlet</code>, it starts processing the
    request. The list below describes the complete process a request goes
    through if handled by a <code class="classname">DispatcherPortlet</code>:</p>

    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The locale returned by
      <code class="literal">PortletRequest.getLocale()</code> is bound to the
      request to let elements in the process resolve the locale to use
      when processing the request (rendering the view, preparing data,
      etc.).</p></li><li class="listitem"><p>If a multipart resolver is specified and this is an
      <code class="interfacename">ActionRequest</code>, the request is
      inspected for multiparts and if they are found, it is wrapped in a
      <code class="interfacename">MultipartActionRequest</code> for further
      processing by other elements in the process. (See <a class="xref" href="portlet.html#portlet-multipart" title="20.7&nbsp;Multipart (file upload) support">Section&nbsp;20.7, &#8220;Multipart (file upload) support&#8221;</a> for further information about
      multipart handling).</p></li><li class="listitem"><p>An appropriate handler is searched for. If a handler
      is found, the execution chain associated with the handler
      (pre-processors, post-processors, controllers) will be executed in order
      to prepare a model.</p></li><li class="listitem"><p>If a model is returned, the view is rendered, using
      the view resolver that has been configured with the
      <code class="interfacename">WebApplicationContext</code>. If no model is
      returned (which could be due to a pre- or post-processor
      intercepting the request, for example, for security reasons), no
      view is rendered, since the request could already have been
      fulfilled.</p></li></ol></div>

    <p>Exceptions that are thrown during processing of the request
    get picked up by any of the handler exception resolvers that are
    declared in the <code class="interfacename">WebApplicationContext</code>.
    Using these exception resolvers you can define custom behavior in case
    such exceptions get thrown.</p>

    <p>You can customize Spring's <code class="classname">DispatcherPortlet</code>
    by adding context parameters in the <code class="literal">portlet.xml</code> file or
    portlet init-parameters. The possibilities are listed below.</p>

    <div class="table"><a name="portlet-dpp-init-params"></a><p class="title"><b>Table&nbsp;20.2.&nbsp;<code class="classname">DispatcherPortlet</code> initialization parameters</b></p><div class="table-contents">
      
      <table summary="DispatcherPortlet initialization parameters" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Parameter</th><th style="border-bottom: 0.5pt solid ; ">Explanation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">contextClass</code></td><td style="border-bottom: 0.5pt solid ; ">Class that implements
            <code class="interfacename">WebApplicationContext</code>,
            which will be used to instantiate the context used by
            this portlet. If this parameter isn't specified, the
            <code class="classname">XmlPortletApplicationContext</code> will
            be used.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">contextConfigLocation</code></td><td style="border-bottom: 0.5pt solid ; ">String which is passed to the context instance
            (specified by <code class="literal">contextClass</code>) to
            indicate where context(s) can be found. The String is
            potentially split up into multiple Strings (using a
            comma as a delimiter) to support multiple contexts (in
            case of multiple context locations, for beans that are
            defined twice, the latest takes precedence).</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">namespace</code></td><td style="border-bottom: 0.5pt solid ; ">The namespace of the
            <code class="interfacename">WebApplicationContext</code>.
            Defaults to <code class="literal">[portlet-name]-portlet</code>.</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left"><code class="literal">viewRendererUrl</code></td><td style="">The URL at which
            <code class="classname">DispatcherPortlet</code> can access an
            instance of <code class="classname">ViewRendererServlet</code>
            (see <a class="xref" href="portlet.html#portlet-viewservlet" title="20.3&nbsp;The ViewRendererServlet">Section&nbsp;20.3, &#8220;The <code class="classname">ViewRendererServlet</code>&#8221;</a>).</td></tr></tbody></table>
    </div></div><br class="table-break">
  </div>

  <div class="section" title="20.3&nbsp;The ViewRendererServlet"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-viewservlet"></a>20.3&nbsp;The <code class="classname">ViewRendererServlet</code></h2></div></div></div>
    

    <p>The rendering process in Portlet MVC is a bit more complex than in
    Web MVC. In order to reuse all the <a class="link" href="view.html" title="18.&nbsp;View technologies">view technologies</a>
    from Spring Web MVC, we must convert the
    <code class="interfacename">PortletRequest</code> /
    <code class="interfacename">PortletResponse</code> to
    <code class="interfacename">HttpServletRequest</code> /
    <code class="interfacename">HttpServletResponse</code> and then call the
    <code class="literal">render</code> method of the
    <code class="interfacename">View</code>. To do this,
    <code class="classname">DispatcherPortlet</code> uses a special servlet that
    exists for just this purpose: the
    <code class="classname">ViewRendererServlet</code>.</p>

    <p>In order for <code class="classname">DispatcherPortlet</code> rendering to
    work, you must declare an instance of the
    <code class="classname">ViewRendererServlet</code> in the
    <code class="literal">web.xml</code> file for your web application as
    follows:</p>

    <pre class="programlisting"><span class="hl-tag">&lt;servlet&gt;</span>
    <span class="hl-tag">&lt;servlet-name&gt;</span>ViewRendererServlet<span class="hl-tag">&lt;/servlet-name&gt;</span>
    <span class="hl-tag">&lt;servlet-class&gt;</span>org.springframework.web.servlet.ViewRendererServlet<span class="hl-tag">&lt;/servlet-class&gt;</span>
<span class="hl-tag">&lt;/servlet&gt;</span>

<span class="hl-tag">&lt;servlet-mapping&gt;</span>
    <span class="hl-tag">&lt;servlet-name&gt;</span>ViewRendererServlet<span class="hl-tag">&lt;/servlet-name&gt;</span>
    <span class="hl-tag">&lt;url-pattern&gt;</span>/WEB-INF/servlet/view<span class="hl-tag">&lt;/url-pattern&gt;</span>
<span class="hl-tag">&lt;/servlet-mapping&gt;</span></pre>

    <p>To perform the actual rendering, <code class="classname">DispatcherPortlet</code>
    does the following:</p>

    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Binds the
      <code class="interfacename">WebApplicationContext</code> to the request
      as an attribute under the same
      <code class="literal">WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> key that
      <code class="classname">DispatcherServlet</code> uses.</p></li><li class="listitem"><p>Binds the <code class="interfacename">Model</code> and
      <code class="interfacename">View</code> objects to the request to make
      them available to the
      <code class="classname">ViewRendererServlet</code>.</p></li><li class="listitem"><p>Constructs a
      <code class="interfacename">PortletRequestDispatcher</code> and performs
      an <code class="literal">include</code> using the <code class="literal">/WEB-
      INF/servlet/view</code> URL that is mapped to the
      <code class="classname">ViewRendererServlet</code>.</p></li></ol></div>

    <p>The <code class="classname">ViewRendererServlet</code> is then able to
    call the <code class="literal">render</code> method on the
    <code class="interfacename">View</code> with the appropriate
    arguments.</p>

    <p>The actual URL for the <code class="classname">ViewRendererServlet</code>
    can be changed using <code class="classname">DispatcherPortlet</code>&#8217;s
    <code class="literal">viewRendererUrl</code> configuration parameter.</p>

  </div>

  <div class="section" title="20.4&nbsp;Controllers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-controller"></a>20.4&nbsp;Controllers</h2></div></div></div>
    

    <p>The controllers in Portlet MVC are very similar to the Web MVC
    Controllers, and porting code from one to the other should be
    simple.</p>

    <p>The basis for the Portlet MVC controller architecture is the
    <code class="interfacename">org.springframework.web.portlet.mvc.Controller</code>
    interface, which is listed below.</p>

    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Controller {

    <b class="hl-tag" style="color: blue">/**
     * Process the render request and return a ModelAndView object which the
     * DispatcherPortlet will render.
     */</b>
    ModelAndView handleRenderRequest(RenderRequest request, RenderResponse response)
        <span class="hl-keyword">throws</span> Exception;

    <b class="hl-tag" style="color: blue">/**
     * Process the action request. There is nothing to return.
     */</b>
    <span class="hl-keyword">void</span> handleActionRequest(ActionRequest request, ActionResponse response)
        <span class="hl-keyword">throws</span> Exception;
}</pre>

    <p>As you can see, the Portlet
    <code class="interfacename">Controller</code> interface requires two methods
    that handle the two phases of a portlet request: the action request and
    the render request. The action phase should be capable of handling an
    action request, and the render phase should be capable of handling a
    render request and returning an appropriate model and view. While the
    <code class="interfacename">Controller</code> interface is quite abstract,
    Spring Portlet MVC offers several controllers that already contain a
    lot of the functionality you might need; most of these are very similar
    to controllers from Spring Web MVC. The
    <code class="interfacename">Controller</code> interface just defines the
    most common functionality required of every controller: handling an
    action request, handling a render request, and returning a model and a
    view.</p>

    <div class="section" title="20.4.1&nbsp;AbstractController and PortletContentGenerator"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-controller-abstractcontroller"></a>20.4.1&nbsp;<code class="classname">AbstractController</code> and <code class="classname">PortletContentGenerator</code></h3></div></div></div>
      

      <p>Of course, just a <code class="interfacename">Controller</code>
      interface isn't enough. To provide a basic infrastructure, all of
      Spring Portlet MVC's <code class="interfacename">Controller</code>s
      inherit from <code class="classname">AbstractController</code>, a class
      offering access to Spring's
      <code class="interfacename">ApplicationContext</code> and control over
      caching.</p>

      <div class="table"><a name="portlet-ac-features"></a><p class="title"><b>Table&nbsp;20.3.&nbsp;Features offered by the <code class="classname">AbstractController</code></b></p><div class="table-contents">
        
        <table summary="Features offered by the AbstractController" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Parameter</th><th style="border-bottom: 0.5pt solid ; ">Explanation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">requireSession</code></td><td style="border-bottom: 0.5pt solid ; ">Indicates whether or not this
              <code class="interfacename">Controller</code> requires a
              session to do its work. This feature is offered to
              all controllers. If a session is not present when
              such a controller receives a request, the user is
              informed using a
              <code class="classname">SessionRequiredException</code>.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">synchronizeSession</code></td><td style="border-bottom: 0.5pt solid ; ">Use this if you want handling by this
              controller to be synchronized on the user's session.
              To be more specific, the extending controller will
              override the <code class="methodname">handleRenderRequestInternal(..)</code> and
              <code class="methodname">handleActionRequestInternal(..)</code> methods, which will be
              synchronized on the user&#8217;s session if you specify
              this variable.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><code class="literal">renderWhenMinimized</code></td><td style="border-bottom: 0.5pt solid ; ">If you want your controller to actually
              render the view when the portlet is in a minimized
              state, set this to true. By default, this is set to
              false so that portlets that are in a minimized state
              don&#8217;t display any content.</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left"><code class="literal">cacheSeconds</code></td><td style="">When you want a controller to override the
              default cache expiration defined for the portlet,
              specify a positive integer here. By default it is
              set to <code class="literal">-1</code>, which does not change
              the default caching. Setting it to <code class="literal">0</code>
              will ensure the result is never cached.</td></tr></tbody></table>
      </div></div><br class="table-break">

      <p>The <code class="literal">requireSession</code> and
      <code class="literal">cacheSeconds</code> properties are declared on the
      <code class="classname">PortletContentGenerator</code> class, which is the
      superclass of <code class="classname">AbstractController</code>) but are
      included here for completeness.</p>

      <p>When using the <code class="classname">AbstractController</code> as a
      base class for your controllers (which is not recommended since there
      are a lot of other controllers that might already do the job for
      you) you only have to override either the
      <code class="methodname">handleActionRequestInternal(ActionRequest,
      ActionResponse)</code> method or the
      <code class="methodname">handleRenderRequestInternal(RenderRequest,
      RenderResponse)</code> method (or both), implement your logic,
      and return a <code class="classname">ModelAndView</code> object (in the case
      of <code class="literal">handleRenderRequestInternal</code>).</p>

      <p>The default implementations of both
      <code class="methodname">handleActionRequestInternal(..)</code> and
      <code class="methodname">handleRenderRequestInternal(..)</code> throw a
      <code class="classname">PortletException</code>. This is consistent with
      the behavior of <code class="classname">GenericPortlet</code> from the JSR-
      168 Specification API. So you only need to override the method that
      your controller is intended to handle.</p>

      <p>Here is short example consisting of a class and a declaration
      in the web application context.</p>

      <pre class="programlisting"><span class="hl-keyword">package</span> samples;

<span class="hl-keyword">import</span> javax.portlet.RenderRequest;
<span class="hl-keyword">import</span> javax.portlet.RenderResponse;

<span class="hl-keyword">import</span> org.springframework.web.portlet.mvc.AbstractController;
<span class="hl-keyword">import</span> org.springframework.web.portlet.ModelAndView;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SampleController <span class="hl-keyword">extends</span> AbstractController {

    <span class="hl-keyword">public</span> ModelAndView handleRenderRequestInternal(RenderRequest request, RenderResponse response) {
        ModelAndView mav = <span class="hl-keyword">new</span> ModelAndView(<span class="hl-string">"foo"</span>);
        mav.addObject(<span class="hl-string">"message"</span>, <span class="hl-string">"Hello World!"</span>);
        <span class="hl-keyword">return</span> mav;
    }
}

&lt;bean id=<span class="hl-string">"sampleController"</span> <span class="hl-keyword">class</span>=<span class="hl-string">"samples.SampleController"</span>&gt;
    &lt;property name=<span class="hl-string">"cacheSeconds"</span> value=<span class="hl-string">"120"</span>/&gt;
&lt;/bean&gt;</pre>

      <p>The class above and the declaration in the web application
      context is all you need besides setting up a handler mapping (see
      <a class="xref" href="portlet.html#portlet-handlermapping" title="20.5&nbsp;Handler mappings">Section&nbsp;20.5, &#8220;Handler mappings&#8221;</a>) to get this very simple
      controller working.</p>
    </div>

    <div class="section" title="20.4.2&nbsp;Other simple controllers"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-controller-simple"></a>20.4.2&nbsp;Other simple controllers</h3></div></div></div>
      

      <p>Although you can extend <code class="classname">AbstractController</code>,
      Spring Portlet MVC provides a number of concrete implementations which offer
      functionality that is commonly used in simple MVC applications.</p>

      <p>The <code class="classname">ParameterizableViewController</code> is
      basically the same as the example above, except for the fact that
      you can specify the view name that it will return in the web
      application context (no need to hard-code the view name).</p>

      <p>The <code class="classname">PortletModeNameViewController</code> uses
      the current mode of the portlet as the view name. So, if your
      portlet is in View mode (i.e. <code class="literal">PortletMode.VIEW</code>)
      then it uses "view" as the view name.</p>
    </div>

    <div class="section" title="20.4.3&nbsp;Command Controllers"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-controller-command"></a>20.4.3&nbsp;Command Controllers</h3></div></div></div>
      

      <p>Spring Portlet MVC has the exact same hierarchy of
      <span class="emphasis"><em>command controllers</em></span> as Spring Web MVC. They
      provide a way to interact with data objects and dynamically bind
      parameters from the <code class="interfacename">PortletRequest</code> to
      the data object specified. Your data objects don't have to
      implement a framework-specific interface, so you can directly
      manipulate your persistent objects if you desire. Let's examine what
      command controllers are available, to get an overview of what you can do
      with them:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="classname">AbstractCommandController</code>
        - a command controller you can use to create your own command
        controller, capable of binding request parameters to a data
        object you specify. This class does not offer form
        functionality, it does however offer validation features and
        lets you specify in the controller itself what to do with the
        command object that has been filled with the parameters from the
        request.</p></li><li class="listitem"><p><code class="classname">AbstractFormController</code> -
        an abstract controller offering form submission support. Using
        this controller you can model forms and populate them using a
        command object you retrieve in the controller. After a user has
        filled the form, <code class="classname">AbstractFormController</code>
        binds the fields, validates, and hands the object back to the
        controller to take appropriate action. Supported features are:
        invalid form submission (resubmission), validation, and normal
        form workflow. You implement methods to determine which views
        are used for form presentation and success. Use this controller
        if you need forms, but don't want to specify what views you're
        going to show the user in the application
        context.</p></li><li class="listitem"><p><code class="classname">SimpleFormController</code> - a
        concrete <code class="classname">AbstractFormController</code> that
        provides even more support when creating a form with a
        corresponding command object. The
        <code class="classname">SimpleFormController</code> lets you specify a
        command object, a viewname for the form, a viewname for the page you
        want to show the user when form submission has succeeded, and
        more.</p></li><li class="listitem"><p><code class="classname">AbstractWizardFormController</code> &#8211;
        a concrete <code class="classname">AbstractFormController</code> that
        provides a wizard-style interface for editing the contents of a
        command object across multiple display pages. Supports multiple
        user actions: finish, cancel, or page change, all of which are
        easily specified in request parameters from the
        view.</p></li></ul></div>

      <p>These command controllers are quite powerful, but they do
      require a detailed understanding of how they operate in order to use
      them efficiently. Carefully review the Javadocs for this entire
      hierarchy and then look at some sample implementations before you
      start using them.</p>
    </div>

    <div class="section" title="20.4.4&nbsp;PortletWrappingController"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-controller-wrapping"></a>20.4.4&nbsp;<code class="classname">PortletWrappingController</code></h3></div></div></div>
      

      <p>Instead of developing new controllers, it is possible to use
      existing portlets and map requests to them from a
      <code class="classname">DispatcherPortlet</code>. Using the
      <code class="classname">PortletWrappingController</code>, you can
      instantiate an existing <code class="interfacename">Portlet</code> as a
      <code class="interfacename">Controller</code> as follows:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myPortlet"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.portlet.mvc.PortletWrappingController"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portletClass"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sample.MyPortlet"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portletName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"my-portlet"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"initParameters"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;value&gt;</span>config=/WEB-INF/my-portlet-config.xml<span class="hl-tag">&lt;/value&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>This can be very valuable since you can then use interceptors
      to pre-process and post-process requests going to these portlets.
      Since JSR-168 does not support any kind of filter mechanism, this is
      quite handy. For example, this can be used to wrap the Hibernate
      <code class="classname">OpenSessionInViewInterceptor</code> around a MyFaces
      JSF Portlet.</p>
    </div>
  </div>

  <div class="section" title="20.5&nbsp;Handler mappings"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-handlermapping"></a>20.5&nbsp;Handler mappings</h2></div></div></div>
    

    <p>Using a handler mapping you can map incoming portlet requests to
    appropriate handlers. There are some handler mappings you can use out
    of the box, for example, the
    <code class="classname">PortletModeHandlerMapping</code>, but let's first
    examine the general concept of a
    <code class="interfacename">HandlerMapping</code>.</p>

    <p>Note: We are intentionally using the term &#8220;Handler&#8221; here instead
    of &#8220;Controller&#8221;. <code class="classname">DispatcherPortlet</code> is designed
    to be used with other ways to process requests than just Spring Portlet
    MVC&#8217;s own Controllers. A Handler is any Object that can handle portlet
    requests. Controllers are an example of Handlers, and they are of
    course the default. To use some other framework with
    <code class="classname">DispatcherPortlet</code>, a corresponding implementation
    of <code class="interfacename">HandlerAdapter</code> is all that is needed.</p>

    <p>The functionality a basic
    <code class="interfacename">HandlerMapping</code> provides is the delivering
    of a <code class="classname">HandlerExecutionChain</code>, which must contain
    the handler that matches the incoming request, and may also contain a
    list of handler interceptors that are applied to the request. When a
    request comes in, the <code class="classname">DispatcherPortlet</code> will hand
    it over to the handler mapping to let it inspect the request and come up
    with an appropriate <code class="classname">HandlerExecutionChain</code>. Then
    the <code class="classname">DispatcherPortlet</code> will execute the handler
    and interceptors in the chain (if any). These concepts are all exactly
    the same as in Spring Web MVC.</p>

    <p>The concept of configurable handler mappings that can optionally
    contain interceptors (executed before or after the actual handler was
    executed, or both) is extremely powerful. A lot of supporting
    functionality can be built into a custom
    <code class="interfacename">HandlerMapping</code>. Think of a custom handler
    mapping that chooses a handler not only based on the portlet mode of the
    request coming in, but also on a specific state of the session
    associated with the request.</p>

    <p>In Spring Web MVC, handler mappings are commonly based on URLs.
    Since there is really no such thing as a URL within a Portlet, we must
    use other mechanisms to control mappings. The two most common are the
    portlet mode and a request parameter, but anything available to the
    portlet request can be used in a custom handler mapping.</p>

    <p>The rest of this section describes three of Spring Portlet MVC's
    most commonly used handler mappings. They all extend
    <code class="classname">AbstractHandlerMapping</code> and share the following
    properties:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">interceptors</code>: The list of
      interceptors to use.
      <code class="interfacename">HandlerInterceptor</code>s are discussed in
      <a class="xref" href="portlet.html#portlet-handlermapping-interceptor" title="20.5.4&nbsp;Adding HandlerInterceptors">Section&nbsp;20.5.4, &#8220;Adding <code class="interfacename">HandlerInterceptor</code>s&#8221;</a>.</p></li><li class="listitem"><p><code class="literal">defaultHandler</code>: The default
      handler to use, when this handler mapping does not result in a
      matching handler.</p></li><li class="listitem"><p><code class="literal">order</code>: Based on the value of the
      order property (see the
      <code class="interfacename">org.springframework.core.Ordered</code>
      interface), Spring will sort all handler mappings available in the
      context and apply the first matching handler.</p></li><li class="listitem"><p><code class="literal">lazyInitHandlers</code>: Allows for lazy
      initialization of singleton handlers (prototype handlers are always
      lazily initialized). Default value is false. This property is
      directly implemented in the three concrete
      Handlers.</p></li></ul></div>

    <div class="section" title="20.5.1&nbsp;PortletModeHandlerMapping"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-portletmode"></a>20.5.1&nbsp;<code class="classname">PortletModeHandlerMapping</code></h3></div></div></div>
      

      <p>This is a simple handler mapping that maps incoming requests
      based on the current mode of the portlet (e.g. &#8216;view&#8217;, &#8216;edit&#8217;,
      &#8216;help&#8217;). An example:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.portlet.handler.PortletModeHandlerMapping"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portletModeMap"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;map&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"view"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"viewHandler"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"edit"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"editHandler"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"help"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"helpHandler"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
    </div>

    <div class="section" title="20.5.2&nbsp;ParameterHandlerMapping"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-parameter"></a>20.5.2&nbsp;<code class="classname">ParameterHandlerMapping</code></h3></div></div></div>
      

      <p>If we need to navigate around to multiple controllers without
      changing portlet mode, the simplest way to do this is with a request
      parameter that is used as the key to control the mapping.</p>

      <p><code class="classname">ParameterHandlerMapping</code> uses the value
      of a specific request parameter to control the mapping. The default
      name of the parameter is <code class="literal">'action'</code>, but can be changed
      using the <code class="literal">'parameterName'</code> property.</p>

      <p>The bean configuration for this mapping will look something
      like this:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.portlet.handler.ParameterHandlerMapping&#8221;&gt;
    &lt;property name="</span><span class="hl-attribute">parameterMap"&gt;</span>
        <span class="hl-attribute">&lt;map&gt;</span>
            <span class="hl-attribute">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"add"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"addItemHandler"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"edit"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"editItemHandler"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"delete"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"deleteItemHandler"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
    </div>

    <div class="section" title="20.5.3&nbsp;PortletModeParameterHandlerMapping"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-portletmodeparameter"></a>20.5.3&nbsp;<code class="classname">PortletModeParameterHandlerMapping</code></h3></div></div></div>
      

      <p>The most powerful built-in handler mapping,
      <code class="classname">PortletModeParameterHandlerMapping</code> combines
      the capabilities of the two previous ones to allow different
      navigation within each portlet mode.</p>

      <p>Again the default name of the parameter is "action", but can
      be changed using the <code class="literal">parameterName</code>
      property.</p>

      <p>By default, the same parameter value may not be used in two
      different portlet modes. This is so that if the portal itself
      changes the portlet mode, the request will no longer be valid in the
      mapping. This behavior can be changed by setting the
      <code class="literal">allowDupParameters</code> property to true. However,
      this is not recommended.</p>

      <p>The bean configuration for this mapping will look something
      like this:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.portlet.handler.PortletModeParameterHandlerMapping"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portletModeParameterMap"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;map&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"view"</span><span class="hl-tag">&gt;</span> <em class="lineannotation"><span class="lineannotation">&lt;!-- 'view' portlet mode --&gt;</span></em>
                <span class="hl-tag">&lt;map&gt;</span>
                    <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"add"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"addItemHandler"</span><span class="hl-tag">/&gt;</span>
                    <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"edit"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"editItemHandler"</span><span class="hl-tag">/&gt;</span>
                    <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"delete"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"deleteItemHandler"</span><span class="hl-tag">/&gt;</span>
                <span class="hl-tag">&lt;/map&gt;</span>
            <span class="hl-tag">&lt;/entry&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"edit"</span><span class="hl-tag">&gt;</span> <em class="lineannotation"><span class="lineannotation">&lt;!-- 'edit' portlet mode --&gt;</span></em>
                <span class="hl-tag">&lt;map&gt;</span>
                    <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"prefs"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"prefsHandler"</span><span class="hl-tag">/&gt;</span>
                    <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"resetPrefs"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"resetPrefsHandler"</span><span class="hl-tag">/&gt;</span>
                <span class="hl-tag">&lt;/map&gt;</span>
            <span class="hl-tag">&lt;/entry&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>This mapping can be chained ahead of a
      <code class="classname">PortletModeHandlerMapping</code>, which can then provide
      defaults for each mode and an overall default as well.</p>
    </div>

    <div class="section" title="20.5.4&nbsp;Adding HandlerInterceptors"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-interceptor"></a>20.5.4&nbsp;Adding <code class="interfacename">HandlerInterceptor</code>s</h3></div></div></div>
      

      <p>Spring's handler mapping mechanism has a notion of handler
      interceptors, which can be extremely useful when you want to apply
      specific functionality to certain requests, for example, checking
      for a principal. Again Spring Portlet MVC implements these concepts
      in the same way as Web MVC.</p>

      <p>Interceptors located in the handler mapping must implement
      <code class="interfacename">HandlerInterceptor</code> from the
      <code class="literal">org.springframework.web.portlet</code> package. Just
      like the servlet version, this interface defines three methods: one
      that will be called before the actual handler will be executed
      (<code class="literal">preHandle</code>), one that will be called after the
      handler is executed (<code class="literal">postHandle</code>), and one that is
      called after the complete request has finished
      (<code class="literal">afterCompletion</code>). These three methods should
      provide enough flexibility to do all kinds of pre- and post-
      processing.</p>

      <p>The <code class="literal">preHandle</code> method returns a boolean
      value. You can use this method to break or continue the processing
      of the execution chain. When this method returns
      <code class="literal">true</code>, the handler execution chain will continue.
      When it returns <code class="literal">false</code>, the
      <code class="classname">DispatcherPortlet</code> assumes the interceptor
      itself has taken care of requests (and, for example, rendered an
      appropriate view) and does not continue executing the other
      interceptors and the actual handler in the execution chain.</p>

      <p>The <code class="literal">postHandle</code> method is only called on a
      <code class="interfacename">RenderRequest</code>. The
      <code class="literal">preHandle</code> and <code class="literal">afterCompletion</code>
      methods are called on both an
      <code class="interfacename">ActionRequest</code> and a
      <code class="interfacename">RenderRequest</code>. If you need to
      execute logic in these methods for just one type of request, be sure
      to check what kind of request it is before processing it.</p>
    </div>

    <div class="section" title="20.5.5&nbsp;HandlerInterceptorAdapter"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-interceptoradapter"></a>20.5.5&nbsp;<code class="classname">HandlerInterceptorAdapter</code></h3></div></div></div>
      

      <p>As with the servlet package, the portlet package has a
      concrete implementation of
      <code class="interfacename">HandlerInterceptor</code> called
      <code class="classname">HandlerInterceptorAdapter</code>. This class has
      empty versions of all the methods so that you can inherit from this
      class and implement just one or two methods when that is all you
      need.</p>

    </div>

    <div class="section" title="20.5.6&nbsp;ParameterMappingInterceptor"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-parameterinterceptor"></a>20.5.6&nbsp;<code class="classname">ParameterMappingInterceptor</code></h3></div></div></div>
      

      <p>The portlet package also has a concrete interceptor named
      <code class="classname">ParameterMappingInterceptor</code> that is meant to
      be used directly with <code class="classname">ParameterHandlerMapping</code>
      and <code class="classname">PortletModeParameterHandlerMapping</code>. This
      interceptor will cause the parameter that is being used to control
      the mapping to be forwarded from an
      <code class="interfacename">ActionRequest</code> to the subsequent
      <code class="interfacename">RenderRequest</code>. This will help ensure
      that the <code class="interfacename">RenderRequest</code> is mapped to
      the same Handler as the
      <code class="interfacename">ActionRequest</code>. This is done in the
      <code class="literal">preHandle</code> method of the interceptor, so you can
      still modify the parameter value in your handler to change where the
      <code class="interfacename">RenderRequest</code> will be mapped.</p>

      <p>Be aware that this interceptor is calling
      <code class="literal">setRenderParameter</code> on the
      <code class="interfacename">ActionResponse</code>, which means that you
      cannot call <code class="literal">sendRedirect</code> in your handler when
      using this interceptor. If you need to do external redirects then
      you will either need to forward the mapping parameter manually or
      write a different interceptor to handle this for you.</p>
    </div>
  </div>

  <div class="section" title="20.6&nbsp;Views and resolving them"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-viewresolver"></a>20.6&nbsp;Views and resolving them</h2></div></div></div>
    

    <p>As mentioned previously, Spring Portlet MVC directly reuses all
    the view technologies from Spring Web MVC. This includes not only the
    various <code class="interfacename">View</code> implementations themselves,
    but also the <code class="interfacename">ViewResolver</code> implementations.
    For more information, refer to <a class="xref" href="view.html" title="18.&nbsp;View technologies">Chapter&nbsp;18, <i>View technologies</i></a> and
    <a class="xref" href="mvc.html#mvc-viewresolver" title="17.5&nbsp;Resolving views">Section&nbsp;17.5, &#8220;Resolving views&#8221;</a> respectively.</p>

    <p>A few items on using the existing <code class="interfacename">View</code> and
    <code class="interfacename">ViewResolver</code> implementations  are worth mentioning:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Most portals expect the result of rendering a
      portlet to be an HTML fragment. So, things like JSP/JSTL, Velocity,
      FreeMarker, and XSLT all make sense. But it is unlikely that views
      that return other document types will make any sense in a portlet
      context.</p></li><li class="listitem"><p>There is no such thing as an HTTP redirect from
      within a portlet (the <code class="literal">sendRedirect(..)</code> method of
      <code class="interfacename">ActionResponse</code> cannot
      be used to stay within the portal). So, <code class="classname">RedirectView</code>
      and use of the <code class="literal">'redirect:'</code> prefix will
      <span class="bold"><strong>not</strong></span> work correctly from within Portlet MVC.</p></li><li class="listitem"><p>It may be possible to use the <code class="literal">'forward:'</code> prefix from
      within Portlet MVC. However, remember that since you are in a
      portlet, you have no idea what the current URL looks like. This
      means you cannot use a relative URL to access other resources in
      your web application and that you will have to use an absolute
      URL.</p></li></ul></div>

    <p>Also, for JSP development, the new Spring Taglib and the new
    Spring Form Taglib both work in portlet views in exactly the same way
    that they work in servlet views.</p>
  </div>

  <div class="section" title="20.7&nbsp;Multipart (file upload) support"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-multipart"></a>20.7&nbsp;Multipart (file upload) support</h2></div></div></div>
    

    <p>Spring Portlet MVC has built-in multipart support to handle file
    uploads in portlet applications, just like Web MVC does. The design for
    the multipart support is done with pluggable
    <code class="interfacename">PortletMultipartResolver</code> objects, defined
    in the <code class="literal">org.springframework.web.portlet.multipart</code>
    package. Spring provides a <code class="interfacename">PortletMultipartResolver</code>
    for use with
    <a class="ulink" href="http://jakarta.apache.org/commons/fileupload" target="_top">Commons FileUpload</a>.
    How uploading files is supported will be described in the rest of this section.</p>

    <p>By default, no multipart handling will be done by Spring Portlet
    MVC, as some developers will want to handle multiparts themselves. You
    will have to enable it yourself by adding a multipart resolver to the
    web application's context. After you have done that,
    <code class="classname">DispatcherPortlet</code> will inspect each request to
    see if it contains a multipart. If no multipart is found, the request
    will continue as expected. However, if a multipart is found in the
    request, the <code class="interfacename">PortletMultipartResolver</code>
    that has been declared in your context will be used. After that, the
    multipart attribute in your request will be treated like any other
    attribute.</p>

    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      <p>Any configured <code class="interfacename">PortletMultipartResolver</code>
      bean <span class="emphasis"><em>must</em></span> have the following id (or name):
      "<code class="literal">portletMultipartResolver</code>". If you have defined your
      <code class="interfacename">PortletMultipartResolver</code> with any other name,
      then the <code class="classname">DispatcherPortlet</code> will <span class="emphasis"><em>not</em></span>
      find your <code class="interfacename">PortletMultipartResolver</code>, and
      consequently no multipart support will be in effect.</p>
    </td></tr></table></div>

    <div class="section" title="20.7.1&nbsp;Using the PortletMultipartResolver"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-multipart-resolver"></a>20.7.1&nbsp;Using the <code class="interfacename">PortletMultipartResolver</code></h3></div></div></div>
      

      <p>The following example shows how to use the
      <code class="classname">CommonsPortletMultipartResolver</code>:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"portletMultipartResolver"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.portlet.multipart.CommonsPortletMultipartResolver"</span><span class="hl-tag">&gt;</span>

    <em class="lineannotation"><span class="lineannotation">&lt;!-- one of the properties available; the maximum file size in bytes --&gt;</span></em>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxUploadSize"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>Of course you also need to put the appropriate jars in your
      classpath for the multipart resolver to work. In the case of the
      <code class="classname">CommonsMultipartResolver</code>, you need to use
      <code class="literal">commons-fileupload.jar</code>. Be sure to use at least
      version 1.1 of Commons FileUpload as previous versions do not
      support JSR-168 Portlet applications.</p>

      <p>Now that you have seen how to set Portlet MVC up to handle
      multipart requests, let's talk about how to actually use it. When
      <code class="classname">DispatcherPortlet</code> detects a multipart
      request, it activates the resolver that has been declared in your
      context and hands over the request. What the resolver then does is
      wrap the current <code class="interfacename">ActionRequest</code> in a
      <code class="interfacename">MultipartActionRequest</code> that has
      support for multipart file uploads. Using the
      <code class="interfacename">MultipartActionRequest</code> you can get
      information about the multiparts contained by this request and
      actually get access to the multipart files themselves in your
      controllers.</p>

      <p>Note that you can only receive multipart file uploads as part
      of an <code class="interfacename">ActionRequest</code>, not as part of a
      <code class="interfacename">RenderRequest</code>.</p>
    </div>

    <div class="section" title="20.7.2&nbsp;Handling a file upload in a form"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-multipart-forms"></a>20.7.2&nbsp;Handling a file upload in a form</h3></div></div></div>
      

      <p>After the
      <code class="interfacename">PortletMultipartResolver</code> has finished
      doing its job, the request will be processed like any other. To use
      the <code class="interfacename">PortletMultipartResolver</code>, create
      a form with an upload field (see example below),
      then let Spring bind the file onto your form (backing object). To
      actually let the user upload a file, we have to create a (JSP/HTML)
      form:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;h1&gt;</span>Please upload a file<span class="hl-tag">&lt;/h1&gt;</span>
<span class="hl-tag">&lt;form</span> <span class="hl-attribute">method</span>=<span class="hl-value">"post"</span> <span class="hl-attribute">action</span>=<span class="hl-value">"&lt;portlet:actionURL/&gt;"</span> <span class="hl-attribute">enctype</span>=<span class="hl-value">"multipart/form-data"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"file"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"file"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"submit"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/form&gt;</span></pre>

      <p>As you can see, we've created a field named &#8220;file&#8221; that matches the
      property of the bean that holds the <code class="literal">byte[]</code> array.
      Furthermore we've added the encoding attribute
      (<code class="literal">enctype="multipart/form-data"</code>), which is
      necessary to let the browser know how to encode the multipart fields
      (do not forget this!).</p>

      <p>Just as with any other property that's not automagically
      convertible to a string or primitive type, to be able to put binary
      data in your objects you have to register a custom editor with the
      <code class="classname">PortletRequestDataBinder</code>. There are a couple
      of editors available for handling files and setting the results on
      an object. There's a
      <code class="classname">StringMultipartFileEditor</code> capable of
      converting files to Strings (using a user-defined character set), and
      there is a <code class="classname">ByteArrayMultipartFileEditor</code> which
      converts files to byte arrays. They function analogous to the
      <code class="classname">CustomDateEditor</code>.</p>

      <p>So, to be able to upload files using a form, declare the
      resolver, a mapping to a controller that will process the bean, and
      the controller itself.</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"portletMultipartResolver"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.portlet.multipart.CommonsPortletMultipartResolver"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.portlet.handler.PortletModeHandlerMapping"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portletModeMap"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;map&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"view"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"fileUploadController"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"fileUploadController"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"examples.FileUploadController"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"commandClass"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"examples.FileUploadBean"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"formView"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"fileuploadform"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"successView"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"confirmation"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>After that, create the controller and the actual class to hold
      the file property.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FileUploadController <span class="hl-keyword">extends</span> SimpleFormController {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onSubmitAction(ActionRequest request, ActionResponse response,
            Object command, BindException errors) <span class="hl-keyword">throws</span> Exception {

        <em class="lineannotation"><span class="lineannotation">// cast the bean</span></em>
        FileUploadBean bean = (FileUploadBean) command;

        <em class="lineannotation"><span class="lineannotation">// let's see if there's content there</span></em>
        <span class="hl-keyword">byte</span>[] file = bean.getFile();
        <span class="hl-keyword">if</span> (file == null) {
            <em class="lineannotation"><span class="lineannotation">// hmm, that's strange, the user did not upload anything</span></em>
        }

        <span class="hl-comment">// do something with the file here</span>
    }

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> initBinder(
            PortletRequest request, PortletRequestDataBinder binder) <span class="hl-keyword">throws</span> Exception {
        <span class="hl-comment">// to actually be able to convert Multipart instance to byte[]</span>
        <span class="hl-comment">// we have to register a custom editor</span>
        binder.registerCustomEditor(<span class="hl-keyword">byte</span>[].<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> ByteArrayMultipartFileEditor());
        <em class="lineannotation"><span class="lineannotation">// now Spring knows how to handle multipart object and convert</span></em>
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FileUploadBean {

    <span class="hl-keyword">private</span> <span class="hl-keyword">byte</span>[] file;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFile(<span class="hl-keyword">byte</span>[] file) {
        <span class="hl-keyword">this</span>.file = file;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">byte</span>[] getFile() {
        <span class="hl-keyword">return</span> file;
    }
}</pre>

      <p>As you can see, the <code class="classname">FileUploadBean</code> has
      a property of type <code class="literal">byte[]</code> that holds the file. The
      controller registers a custom editor to let Spring know how to
      actually convert the multipart objects the resolver has found to
      properties specified by the bean. In this example, nothing is done
      with the <code class="literal">byte[]</code> property of the bean itself, but
      in practice you can do whatever you want (save it in a database,
      mail it to somebody, etc).</p>

      <p>An equivalent example in which a file is bound straight to a
      String-typed property on a form backing object might look like
      this:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FileUploadController <span class="hl-keyword">extends</span> SimpleFormController {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onSubmitAction(ActionRequest request, ActionResponse response,
            Object command, BindException errors) <span class="hl-keyword">throws</span> Exception {

        <span class="hl-comment">// cast the bean</span>
        FileUploadBean bean = (FileUploadBean) command;

        <span class="hl-comment">// let's see if there's content there</span>
        String file = bean.getFile();
        <span class="hl-keyword">if</span> (file == null) {
            <span class="hl-comment">// hmm, that's strange, the user did not upload anything</span>
        }

        <span class="hl-comment">// do something with the file here</span>
    }

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> initBinder(
        PortletRequest request, PortletRequestDataBinder binder) <span class="hl-keyword">throws</span> Exception {

        <span class="hl-comment">// to actually be able to convert Multipart instance to a String</span>
        <span class="hl-comment">// we have to register a custom editor</span>
        binder.registerCustomEditor(String.<span class="hl-keyword">class</span>,
            <span class="hl-keyword">new</span> StringMultipartFileEditor());
        <span class="hl-comment">// now Spring knows how to handle multipart objects and convert</span>
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FileUploadBean {

    <span class="hl-keyword">private</span> String file;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFile(String file) {
        <span class="hl-keyword">this</span>.file = file;
    }

    <span class="hl-keyword">public</span> String getFile() {
        <span class="hl-keyword">return</span> file;
    }
}</pre>

      <p>Of course, this last example only makes (logical) sense in the
      context of uploading a plain text file (it wouldn't work so well in
      the case of uploading an image file).</p>

      <p>The third (and final) option is where one binds directly to a
      <code class="interfacename">MultipartFile</code> property declared on
      the (form backing) object's class. In this case one does not need to
      register any custom property editor because there is no type
      conversion to be performed.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FileUploadController <span class="hl-keyword">extends</span> SimpleFormController {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onSubmitAction(ActionRequest request, ActionResponse response,
            Object command, BindException errors) <span class="hl-keyword">throws</span> Exception {

        <span class="hl-comment">// cast the bean</span>
        FileUploadBean bean = (FileUploadBean) command;

        <span class="hl-comment">// let's see if there's content there</span>
        MultipartFile file = bean.getFile();
        <span class="hl-keyword">if</span> (file == null) {
            <span class="hl-comment">// hmm, that's strange, the user did not upload anything</span>
        }

        <span class="hl-comment">// do something with the file here</span>
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FileUploadBean {

    <span class="hl-keyword">private</span> MultipartFile file;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFile(MultipartFile file) {
        <span class="hl-keyword">this</span>.file = file;
    }

    <span class="hl-keyword">public</span> MultipartFile getFile() {
        <span class="hl-keyword">return</span> file;
    }
}</pre>
    </div>
  </div>

  <div class="section" title="20.8&nbsp;Handling exceptions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-exceptionresolver"></a>20.8&nbsp;Handling exceptions</h2></div></div></div>
    

    <p>Just like Servlet MVC, Portlet MVC provides
    <code class="interfacename">HandlerExceptionResolver</code>s to ease the
    pain of unexpected exceptions that occur while your request is being
    processed by a handler that matched the request. Portlet MVC also
    provides a portlet-specific, concrete
    <code class="classname">SimpleMappingExceptionResolver</code> that enables you
    to take the class name of any exception that might be thrown and map it
    to a view name.</p>
  </div>

  <div class="section" title="20.9&nbsp;Annotation-based controller configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-annotation"></a>20.9&nbsp;Annotation-based controller configuration</h2></div></div></div>
    

    <p>Spring 2.5 introduced an annotation-based programming model for MVC
    controllers, using annotations such as
    <code class="interfacename">@RequestMapping</code>,
    <code class="interfacename">@RequestParam</code>,
    <code class="interfacename">@ModelAttribute</code>, etc. This annotation
    support is available for both Servlet MVC and Portlet MVC. Controllers
    implemented in this style do not have to extend specific base classes or
    implement specific interfaces. Furthermore, they do not usually have
    direct dependencies on Servlet or Portlet API's, although they can easily
    get access to Servlet or Portlet facilities if desired.</p>

    
    

    <p>The following sections document these annotations and how they are
    most commonly used in a Portlet environment.</p>

    <div class="section" title="20.9.1&nbsp;Setting up the dispatcher for annotation support"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-setup"></a>20.9.1&nbsp;Setting up the dispatcher for annotation support</h3></div></div></div>
      

      <p><span class="emphasis"><em><code class="interfacename">@RequestMapping</code> will only be processed
      if a corresponding <code class="interfacename">HandlerMapping</code> (for type level annotations)
      and/or <code class="interfacename">HandlerAdapter</code> (for method level annotations) is
      present in the dispatcher.</em></span> This is the case by default in both
      <code class="classname">DispatcherServlet</code> and <code class="classname">DispatcherPortlet</code>.</p>

      <p>However, if you are defining custom <code class="interfacename">HandlerMappings</code> or
      <code class="interfacename">HandlerAdapters</code>, then you need to make sure that a
      corresponding custom <code class="classname">DefaultAnnotationHandlerMapping</code>
      and/or <code class="classname">AnnotationMethodHandlerAdapter</code> is defined as well
      - provided that you intend to use <code class="interfacename">@RequestMapping</code>.</p>

      <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.portlet.mvc.annotation.DefaultAnnotationHandlerMapping"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span><span class="hl-tag">/&gt;</span>

    <em class="lineannotation"><span class="lineannotation">// ... (controller bean definitions) ...</span></em>

<span class="hl-tag">&lt;/beans&gt;</span>
</pre>

      <p>Defining a <code class="classname">DefaultAnnotationHandlerMapping</code>
      and/or <code class="classname">AnnotationMethodHandlerAdapter</code> explicitly
      also makes sense if you would like to customize the mapping strategy, e.g.
      specifying a custom <code class="interfacename">WebBindingInitializer</code> (see below).</p>
    </div>

    <div class="section" title="20.9.2&nbsp;Defining a controller with @Controller"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-controller"></a>20.9.2&nbsp;Defining a controller with
      <code class="interfacename">@Controller</code></h3></div></div></div>
      

      <p>The <code class="interfacename">@Controller</code> annotation indicates
      that a particular class serves the role of a <span class="emphasis"><em>controller</em></span>.
      There is no need to extend any controller base class or reference the
      Portlet API. You are of course still able to reference Portlet-specific
      features if you need to.</p>

      <p>The basic purpose of the <code class="interfacename">@Controller</code>
      annotation is to act as a stereotype for the annotated class, indicating
      its role. The dispatcher will scan such annotated classes for mapped
      methods, detecting <code class="interfacename">@RequestMapping</code>
      annotations (see the next section).</p>

      <p>Annotated controller beans may be defined explicitly,
      using a standard Spring bean definition in the dispatcher's context.
      However, the <code class="interfacename">@Controller</code> stereotype also
      allows for autodetection, aligned with Spring 2.5's general support for
      detecting component classes in the classpath and auto-registering bean
      definitions for them.</p>

      <p>To enable autodetection of such annotated controllers, you have to add
      component scanning to your configuration. This is easily achieved by using
      the <span class="emphasis"><em>spring-context</em></span> schema as shown in the following
      XML snippet:</p>

      <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:p</span>=<span class="hl-value">"http://www.springframework.org/schema/p"</span>
    <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;context:component-scan</span> <span class="hl-attribute">base-package</span>=<span class="hl-value">"org.springframework.samples.petportal.portlet"</span><span class="hl-tag">/&gt;</span>

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>

<span class="hl-tag">&lt;/beans&gt;</span>
</pre>
    </div>

    <div class="section" title="20.9.3&nbsp;Mapping requests with @RequestMapping"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-requestmapping"></a>20.9.3&nbsp;Mapping requests with
      <code class="interfacename">@RequestMapping</code></h3></div></div></div>
      

      <p>The <code class="interfacename">@RequestMapping</code> annotation is used
      to map portlet modes like 'VIEW'/'EDIT' onto an entire class or a particular
      handler method. Typically the type-level annotation maps a specific mode
      (or mode plus parameter condition) onto a form controller, with additional
      method-level annotations 'narrowing' the primary mapping for specific
      portlet request parameters.</p>

      <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
        <p><code class="interfacename">@RequestMapping</code> at the type
        level may be used for plain implementations of the
        <code class="interfacename">Controller</code> interface as well.
        In this case, the request processing code would follow the
        traditional <code class="literal">handle(Action|Render)Request</code> signature,
        while the controller's mapping would be expressed through an
        <code class="interfacename">@RequestMapping</code> annotation.
        This works for pre-built <code class="interfacename">Controller</code>
        base classes, such as <code class="classname">SimpleFormController</code>,
        too.</p>

        <p>In the following discussion, we'll focus on controllers
        that are based on annotated handler methods.</p>
      </td></tr></table></div>

      <p>The following is an example of a form controller from the
      PetPortal sample application using this annotation:</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Controller</span></i>
<span class="bold"><strong>@RequestMapping("EDIT")</strong></span>
<i><span class="hl-annotation" style="color: gray">@SessionAttributes("site")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PetSitesEditController {

    <span class="hl-keyword">private</span> Properties petSites;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPetSites(Properties petSites) {
        <span class="hl-keyword">this</span>.petSites = petSites;
    }

    <i><span class="hl-annotation" style="color: gray">@ModelAttribute("petSites")</span></i>
    <span class="hl-keyword">public</span> Properties getPetSites() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.petSites;
    }

    <span class="bold"><strong>@RequestMapping</strong></span>  <span class="hl-comment">// default (action=list)</span>
    <span class="hl-keyword">public</span> String showPetSites() {
        <span class="hl-keyword">return</span> <span class="hl-string">"petSitesEdit"</span>;
    }

    <span class="bold"><strong>@RequestMapping(params = "action=add")</strong></span>  <span class="hl-comment">// render phase</span>
    <span class="hl-keyword">public</span> String showSiteForm(Model model) {
        <span class="hl-comment">// Used for the initial form as well as for redisplaying with errors.</span>
        <span class="hl-keyword">if</span> (!model.containsAttribute(<span class="hl-string">"site"</span>)) {
            model.addAttribute(<span class="hl-string">"site"</span>, <span class="hl-keyword">new</span> PetSite());
        }
        <span class="hl-keyword">return</span> <span class="hl-string">"petSitesAdd"</span>;
    }

    <span class="bold"><strong>@RequestMapping(params = "action=add")</strong></span>  <span class="hl-comment">// action phase</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> populateSite(
            <i><span class="hl-annotation" style="color: gray">@ModelAttribute("site")</span></i> PetSite petSite, BindingResult result,
            SessionStatus status, ActionResponse response) {

        <span class="hl-keyword">new</span> PetSiteValidator().validate(petSite, result);
        <span class="hl-keyword">if</span> (!result.hasErrors()) {
            <span class="hl-keyword">this</span>.petSites.put(petSite.getName(), petSite.getUrl());
            status.setComplete();
            response.setRenderParameter(<span class="hl-string">"action"</span>, <span class="hl-string">"list"</span>);
        }
    }

    <span class="bold"><strong>@RequestMapping(params = "action=delete")</strong></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> removeSite(<i><span class="hl-annotation" style="color: gray">@RequestParam("site")</span></i> String site, ActionResponse response) {
        <span class="hl-keyword">this</span>.petSites.remove(site);
        response.setRenderParameter(<span class="hl-string">"action"</span>, <span class="hl-string">"list"</span>);
    }
}</pre>
    </div>

    <div class="section" title="20.9.4&nbsp;Supported handler method arguments"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-requestmapping-arguments"></a>20.9.4&nbsp;Supported handler method arguments</h3></div></div></div>
      

      <p>Handler methods which are annotated with
      <code class="classname">@RequestMapping</code> are allowed to have very flexible
      signatures. They may have arguments of the following types, in arbitrary
      order (except for validation results, which need to follow right after
      the corresponding command object, if desired):

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>Request and/or response objects (Portlet API).
          You may choose any specific request/response type, e.g. PortletRequest /
          ActionRequest / RenderRequest. An explicitly declared action/render
          argument is also used for mapping specific request types onto a handler
          method (in case of no other information given that differentiates
          between action and render requests).</p>
        </li><li class="listitem">
          <p>Session object (Portlet API): of type PortletSession. An argument
          of this type will enforce the presence of a corresponding session.
          As a consequence, such an argument will never be <code class="literal">null</code>.</p>
        </li><li class="listitem">
          <p><code class="classname">org.springframework.web.context.request.WebRequest</code>
          or <code class="classname">org.springframework.web.context.request.NativeWebRequest</code>.
          Allows for generic request parameter access as well as request/session
          attribute access, without ties to the native Servlet/Portlet API.</p>
        </li><li class="listitem">
          <p><code class="classname">java.util.Locale</code> for the current request
          locale (the portal locale in a Portlet environment).</p>
        </li><li class="listitem">
          <p><code class="classname">java.io.InputStream</code> /
          <code class="classname">java.io.Reader</code> for access to the request's content.
          This will be the raw InputStream/Reader as exposed by the Portlet API.</p>
        </li><li class="listitem">
          <p><code class="classname">java.io.OutputStream</code> /
          <code class="classname">java.io.Writer</code> for generating the response's content.
          This will be the raw OutputStream/Writer as exposed by the Portlet API.</p>
        </li><li class="listitem">
          <p><code class="classname">@RequestParam</code> annotated parameters
          for access to specific Portlet request parameters. Parameter values
          will be converted to the declared method argument type.</p>
        </li><li class="listitem">
          <p><code class="interfacename">java.util.Map</code> /
          <code class="interfacename">org.springframework.ui.Model</code> /
          <code class="classname">org.springframework.ui.ModelMap</code> for
          enriching the implicit model that will be exposed to the web view.</p>
        </li><li class="listitem">
          <p>Command/form objects to bind parameters to: as bean
          properties or fields, with customizable type conversion, depending
          on <code class="classname">@InitBinder</code> methods and/or the
          HandlerAdapter configuration - see the
          "<code class="literal">webBindingInitializer</code>" property on
          <code class="classname">AnnotationMethodHandlerAdapter</code>. Such
          command objects along with their validation results will be
          exposed as model attributes, by default using the non-qualified
          command class name in property notation (e.g. "orderAddress" for
          type "mypackage.OrderAddress"). Specify a parameter-level
          <code class="classname">ModelAttribute</code> annotation for declaring a
          specific model attribute name.</p>
        </li><li class="listitem">
          <p><code class="classname">org.springframework.validation.Errors</code> /
          <code class="classname">org.springframework.validation.BindingResult</code>
          validation results for a preceding command/form object (the
          immediate preceding argument).</p>
        </li><li class="listitem">
          <p><code class="classname">org.springframework.web.bind.support.SessionStatus</code>
          status handle for marking form processing as complete (triggering
          the cleanup of session attributes that have been indicated by the
          <code class="classname">@SessionAttributes</code> annotation at the
          handler type level).</p>
        </li></ul></div>

      <p>The following return types are supported for handler methods:

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>A <code class="classname">ModelAndView</code> object, with the model implicitly
          enriched with command objects and the results of <code class="literal">@ModelAttribute</code>
          annotated reference data accessor methods.</p>
        </li><li class="listitem">
          <p>A <code class="interfacename">Model</code> object, with the view name implicitly
          determined through a <code class="interfacename">RequestToViewNameTranslator</code>
          and the model implicitly enriched with command objects and the results of
          <code class="literal">@ModelAttribute</code> annotated reference data accessor methods.</p>
        </li><li class="listitem">
          <p>A <code class="interfacename">Map</code> object for exposing a model, with the view name
          implicitly determined through a <code class="interfacename">RequestToViewNameTranslator</code>
          and the model implicitly enriched with command objects and the results of
          <code class="literal">@ModelAttribute</code> annotated reference data accessor methods.</p>
        </li><li class="listitem">
          <p>A <code class="interfacename">View</code> object, with the model implicitly
          determined through command objects and <code class="literal">@ModelAttribute</code>
          annotated reference data accessor methods. The handler method may also
          programmatically enrich the model by declaring a <code class="interfacename">Model</code>
          argument (see above).</p>
        </li><li class="listitem">
          <p>A <code class="classname">String</code> value which is interpreted as view name,
          with the model implicitly determined through command objects and
          <code class="literal">@ModelAttribute</code> annotated reference data accessor methods.
          The handler method may also programmatically enrich the model by declaring a
          <code class="interfacename">Model</code> argument (see above).</p>
        </li><li class="listitem">
          <p><code class="literal">void</code> if the method handles the response itself
          (e.g. by writing the response content directly).</p>
        </li><li class="listitem">
          <p>Any other return type will be considered a single model attribute
          to be exposed to the view, using the attribute name specified through
          <code class="literal">@ModelAttribute</code> at the method level (or the default
          attribute name based on the return type's class name otherwise). The model
          will be implicitly enriched with command objects and the results of
          <code class="literal">@ModelAttribute</code> annotated reference data accessor methods.</p>
        </li></ul></div>
    </div>

    <div class="section" title="20.9.5&nbsp;Binding request parameters to method parameters with @RequestParam"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-requestparam"></a>20.9.5&nbsp;Binding request parameters to method parameters with
      <code class="classname">@RequestParam</code></h3></div></div></div>
      

      <p>The <code class="classname">@RequestParam</code> annotation is used to
      bind request parameters to a method parameter in your controller.</p>

      <p>The following code snippet from the PetPortal sample application
      shows the usage:</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Controller</span></i>
<i><span class="hl-annotation" style="color: gray">@RequestMapping("EDIT")</span></i>
<i><span class="hl-annotation" style="color: gray">@SessionAttributes("site")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PetSitesEditController {

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> removeSite(<span class="bold"><strong>@RequestParam("site")</strong></span> String site, ActionResponse response) {
        <span class="hl-keyword">this</span>.petSites.remove(site);
        response.setRenderParameter(<span class="hl-string">"action"</span>, <span class="hl-string">"list"</span>);
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}
</pre>

      <p>Parameters using this annotation are required by default, but you
      can specify that a parameter is optional by setting
      <code class="interfacename">@RequestParam</code>'s
      <code class="literal">required</code> attribute to <code class="literal">false</code> (e.g.,
      <code class="literal">@RequestParam(value="id", required=false)</code>).</p>
    </div>

    <div class="section" title="20.9.6&nbsp;Providing a link to data from the model with @ModelAttribute"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-modelattrib"></a>20.9.6&nbsp;Providing a link to data from the model with
      <code class="classname">@ModelAttribute</code></h3></div></div></div>
      

      <p><code class="classname">@ModelAttribute</code> has two usage scenarios in
      controllers. When placed on a method parameter,
      <code class="classname">@ModelAttribute</code> is used to map a model attribute
      to the specific, annotated method parameter (see the
      <code class="literal">populateSite()</code> method below). This is how the
      controller gets a reference to the object holding the data entered in
      the form. In addition, the parameter can be declared as the specific
      type of the form backing object rather than as a generic
      <code class="classname">java.lang.Object</code>, thus increasing type
      safety.</p>

      <p><code class="classname">@ModelAttribute</code> is also used at the method
      level to provide <span class="emphasis"><em>reference data</em></span> for the model (see
      the <code class="literal">getPetSites()</code> method below). For this usage
      the method signature can contain the same types as documented above for
      the <code class="classname">@RequestMapping</code> annotation.</p>

      <p><span class="emphasis"><em>Note:</em></span> <code class="classname">@ModelAttribute</code>
      annotated methods will be executed <span class="emphasis"><em>before</em></span> the
      chosen <code class="classname">@RequestMapping</code> annotated handler method.
      They effectively pre-populate the implicit model with specific attributes,
      often loaded from a database. Such an attribute can then already be
      accessed through <code class="classname">@ModelAttribute</code> annotated
      handler method parameters in the chosen handler method, potentially
      with binding and validation applied to it.</p>

      <p>The following code snippet shows these two usages of this
      annotation:</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Controller</span></i>
<i><span class="hl-annotation" style="color: gray">@RequestMapping("EDIT")</span></i>
<i><span class="hl-annotation" style="color: gray">@SessionAttributes("site")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PetSitesEditController {

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>

    <span class="bold"><strong>@ModelAttribute("petSites")</strong></span>
    <span class="hl-keyword">public</span> Properties getPetSites() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.petSites;
    }

    <i><span class="hl-annotation" style="color: gray">@RequestMapping(params = "action=add")</span></i>  <span class="hl-comment">// action phase</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> populateSite(
            <span class="bold"><strong>@ModelAttribute("site")</strong></span> PetSite petSite, BindingResult result,
            SessionStatus status, ActionResponse response) {

        <span class="hl-keyword">new</span> PetSiteValidator().validate(petSite, result);
        <span class="hl-keyword">if</span> (!result.hasErrors()) {
            <span class="hl-keyword">this</span>.petSites.put(petSite.getName(), petSite.getUrl());
            status.setComplete();
            response.setRenderParameter(<span class="hl-string">"action"</span>, <span class="hl-string">"list"</span>);
        }
    }
}</pre>
    </div>

    <div class="section" title="20.9.7&nbsp;Specifying attributes to store in a Session with @SessionAttributes"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-sessionattrib"></a>20.9.7&nbsp;Specifying attributes to store in a Session with
      <code class="classname">@SessionAttributes</code></h3></div></div></div>
      

      <p>The type-level <code class="classname">@SessionAttributes</code>
      annotation declares session attributes used by a specific handler.
      This will typically list the names of model attributes or types of
      model attributes which should be
      transparently stored in the session or some conversational storage,
      serving as form-backing beans between subsequent requests.</p>

      <p>The following code snippet shows the usage of this
      annotation:</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Controller</span></i>
<i><span class="hl-annotation" style="color: gray">@RequestMapping("EDIT")</span></i>
<span class="bold"><strong>@SessionAttributes("site")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PetSitesEditController {
  <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}
</pre>
    </div>

    <div class="section" title="20.9.8&nbsp;Customizing WebDataBinder initialization"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-webdatabinder"></a>20.9.8&nbsp;Customizing <code class="classname">WebDataBinder</code>
      initialization</h3></div></div></div>
      

      <p>To customize request parameter binding with PropertyEditors, etc.
      via Spring's <code class="classname">WebDataBinder</code>, you can either use
      <code class="interfacename">@InitBinder</code>-annotated methods within your
      controller or externalize your configuration by providing a custom
      <code class="interfacename">WebBindingInitializer</code>.</p>

      <div class="section" title="Customizing data binding with @InitBinder"><div class="titlepage"><div><div><h4 class="title"><a name="portlet-ann-initbinder"></a>Customizing data binding with
        <code class="interfacename">@InitBinder</code></h4></div></div></div>
        

        <p>Annotating controller methods with
        <code class="interfacename">@InitBinder</code> allows you to configure web
        data binding directly within your controller class.
        <code class="interfacename">@InitBinder</code> identifies methods which
        initialize the <code class="classname">WebDataBinder</code> which will be used
        for populating command and form object arguments of annotated handler
        methods.</p>

        <p>Such init-binder methods support all arguments that
        <code class="interfacename">@RequestMapping</code> supports, except for
        command/form objects and corresponding validation result objects.
        Init-binder methods must not have a return value. Thus, they are
        usually declared as <code class="literal">void</code>. Typical arguments include
        <code class="classname">WebDataBinder</code> in combination with
        <code class="interfacename">WebRequest</code> or
        <code class="classname">java.util.Locale</code>, allowing code to register
        context-specific editors.</p>

        <p>The following example demonstrates the use of
        <code class="interfacename">@InitBinder</code> for configuring a
        <code class="classname">CustomDateEditor</code> for all
        <code class="classname">java.util.Date</code> form properties.</p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Controller</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyFormController {

    <span class="bold"><strong>@InitBinder</strong></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = <span class="hl-keyword">new</span> SimpleDateFormat(<span class="hl-string">"yyyy-MM-dd"</span>);
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> CustomDateEditor(dateFormat, false));
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
      </div>

      <div class="section" title="Configuring a custom WebBindingInitializer"><div class="titlepage"><div><div><h4 class="title"><a name="portlet-ann-webbindinginitializer"></a>Configuring a custom
        <code class="interfacename">WebBindingInitializer</code></h4></div></div></div>
        

        <p>To externalize data binding initialization, you can provide a
        custom implementation of the
        <code class="interfacename">WebBindingInitializer</code> interface, which
        you then enable by supplying a custom bean configuration for an
        <code class="classname">AnnotationMethodHandlerAdapter</code>, thus overriding
        the default configuration.</p>
      </div>
    </div>
  </div>

  <div class="section" title="20.10&nbsp;Portlet application deployment"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-deployment"></a>20.10&nbsp;Portlet application deployment</h2></div></div></div>
    

    <p>The process of deploying a Spring Portlet MVC application is no
    different than deploying any JSR-168 Portlet application. However, this
    area is confusing enough in general that it is worth talking about here
    briefly.</p>

    <p>Generally, the portal/portlet container runs in one webapp in your
    servlet container and your portlets run in another webapp in your
    servlet container. In order for the portlet container webapp to make
    calls into your portlet webapp it must make cross-context calls to a
    well-known servlet that provides access to the portlet services defined
    in your <code class="literal">portlet.xml</code> file.</p>

    <p>The JSR-168 specification does not specify exactly how this should
    happen, so each portlet container has its own mechanism for this, which
    usually involves some kind of &#8220;deployment process&#8221; that makes changes to
    the portlet webapp itself and then registers the portlets within the
    portlet container.</p>

    <p>At a minimum, the <code class="literal">web.xml</code> file in your portlet
    webapp is modified to inject the well-known servlet that the portlet
    container will call. In some cases a single servlet will service all
    portlets in the webapp, in other cases there will be an instance of the
    servlet for each portlet.</p>

    <p>Some portlet containers will also inject libraries and/or
    configuration files into the webapp as well. The portlet container must
    also make its implementation of the Portlet JSP Tag Library available to
    your webapp.</p>

    <p>The bottom line is that it is important to understand the
    deployment needs of your target portal and make sure they are met
    (usually by following the automated deployment process it provides).
    Be sure to carefully review the documentation from your portal for this
    process.</p>

    <p>Once you have deployed your portlet, review the resulting
    <code class="literal">web.xml</code> file for sanity. Some older portals have
    been known to corrupt the definition of the
    <code class="classname">ViewRendererServlet</code>, thus breaking the rendering
    of your portlets.</p>
  </div>

</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="web-integration.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-web.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="spring-integration.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">19.&nbsp;Integrating with other web frameworks&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;VI.&nbsp;Integration</td></tr></table></div></body></html>