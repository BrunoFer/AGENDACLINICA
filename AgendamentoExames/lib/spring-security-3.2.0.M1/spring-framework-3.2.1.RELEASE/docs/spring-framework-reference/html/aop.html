<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>9.&nbsp;Aspect Oriented Programming with Spring</title><link rel="stylesheet" href="css/manual-multipage.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-core.html" title="Part&nbsp;III.&nbsp;Core Technologies"><link rel="prev" href="expressions.html" title="8.&nbsp;Spring Expression Language (SpEL)"><link rel="next" href="aop-api.html" title="10.&nbsp;Spring AOP APIs"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">9.&nbsp;Aspect Oriented Programming with Spring</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="expressions.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;III.&nbsp;Core Technologies</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="aop-api.html">Next</a></td></tr></table><hr></div><div class="chapter" title="9.&nbsp;Aspect Oriented Programming with Spring"><div class="titlepage"><div><div><h2 class="title"><a name="aop"></a>9.&nbsp;Aspect Oriented Programming with Spring</h2></div></div></div>
  

  <div class="section" title="9.1&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-introduction"></a>9.1&nbsp;Introduction</h2></div></div></div>
    

    <p><span class="emphasis"><em>Aspect-Oriented Programming</em></span> (AOP) complements
    Object-Oriented Programming (OOP) by providing another way of thinking
    about program structure. The key unit of modularity in OOP is the class,
    whereas in AOP the unit of modularity is the <span class="emphasis"><em>aspect</em></span>.
    Aspects enable the modularization of concerns such as transaction
    management that cut across multiple types and objects. (Such concerns are
    often termed <span class="emphasis"><em>crosscutting</em></span> concerns in AOP
    literature.)</p>

    <p>One of the key components of Spring is the <span class="emphasis"><em>AOP
    framework</em></span>. While the Spring IoC container does not depend on
    AOP, meaning you do not need to use AOP if you don't want to, AOP
    complements Spring IoC to provide a very capable middleware
    solution.</p>

    <div class="sidebar" title="Spring 2.0 AOP"><p class="title"><b>Spring 2.0 AOP</b></p>
      

      <p>Spring 2.0 introduces a simpler and more powerful way of writing
      custom aspects using either a <a class="link" href="aop.html#aop-schema" title="9.3&nbsp;Schema-based AOP support">schema-based
      approach</a> or the <a class="link" href="aop.html#aop-ataspectj" title="9.2&nbsp;@AspectJ support">@AspectJ annotation
      style</a>. Both of these styles offer fully typed advice and use of
      the AspectJ pointcut language, while still using Spring AOP for
      weaving.</p>

      <p>The Spring 2.0 schema- and @AspectJ-based AOP support is discussed
      in this chapter. Spring 2.0 AOP remains fully backwards compatible with
      Spring 1.2 AOP, and the lower-level AOP support offered by the Spring
      1.2 APIs is discussed in <a class="link" href="aop-api.html" title="10.&nbsp;Spring AOP APIs">the following
      chapter</a>.</p>
    </div>

    <p>AOP is used in the Spring Framework to...</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p>... provide declarative enterprise services, especially as a
        replacement for EJB declarative services. The most important such
        service is <a class="link" href="transaction.html#transaction-declarative" title="12.5&nbsp;Declarative transaction management"><span class="emphasis"><em>declarative transaction
        management</em></span></a>.</p>
      </li><li class="listitem">
        <p>... allow users to implement custom aspects, complementing their
        use of OOP with AOP.</p>
      </li></ul></div>

    <p class="remark"><i><span class="remark">If you are interested only in generic declarative services
    or other pre-packaged declarative middleware services such as pooling, you
    do not need to work directly with Spring AOP, and can skip most of this
    chapter.</span></i></p>

    <div class="section" title="9.1.1&nbsp;AOP concepts"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-defn"></a>9.1.1&nbsp;AOP concepts</h3></div></div></div>
      

      <p>Let us begin by defining some central AOP concepts and
      terminology. These terms are not Spring-specific... unfortunately, AOP
      terminology is not particularly intuitive; however, it would be even
      more confusing if Spring used its own terminology.</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><span class="emphasis"><em>Aspect</em></span>: a modularization of a concern
          that cuts across multiple classes. Transaction management is a good
          example of a crosscutting concern in enterprise Java applications.
          In Spring AOP, aspects are implemented using regular classes (the
          <a class="link" href="aop.html#aop-schema" title="9.3&nbsp;Schema-based AOP support">schema-based approach</a>) or regular
          classes annotated with the <code class="interfacename">@Aspect</code>
          annotation (the <a class="link" href="aop.html#aop-ataspectj" title="9.2&nbsp;@AspectJ support"><code class="interfacename">@AspectJ</code>
          style</a>).</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>Join point</em></span>: a point during the execution
          of a program, such as the execution of a method or the handling of
          an exception. In Spring AOP, a join point
          <span class="emphasis"><em>always</em></span> represents a method execution.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>Advice</em></span>: action taken by an aspect at a
          particular join point. Different types of advice include "around,"
          "before" and "after" advice. (Advice types are discussed below.)
          Many AOP frameworks, including Spring, model an advice as an
          <span class="emphasis"><em>interceptor</em></span>, maintaining a chain of
          interceptors <span class="emphasis"><em>around</em></span> the join point.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>Pointcut</em></span>: a predicate that matches join
          points. Advice is associated with a pointcut expression and runs at
          any join point matched by the pointcut (for example, the execution
          of a method with a certain name). The concept of join points as
          matched by pointcut expressions is central to AOP, and Spring uses
          the AspectJ pointcut expression language by default.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>Introduction</em></span>: declaring additional
          methods or fields on behalf of a type. Spring AOP allows you to
          introduce new interfaces (and a corresponding implementation) to any
          advised object. For example, you could use an introduction to make a
          bean implement an <code class="interfacename">IsModified</code>
          interface, to simplify caching. (An introduction is known as an
          inter-type declaration in the AspectJ community.)</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>Target object</em></span>: object being advised by
          one or more aspects. Also referred to as the
          <span class="emphasis"><em>advised</em></span> object. Since Spring AOP is implemented
          using runtime proxies, this object will always be a
          <span class="emphasis"><em>proxied</em></span> object.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>AOP proxy</em></span>: an object created by the AOP
          framework in order to implement the aspect contracts (advise method
          executions and so on). In the Spring Framework, an AOP proxy will be
          a JDK dynamic proxy or a CGLIB proxy.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>Weaving</em></span>: linking aspects with other
          application types or objects to create an advised object. This can
          be done at compile time (using the AspectJ compiler, for example),
          load time, or at runtime. Spring AOP, like other pure Java AOP
          frameworks, performs weaving at runtime.</p>
        </li></ul></div>

      <p>Types of advice:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><span class="emphasis"><em>Before advice</em></span>: Advice that executes
          before a join point, but which does not have the ability to prevent
          execution flow proceeding to the join point (unless it throws an
          exception).</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>After returning advice</em></span>: Advice to be
          executed after a join point completes normally: for example, if a
          method returns without throwing an exception.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>After throwing advice</em></span>: Advice to be
          executed if a method exits by throwing an exception.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>After (finally) advice</em></span>: Advice to be
          executed regardless of the means by which a join point exits (normal
          or exceptional return).</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>Around advice</em></span>: Advice that surrounds a
          join point such as a method invocation. This is the most powerful
          kind of advice. Around advice can perform custom behavior before and
          after the method invocation. It is also responsible for choosing
          whether to proceed to the join point or to shortcut the advised
          method execution by returning its own return value or throwing an
          exception.</p>
        </li></ul></div>

      <p>Around advice is the most general kind of advice. Since Spring
      AOP, like AspectJ, provides a full range of advice types, we recommend
      that you use the least powerful advice type that can implement the
      required behavior. For example, if you need only to update a cache with
      the return value of a method, you are better off implementing an after
      returning advice than an around advice, although an around advice can
      accomplish the same thing. Using the most specific advice type provides
      a simpler programming model with less potential for errors. For example,
      you do not need to invoke the <code class="methodname">proceed()</code> method
      on the <code class="interfacename">JoinPoint</code> used for around advice,
      and hence cannot fail to invoke it.</p>

      <p>In Spring 2.0, all advice parameters are statically typed, so that
      you work with advice parameters of the appropriate type (the type of the
      return value from a method execution for example) rather than
      <code class="classname">Object</code> arrays.</p>

      <p>The concept of join points, matched by pointcuts, is the key to
      AOP which distinguishes it from older technologies offering only
      interception. Pointcuts enable advice to be targeted independently of
      the Object-Oriented hierarchy. For example, an around advice providing
      declarative transaction management can be applied to a set of methods
      spanning multiple objects (such as all business operations in the
      service layer).</p>
    </div>

    <div class="section" title="9.1.2&nbsp;Spring AOP capabilities and goals"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-spring-defn"></a>9.1.2&nbsp;Spring AOP capabilities and goals</h3></div></div></div>
      

      <p>Spring AOP is implemented in pure Java. There is no need for a
      special compilation process. Spring AOP does not need to control the
      class loader hierarchy, and is thus suitable for use in a Servlet
      container or application server.</p>

      <p>Spring AOP currently supports only method execution join points
      (advising the execution of methods on Spring beans). Field interception
      is not implemented, although support for field interception could be
      added without breaking the core Spring AOP APIs. If you need to advise
      field access and update join points, consider a language such as
      AspectJ.</p>

      <p>Spring AOP's approach to AOP differs from that of most other AOP
      frameworks. The aim is not to provide the most complete AOP
      implementation (although Spring AOP is quite capable); it is rather to
      provide a close integration between AOP implementation and Spring IoC to
      help solve common problems in enterprise applications.</p>

      <p>Thus, for example, the Spring Framework's AOP functionality is
      normally used in conjunction with the Spring IoC container. Aspects are
      configured using normal bean definition syntax (although this allows
      powerful "autoproxying" capabilities): this is a crucial difference from
      other AOP implementations. There are some things you cannot do easily or
      efficiently with Spring AOP, such as advise very fine-grained objects
      (such as domain objects typically): AspectJ is the best choice in such
      cases. However, our experience is that Spring AOP provides an excellent
      solution to most problems in enterprise Java applications that are
      amenable to AOP.</p>

      <p>Spring AOP will never strive to compete with AspectJ to provide a
      comprehensive AOP solution. We believe that both proxy-based frameworks
      like Spring AOP and full-blown frameworks such as AspectJ are valuable,
      and that they are complementary, rather than in competition. Spring 2.0
      seamlessly integrates Spring AOP and IoC with AspectJ, to enable all
      uses of AOP to be catered for within a consistent Spring-based
      application architecture. This integration does not affect the Spring
      AOP API or the AOP Alliance API: Spring AOP remains backward-compatible.
      See <a class="link" href="aop-api.html" title="10.&nbsp;Spring AOP APIs">the following chapter</a> for a
      discussion of the Spring AOP APIs.</p>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>One of the central tenets of the Spring Framework is that of
        <span class="emphasis"><em>non-invasiveness</em></span>; this is the idea that you
        should not be forced to introduce framework-specific classes and
        interfaces into your business/domain model. However, in some places
        the Spring Framework does give you the option to introduce Spring
        Framework-specific dependencies into your codebase: the rationale in
        giving you such options is because in certain scenarios it might be
        just plain easier to read or code some specific piece of functionality
        in such a way. The Spring Framework (almost) always offers you the
        choice though: you have the freedom to make an informed decision as to
        which option best suits your particular use case or scenario.</p>

        <p>One such choice that is relevant to this chapter is that of
        which AOP framework (and which AOP style) to choose. You have the
        choice of AspectJ and/or Spring AOP, and you also have the choice of
        either the @AspectJ annotation-style approach or the Spring XML
        configuration-style approach. The fact that this chapter chooses to
        introduce the @AspectJ-style approach first should not be taken as an
        indication that the Spring team favors the @AspectJ annotation-style
        approach over the Spring XML configuration-style.</p>

        <p>See <a class="xref" href="aop.html#aop-choosing" title="9.4&nbsp;Choosing which AOP declaration style to use">Section&nbsp;9.4, &#8220;Choosing which AOP declaration style to use&#8221;</a> for a
        more complete discussion of the whys and wherefores of each style.</p>
      </td></tr></table></div>
    </div>

    <div class="section" title="9.1.3&nbsp;AOP Proxies"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-proxies"></a>9.1.3&nbsp;AOP Proxies</h3></div></div></div>
      

      <p>Spring AOP defaults to using standard J2SE <span class="emphasis"><em>dynamic
      proxies</em></span> for AOP proxies. This enables any interface (or set
      of interfaces) to be proxied.</p>

      <p>Spring AOP can also use CGLIB proxies. This is necessary to proxy
      classes, rather than interfaces. CGLIB is used by default if a business
      object does not implement an interface. As it is good practice to
      program to interfaces rather than classes, business classes normally
      will implement one or more business interfaces. It is possible to <a class="link" href="aop.html#aop-autoproxy-force-CGLIB">force the use of CGLIB</a>, in
      those (hopefully rare) cases where you need to advise a method that is
      not declared on an interface, or where you need to pass a proxied object
      to a method as a concrete type.</p>

      <p>It is important to grasp the fact that Spring AOP is
      <span class="emphasis"><em>proxy-based</em></span>. See <a class="xref" href="aop.html#aop-understanding-aop-proxies" title="9.6.1&nbsp;Understanding AOP proxies">Section&nbsp;9.6.1, &#8220;Understanding AOP proxies&#8221;</a> for a thorough examination of
      exactly what this implementation detail actually means.</p>
    </div>
  </div>

  <div class="section" title="9.2&nbsp;@AspectJ support"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-ataspectj"></a>9.2&nbsp;@AspectJ support</h2></div></div></div>
    

    <p>@AspectJ refers to a style of declaring aspects as regular Java
    classes annotated with Java 5 annotations. The @AspectJ style was
    introduced by the <a class="ulink" href="http://www.eclipse.org/aspectj" target="_top">AspectJ
    project</a> as part of the AspectJ 5 release. Spring 2.0 interprets
    the same annotations as AspectJ 5, using a library supplied by AspectJ for
    pointcut parsing and matching. The AOP runtime is still pure Spring AOP
    though, and there is no dependency on the AspectJ compiler or
    weaver.</p>

    <p class="remark"><i><span class="remark">Using the AspectJ compiler and weaver enables use of the
    full AspectJ language, and is discussed in <a class="xref" href="aop.html#aop-using-aspectj" title="9.8&nbsp;Using AspectJ with Spring applications">Section&nbsp;9.8, &#8220;Using AspectJ with Spring applications&#8221;</a>.</span></i></p>

    <div class="section" title="9.2.1&nbsp;Enabling @AspectJ Support"><div class="titlepage"><div><div><h3 class="title"><a name="aop-aspectj-support"></a>9.2.1&nbsp;Enabling @AspectJ Support</h3></div></div></div>
      

      <p>To use @AspectJ aspects in a Spring configuration you need to
      enable Spring support for configuring Spring AOP based on @AspectJ
      aspects, and <span class="emphasis"><em>autoproxying</em></span> beans based on whether or
      not they are advised by those aspects. By autoproxying we mean that if
      Spring determines that a bean is advised by one or more aspects, it will
      automatically generate a proxy for that bean to intercept method
      invocations and ensure that advice is executed as needed.</p>

      <p>The @AspectJ support can be enabled with XML or Java style
      configuration.  In either case you will also need to ensure that
      AspectJ's <code class="filename">aspectjweaver.jar</code>
      library is on the classpath of your application (version 1.6.8 or later).
      This library is available in the <code class="filename">'lib'</code>
      directory of an AspectJ distribution or via the Maven Central repository.</p>

      <div class="section" title="Enabling @AspectJ Support with Java configuration"><div class="titlepage"><div><div><h4 class="title"><a name="aop-enable-aspectj-java"></a>Enabling @AspectJ Support with Java configuration</h4></div></div></div>
        

        <p>To enable @AspectJ support with Java
        <code class="interfacename">@Configuration</code> add the
        <code class="interfacename">@EnableAspectJAutoProxy</code> annotation:</p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Configuration</span></i>
<i><span class="hl-annotation" style="color: gray">@EnableAspectJAutoProxy</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

}</pre>
      </div>

      <div class="section" title="Enabling @AspectJ Support with XML configuration"><div class="titlepage"><div><div><h4 class="title"><a name="aop-enable-aspectj-xml"></a>Enabling @AspectJ Support with XML configuration</h4></div></div></div>
        

        <p>To enable @AspectJ support with XML based configuration use the
        <code class="literal">aop:aspectj-autoproxy</code> element:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:aspectj-autoproxy/&gt;</span></pre>

        <p>This assumes that you are using schema support as described in
        <a class="xref" href="xsd-config.html" title="Appendix&nbsp;E.&nbsp;XML Schema-based configuration">Appendix&nbsp;E, <i>XML Schema-based configuration</i></a>. See <a class="xref" href="xsd-config.html#xsd-config-body-schemas-aop" title="E.2.7&nbsp;The aop schema">Section&nbsp;E.2.7, &#8220;The <code class="literal">aop</code> schema&#8221;</a> for how to import the tags in
        the aop namespace.</p>

        <p>If you are using the DTD, it is still possible to enable @AspectJ
        support by adding the following definition to your application
        context:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"</span><span class="hl-tag"> /&gt;</span></pre>
      </div>
    </div>

    <div class="section" title="9.2.2&nbsp;Declaring an aspect"><div class="titlepage"><div><div><h3 class="title"><a name="aop-at-aspectj"></a>9.2.2&nbsp;Declaring an aspect</h3></div></div></div>
      

      <p>With the @AspectJ support enabled, any bean defined in your
      application context with a class that is an @AspectJ aspect (has the
      <code class="interfacename">@Aspect</code> annotation) will be automatically
      detected by Spring and used to configure Spring AOP. The following
      example shows the minimal definition required for a not-very-useful
      aspect:</p>

      <p>A regular bean definition in the application context, pointing to
      a bean class that has the <code class="interfacename">@Aspect</code>
      annotation:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.xyz.NotVeryUsefulAspect"</span><span class="hl-tag">&gt;</span>
   <em class="lineannotation"><span class="lineannotation">&lt;!-- configure properties of aspect here as normal --&gt;</span></em>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre>

      <p>And the <code class="classname">NotVeryUsefulAspect</code> class
      definition, annotated with
      <code class="interfacename">org.aspectj.lang.annotation.Aspect</code>
      annotation;</p>

      <pre class="programlisting"><span class="hl-keyword">package</span> org.xyz;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> NotVeryUsefulAspect {

}</pre>

      <p>Aspects (classes annotated with
      <code class="interfacename">@Aspect</code>) may have methods and fields just
      like any other class. They may also contain pointcut, advice, and
      introduction (inter-type) declarations.</p>

      <div class="note" title="Autodetecting aspects through component scanning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Autodetecting aspects through component scanning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Autodetecting aspects through component scanning</th></tr><tr><td align="left" valign="top">
        

        <p>You may register aspect classes as regular beans in your Spring
        XML configuration, or autodetect them through classpath scanning -
        just like any other Spring-managed bean. However, note that the
        <span class="emphasis"><em>@Aspect</em></span> annotation is <span class="emphasis"><em>not</em></span>
        sufficient for autodetection in the classpath: For that purpose,
        you need to add a separate <span class="emphasis"><em>@Component</em></span> annotation
        (or alternatively a custom stereotype annotation that qualifies,
        as per the rules of Spring's component scanner).</p>
      </td></tr></table></div>

      <div class="note" title="Advising aspects with other aspects?" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Advising aspects with other aspects?"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Advising aspects with other aspects?</th></tr><tr><td align="left" valign="top">
        

        <p>In Spring AOP, it is <span class="emphasis"><em>not</em></span> possible to have
        aspects themselves be the target of advice from other aspects. The
        <span class="emphasis"><em>@Aspect</em></span> annotation on a class marks it as an
        aspect, and hence excludes it from auto-proxying.</p>
      </td></tr></table></div>
    </div>

    <div class="section" title="9.2.3&nbsp;Declaring a pointcut"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pointcuts"></a>9.2.3&nbsp;Declaring a pointcut</h3></div></div></div>
      

      <p>Recall that pointcuts determine join points of interest, and thus
      enable us to control when advice executes. <span class="emphasis"><em>Spring AOP only
      supports method execution join points for Spring beans</em></span>, so
      you can think of a pointcut as matching the execution of methods on
      Spring beans. A pointcut declaration has two parts: a signature
      comprising a name and any parameters, and a pointcut expression that
      determines <span class="emphasis"><em>exactly</em></span> which method executions we are
      interested in. In the @AspectJ annotation-style of AOP, a pointcut
      signature is provided by a regular method definition, and the pointcut
      expression is indicated using the
      <code class="interfacename">@Pointcut</code> annotation (the method serving
      as the pointcut signature <span class="emphasis"><em>must</em></span> have a
      <code class="literal">void</code> return type).</p>

      <p>An example will help make this distinction between a pointcut
      signature and a pointcut expression clear. The following example defines
      a pointcut named <code class="literal">'anyOldTransfer'</code> that will match the
      execution of any method named <code class="literal">'transfer'</code>:</p>

      <pre class="programlisting">@Pointcut(<span class="hl-string">"execution(* transfer(..))"</span>)<em class="lineannotation"><span class="lineannotation">// the pointcut expression</span></em>
<span class="hl-keyword">private</span> <span class="hl-keyword">void</span> anyOldTransfer() {}<em class="lineannotation"><span class="lineannotation">// the pointcut signature</span></em></pre>

      <p>The pointcut expression that forms the value of the
      <code class="interfacename">@Pointcut</code> annotation is a regular AspectJ
      5 pointcut expression. For a full discussion of AspectJ's pointcut
      language, see the <a class="ulink" href="http://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_top">AspectJ
      Programming Guide</a> (and for Java 5 based extensions, the <a class="ulink" href="http://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html" target="_top">AspectJ
      5 Developers Notebook</a>) or one of the books on AspectJ such as
      <span class="quote">&#8220;<span class="quote">Eclipse AspectJ</span>&#8221;</span> by Colyer et. al. or <span class="quote">&#8220;<span class="quote">AspectJ in
      Action</span>&#8221;</span> by Ramnivas Laddad.</p>

      <div class="section" title="Supported Pointcut Designators"><div class="titlepage"><div><div><h4 class="title"><a name="aop-pointcuts-designators"></a>Supported Pointcut Designators</h4></div></div></div>
        

        <p>Spring AOP supports the following AspectJ pointcut designators
        (PCD) for use in pointcut expressions:</p>

        <div class="sidebar" title="Other pointcut types"><p class="title"><b>Other pointcut types</b></p>
          

          <p>The full AspectJ pointcut language supports additional
          pointcut designators that are not supported in Spring. These are:
          <code class="literal">call, get, set, preinitialization, staticinitialization,
          initialization, handler, adviceexecution, withincode, cflow,
          cflowbelow, if, @this</code>, and <code class="literal">@withincode</code>.
          Use of these pointcut designators in pointcut expressions
          interpreted by Spring AOP will result in an
          <code class="classname">IllegalArgumentException</code> being thrown.</p>

          <p>The set of pointcut designators supported by Spring AOP may be
          extended in future releases to support more of the AspectJ pointcut
          designators.</p>
        </div>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p><span class="emphasis"><em>execution</em></span> - for matching method
            execution join points, this is the primary pointcut designator you
            will use when working with Spring AOP</p>
          </li><li class="listitem">
            <p><span class="emphasis"><em>within</em></span> - limits matching to join points
            within certain types (simply the execution of a method declared
            within a matching type when using Spring AOP)</p>
          </li><li class="listitem">
            <p><span class="emphasis"><em>this</em></span> - limits matching to join points
            (the execution of methods when using Spring AOP) where the bean
            reference (Spring AOP proxy) is an instance of the given
            type</p>
          </li><li class="listitem">
            <p><span class="emphasis"><em>target</em></span> - limits matching to join points
            (the execution of methods when using Spring AOP) where the target
            object (application object being proxied) is an instance of the
            given type</p>
          </li><li class="listitem">
            <p><span class="emphasis"><em>args</em></span> - limits matching to join points
            (the execution of methods when using Spring AOP) where the
            arguments are instances of the given types</p>
          </li><li class="listitem">
            <p><span class="emphasis"><em><code class="interfacename">@target</code></em></span>
            - limits matching to join points (the execution of methods when
            using Spring AOP) where the class of the executing object has an
            annotation of the given type</p>
          </li><li class="listitem">
            <p><span class="emphasis"><em><code class="interfacename">@args</code></em></span> -
            limits matching to join points (the execution of methods when
            using Spring AOP) where the runtime type of the actual arguments
            passed have annotations of the given type(s)</p>
          </li><li class="listitem">
            <p><span class="emphasis"><em><code class="interfacename">@within</code></em></span>
            - limits matching to join points within types that have the given
            annotation (the execution of methods declared in types with the
            given annotation when using Spring AOP)</p>
          </li><li class="listitem">
            <p><span class="emphasis"><em>@annotation</em></span> - limits matching to join
            points where the subject of the join point (method being executed
            in Spring AOP) has the given annotation</p>
          </li></ul></div>

        <p>Because Spring AOP limits matching to only method execution
        join points, the discussion of the pointcut designators above gives a
        narrower definition than you will find in the AspectJ programming
        guide. In addition, AspectJ itself has type-based semantics and at an
        execution join point both '<code class="literal">this</code>' and
        '<code class="literal">target</code>' refer to the same object - the object
        executing the method. Spring AOP is a proxy-based system and
        differentiates between the proxy object itself (bound to
        '<code class="literal">this</code>') and the target object behind the proxy
        (bound to '<code class="literal">target</code>').</p>

        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p>Due to the proxy-based nature of Spring's AOP framework,
          protected methods are by definition <span class="emphasis"><em>not</em></span>
          intercepted, neither for JDK proxies (where this isn't applicable)
          nor for CGLIB proxies (where this is technically possible but not
          recommendable for AOP purposes). As a consequence, any given pointcut
          will be matched against <span class="emphasis"><em>public methods only</em></span>!</p>

          <p>If your interception needs include protected/private methods
          or even constructors, consider the use of Spring-driven
          <a class="link" href="aop.html#aop-aj-ltw" title="9.8.4&nbsp;Load-time weaving with AspectJ in the Spring Framework">native AspectJ weaving</a> instead
          of Spring's proxy-based AOP framework. This constitutes a different
          mode of AOP usage with different characteristics, so be sure to make
          yourself familiar with weaving first before making a decision.</p>
        </td></tr></table></div>

        <p>Spring AOP also supports an additional PCD named
        '<code class="literal">bean</code>'. This PCD allows you to limit the matching
        of join points to a particular named Spring bean, or to a set of named
        Spring beans (when using wildcards). The '<code class="literal">bean</code>' PCD
        has the following form:</p>

        <pre class="programlisting">bean(idOrNameOfBean)</pre>

        <p>The '<code class="literal">idOrNameOfBean</code>' token can be the name of
        any Spring bean: limited wildcard support using the
        '<code class="literal">*</code>' character is provided, so if you establish
        some naming conventions for your Spring beans you can quite easily
        write a '<code class="literal">bean</code>' PCD expression to pick them out. As
        is the case with other pointcut designators, the
        '<code class="literal">bean</code>' PCD can be &amp;&amp;'ed, ||'ed, and !
        (negated) too.</p>

        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p>Please note that the '<code class="literal">bean</code>' PCD is
          <span class="emphasis"><em>only</em></span> supported in Spring AOP - and
          <span class="emphasis"><em>not</em></span> in native AspectJ weaving. It is a
          Spring-specific extension to the standard PCDs that AspectJ
          defines.</p>

          <p>The '<code class="literal">bean</code>' PCD operates at the
          <span class="emphasis"><em>instance</em></span> level (building on the Spring
          bean name concept) rather than at the type level only
          (which is what weaving-based AOP is limited to).
          Instance-based pointcut designators are a special capability
          of Spring's proxy-based AOP framework and its close integration
          with the Spring bean factory, where it is natural and
          straightforward to identify specific beans by name.</p>
        </td></tr></table></div>
      </div>

      <div class="section" title="Combining pointcut expressions"><div class="titlepage"><div><div><h4 class="title"><a name="aop-pointcuts-combining"></a>Combining pointcut expressions</h4></div></div></div>
        

        <p>Pointcut expressions can be combined using '&amp;&amp;', '||'
        and '!'. It is also possible to refer to pointcut expressions by name.
        The following example shows three pointcut expressions:
        <code class="literal">anyPublicOperation</code> (which matches if a method
        execution join point represents the execution of any public method);
        <code class="literal">inTrading</code> (which matches if a method execution is
        in the trading module), and <code class="literal">tradingOperation</code> (which
        matches if a method execution represents any public method in the
        trading module).</p>

        <pre class="programlisting">    <i><span class="hl-annotation" style="color: gray">@Pointcut("execution(public * *(..))")</span></i>
    <span class="hl-keyword">private</span> <span class="hl-keyword">void</span> anyPublicOperation() {}

    <i><span class="hl-annotation" style="color: gray">@Pointcut("within(com.xyz.someapp.trading..*)")</span></i>
    <span class="hl-keyword">private</span> <span class="hl-keyword">void</span> inTrading() {}

    <i><span class="hl-annotation" style="color: gray">@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")</span></i>
    <span class="hl-keyword">private</span> <span class="hl-keyword">void</span> tradingOperation() {}</pre>

        <p>It is a best practice to build more complex pointcut expressions
        out of smaller named components as shown above. When referring to
        pointcuts by name, normal Java visibility rules apply (you can see
        private pointcuts in the same type, protected pointcuts in the
        hierarchy, public pointcuts anywhere and so on). Visibility does not
        affect pointcut <span class="emphasis"><em>matching</em></span>.</p>
      </div>

      <div class="section" title="Sharing common pointcut definitions"><div class="titlepage"><div><div><h4 class="title"><a name="aop-common-pointcuts"></a>Sharing common pointcut definitions</h4></div></div></div>
        

        <p>When working with enterprise applications, you often want to
        refer to modules of the application and particular sets of operations
        from within several aspects. We recommend defining a
        "SystemArchitecture" aspect that captures common pointcut expressions
        for this purpose. A typical such aspect would look as follows:</p>

        <pre class="programlisting"><span class="hl-keyword">package</span> com.xyz.someapp;

<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Pointcut;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SystemArchitecture {

  <em class="lineannotation"><span class="lineannotation">/**
   * A join point is in the web layer if the method is defined
   * in a type in the com.xyz.someapp.web package or any sub-package
   * under that.
   */</span></em>
  <i><span class="hl-annotation" style="color: gray">@Pointcut("within(com.xyz.someapp.web..*)")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> inWebLayer() {}

  <em class="lineannotation"><span class="lineannotation">/**
   * A join point is in the service layer if the method is defined
   * in a type in the com.xyz.someapp.service package or any sub-package
   * under that.
   */</span></em>
  <i><span class="hl-annotation" style="color: gray">@Pointcut("within(com.xyz.someapp.service..*)")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> inServiceLayer() {}

  <em class="lineannotation"><span class="lineannotation">/**
   * A join point is in the data access layer if the method is defined
   * in a type in the com.xyz.someapp.dao package or any sub-package
   * under that.
   */</span></em>
  <i><span class="hl-annotation" style="color: gray">@Pointcut("within(com.xyz.someapp.dao..*)")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> inDataAccessLayer() {}

  <em class="lineannotation"><span class="lineannotation">/**
   * A business service is the execution of any method defined on a service
   * interface. This definition assumes that interfaces are placed in the
   * "service" package, and that implementation types are in sub-packages.
   *
   * If you group service interfaces by functional area (for example,
   * in packages com.xyz.someapp.abc.service and com.xyz.def.service) then
   * the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))"
   * could be used instead.
   *
   * Alternatively, you can write the expression using the 'bean'
   * PCD, like so "bean(*Service)". (This assumes that you have
   * named your Spring service beans in a consistent fashion.)
   */</span></em>
  <i><span class="hl-annotation" style="color: gray">@Pointcut("execution(* com.xyz.someapp.service.*.*(..))")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> businessService() {}

  <em class="lineannotation"><span class="lineannotation">/**
   * A data access operation is the execution of any method defined on a
   * dao interface. This definition assumes that interfaces are placed in the
   * "dao" package, and that implementation types are in sub-packages.
   */</span></em>
  <i><span class="hl-annotation" style="color: gray">@Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> dataAccessOperation() {}

}</pre>

        <p>The pointcuts defined in such an aspect can be referred to
        anywhere that you need a pointcut expression. For example, to make the
        service layer transactional, you could write:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>
  <span class="hl-tag">&lt;aop:advisor</span>
      <span class="hl-attribute">pointcut</span>=<span class="hl-value">"com.xyz.someapp.SystemArchitecture.businessService()"</span>
      <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"tx-advice"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"tx-advice"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;tx:attributes&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/tx:attributes&gt;</span>
<span class="hl-tag">&lt;/tx:advice&gt;</span></pre>

        <p>The <code class="literal">&lt;aop:config&gt;</code> and
        <code class="literal">&lt;aop:advisor&gt;</code> elements are discussed in <a class="xref" href="aop.html#aop-schema" title="9.3&nbsp;Schema-based AOP support">Section&nbsp;9.3, &#8220;Schema-based AOP support&#8221;</a>. The transaction elements are discussed in
        <a class="xref" href="transaction.html" title="12.&nbsp;Transaction Management">Chapter&nbsp;12, <i>Transaction Management</i></a>.</p>
      </div>

      <div class="section" title="Examples"><div class="titlepage"><div><div><h4 class="title"><a name="aop-pointcuts-examples"></a>Examples</h4></div></div></div>
        

        <p>Spring AOP users are likely to use the
        <code class="literal">execution</code> pointcut designator the most often. The
        format of an execution expression is:</p>

        <pre class="programlisting">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)
          <span class="hl-keyword">throws</span>-pattern?)</pre>

        <p>All parts except the returning type pattern (ret-type-pattern in
        the snippet above), name pattern, and parameters pattern are optional.
        The returning type pattern determines what the return type of the
        method must be in order for a join point to be matched. Most
        frequently you will use <code class="literal">*</code> as the returning type
        pattern, which matches any return type. A fully-qualified type name
        will match only when the method returns the given type. The name
        pattern matches the method name. You can use the <code class="literal">*</code>
        wildcard as all or part of a name pattern. The parameters pattern is
        slightly more complex: <code class="literal">()</code> matches a method that
        takes no parameters, whereas <code class="literal">(..)</code> matches any
        number of parameters (zero or more). The pattern
        <code class="literal">(*)</code> matches a method taking one parameter of any
        type, <code class="literal">(*,String)</code> matches a method taking two
        parameters, the first can be of any type, the second must be a String.
        Consult the <a class="ulink" href="http://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html" target="_top">
        Language Semantics</a> section of the AspectJ Programming Guide
        for more information.</p>

        <p>Some examples of common pointcut expressions are given
        below.</p>

        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p>the execution of any public method:</p>

            <pre class="programlisting">execution(<span class="hl-keyword">public</span> * *(..))</pre>
          </li><li class="listitem">
            <p>the execution of any method with a name beginning with
            "set":</p>

            <pre class="programlisting">execution(* set*(..))</pre>
          </li><li class="listitem">
            <p>the execution of any method defined by the
            <code class="interfacename">AccountService</code> interface:</p>

            <pre class="programlisting">execution(* com.xyz.service.AccountService.*(..))</pre>
          </li><li class="listitem">
            <p>the execution of any method defined in the service
            package:</p>

            <pre class="programlisting">execution(* com.xyz.service.*.*(..))</pre>
          </li><li class="listitem">
            <p>the execution of any method defined in the service package
            or a sub-package:</p>

            <pre class="programlisting">execution(* com.xyz.service..*.*(..))</pre>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) within
            the service package:</p>

            <pre class="programlisting">within(com.xyz.service.*)</pre>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) within
            the service package or a sub-package:</p>

            <pre class="programlisting">within(com.xyz.service..*)</pre>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) where
            the proxy implements the
            <code class="interfacename">AccountService</code> interface:</p>

            <pre class="programlisting"><span class="hl-keyword">this</span>(com.xyz.service.AccountService)</pre>

            <p class="remark"><i><span class="remark">'this' is more commonly used in a binding form :-
            see the following section on advice for how to make the proxy
            object available in the advice body.</span></i></p>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) where
            the target object implements the
            <code class="interfacename">AccountService</code> interface:</p>

            <pre class="programlisting">target(com.xyz.service.AccountService)</pre>

            <p class="remark"><i><span class="remark">'target' is more commonly used in a binding form :-
            see the following section on advice for how to make the target
            object available in the advice body.</span></i></p>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) which
            takes a single parameter, and where the argument passed at runtime
            is <code class="interfacename">Serializable</code>:</p>

            <pre class="programlisting">args(java.io.Serializable)</pre>

            <p class="remark"><i><span class="remark">'args' is more commonly used in a binding form :- see the
            following section on advice for how to make the method arguments
            available in the advice body.</span></i></p>

            <p>Note that the pointcut given in this example is different to
            <code class="literal">execution(* *(java.io.Serializable))</code>: the args
            version matches if the argument passed at runtime is Serializable,
            the execution version matches if the method signature declares a
            single parameter of type
            <code class="interfacename">Serializable</code>.</p>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) where
            the target object has an
            <code class="interfacename">@Transactional</code> annotation:</p>

            <pre class="programlisting">@target(org.springframework.transaction.annotation.Transactional)</pre>

            <p class="remark"><i><span class="remark">'@target' can also be used in a binding form :- see
            the following section on advice for how to make the annotation
            object available in the advice body.</span></i></p>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) where
            the declared type of the target object has an
            <code class="interfacename">@Transactional</code> annotation:</p>

            <pre class="programlisting">@within(org.springframework.transaction.annotation.Transactional)</pre>

            <p class="remark"><i><span class="remark">'@within' can also be used in a binding form :- see
            the following section on advice for how to make the annotation
            object available in the advice body.</span></i></p>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) where
            the executing method has an
            <code class="interfacename">@Transactional</code> annotation:</p>

            <pre class="programlisting">@annotation(org.springframework.transaction.annotation.Transactional)</pre>

            <p class="remark"><i><span class="remark">'@annotation' can also be used in a binding form :-
            see the following section on advice for how to make the annotation
            object available in the advice body.</span></i></p>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) which
            takes a single parameter, and where the runtime type of the
            argument passed has the <code class="interfacename">@Classified</code>
            annotation:</p>

            <pre class="programlisting">@args(com.xyz.security.Classified)</pre>

            <p class="remark"><i><span class="remark">'@args' can also be used in a binding form :- see
            the following section on advice for how to make the annotation
            object(s) available in the advice body.</span></i></p>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) on a
            Spring bean named '<code class="literal">tradeService</code>':</p>

            <pre class="programlisting">bean(tradeService)</pre>
          </li><li class="listitem">
            <p>any join point (method execution only in Spring AOP) on
            Spring beans having names that match the wildcard expression
            '<code class="literal">*Service</code>':</p>

            <pre class="programlisting">bean(*Service)</pre>
          </li></ul></div>
      </div>
      <div class="section" title="Writing good pointcuts"><div class="titlepage"><div><div><h4 class="title"><a name="writing-good-pointcuts"></a>Writing good pointcuts</h4></div></div></div>
        

        <p>During compilation, AspectJ processes pointcuts in order to try and optimize matching performance. Examining code
        and determining if each join point matches (statically or dynamically) a given pointcut is a costly process. (A dynamic
        match means the match cannot be fully determined from static analysis and a test will be placed in the code to
        determine if there is an actual match when the code is running). On first encountering a pointcut declaration,
        AspectJ will rewrite it into an optimal form for the matching process. What does this mean? Basically pointcuts
        are rewritten in DNF (Disjunctive Normal Form) and the components of the pointcut are sorted such that those
        components that are cheaper to evaluate are checked first. This means you do not have to worry about understanding
        the performance of various pointcut designators and may supply them in any order in a pointcut declaration.</p>

        <p>However, AspectJ can only work with what it is told, and for optimal performance of matching you should
        think about what they are trying to achieve and narrow the search space for matches as much as possible in the
        definition. The existing designators naturally fall into one of three groups: kinded, scoping and context:</p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Kinded designators are those which select a particular kind of join point. For example: execution, get, set, call, handler</p></li><li class="listitem"><p>Scoping designators are those which select a group of join points of interest (of probably many kinds). For example: within, withincode</p></li><li class="listitem"><p>Contextual designators are those that match (and optionally bind) based on context. For example: this, target, @annotation</p></li></ul></div>

        <p>A well written pointcut should try and include at least the first two types (kinded and scoping), whilst
        the contextual designators may be included if wishing to match based on join point context, or bind that context
        for use in the advice. Supplying either just a kinded designator or just a contextual designator will work but
        could affect weaving performance (time and memory used) due to all the extra processing and analysis. Scoping
        designators are very fast to match and their usage means AspectJ can very quickly dismiss groups of
        join points that should not be further processed - that is why a good pointcut should always include
        one if possible.</p>
      </div>
    </div>

    <div class="section" title="9.2.4&nbsp;Declaring advice"><div class="titlepage"><div><div><h3 class="title"><a name="aop-advice"></a>9.2.4&nbsp;Declaring advice</h3></div></div></div>
      

      <p>Advice is associated with a pointcut expression, and runs before,
      after, or around method executions matched by the pointcut. The pointcut
      expression may be either a simple reference to a named pointcut, or a
      pointcut expression declared in place.</p>

      <div class="section" title="Before advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-before"></a>Before advice</h4></div></div></div>
        

        <p>Before advice is declared in an aspect using the
        <code class="interfacename">@Before</code> annotation:</p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Before;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BeforeExample {

  <i><span class="hl-annotation" style="color: gray">@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
  }

}</pre>

        <p>If using an in-place pointcut expression we could rewrite the
        above example as:</p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Before;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BeforeExample {

  <i><span class="hl-annotation" style="color: gray">@Before("execution(* com.xyz.myapp.dao.*.*(..))")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
  }

}</pre>
      </div>

      <div class="section" title="After returning advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-after-returning"></a>After returning advice</h4></div></div></div>
        

        <p>After returning advice runs when a matched method execution
        returns normally. It is declared using the
        <code class="interfacename">@AfterReturning</code> annotation:</p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterReturningExample {

  <i><span class="hl-annotation" style="color: gray">@AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
  }

}</pre>

        <p class="remark"><i><span class="remark">Note: it is of course possible to have multiple advice
        declarations, and other members as well, all inside the same aspect.
        We're just showing a single advice declaration in these examples to
        focus on the issue under discussion at the time.</span></i></p>

        <p>Sometimes you need access in the advice body to the actual value
        that was returned. You can use the form of
        <code class="interfacename">@AfterReturning</code> that binds the return
        value for this:</p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterReturningExample {

  <i><span class="hl-annotation" style="color: gray">@AfterReturning(
    pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
    returning="retVal")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck(Object retVal) {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
  }

}</pre>

        <p>The name used in the <code class="literal">returning</code> attribute must
        correspond to the name of a parameter in the advice method. When a
        method execution returns, the return value will be passed to the
        advice method as the corresponding argument value. A
        <code class="literal">returning</code> clause also restricts matching to only
        those method executions that return a value of the specified type
        (<code class="classname">Object</code> in this case, which will match any
        return value).</p>

        <p>Please note that it is <span class="emphasis"><em>not</em></span> possible to
        return a totally different reference when using after-returning
        advice.</p>
      </div>

      <div class="section" title="After throwing advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-after-throwing"></a>After throwing advice</h4></div></div></div>
        

        <p>After throwing advice runs when a matched method execution exits
        by throwing an exception. It is declared using the
        <code class="interfacename">@AfterThrowing</code> annotation:</p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterThrowingExample {

  <i><span class="hl-annotation" style="color: gray">@AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doRecoveryActions() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
  }

}</pre>

        <p>Often you want the advice to run only when exceptions of a given
        type are thrown, and you also often need access to the thrown
        exception in the advice body. Use the <code class="literal">throwing</code>
        attribute to both restrict matching (if desired, use
        <code class="interfacename">Throwable</code> as the exception type
        otherwise) and bind the thrown exception to an advice
        parameter.</p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterThrowingExample {

  <i><span class="hl-annotation" style="color: gray">@AfterThrowing(
    pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
    throwing="ex")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doRecoveryActions(DataAccessException ex) {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
  }

}</pre>

        <p>The name used in the <code class="literal">throwing</code> attribute must
        correspond to the name of a parameter in the advice method. When a
        method execution exits by throwing an exception, the exception will be
        passed to the advice method as the corresponding argument value. A
        <code class="literal">throwing</code> clause also restricts matching to only
        those method executions that throw an exception of the specified type
        (<code class="classname">DataAccessException</code> in this case).</p>
      </div>

      <div class="section" title="After (finally) advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-after-finally"></a>After (finally) advice</h4></div></div></div>
        

        <p>After (finally) advice runs however a matched method execution
        exits. It is declared using the <code class="interfacename">@After</code>
        annotation. After advice must be prepared to handle both normal and
        exception return conditions. It is typically used for releasing
        resources, etc.</p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.After;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AfterFinallyExample {

  <i><span class="hl-annotation" style="color: gray">@After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doReleaseLock() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
  }

}</pre>
      </div>

      <div class="section" title="Around advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ataspectj-around-advice"></a>Around advice</h4></div></div></div>
        

        <p>The final kind of advice is around advice. Around advice runs
        "around" a matched method execution. It has the opportunity to do work
        both before and after the method executes, and to determine when, how,
        and even if, the method actually gets to execute at all. Around advice
        is often used if you need to share state before and after a method
        execution in a thread-safe manner (starting and stopping a timer for
        example). Always use the least powerful form of advice that meets your
        requirements (i.e. don't use around advice if simple before advice
        would do).</p>

        <p>Around advice is declared using the
        <code class="interfacename">@Around</code> annotation. The first parameter
        of the advice method must be of type
        <code class="interfacename">ProceedingJoinPoint</code>. Within the body of
        the advice, calling <code class="literal">proceed()</code> on the
        <code class="interfacename">ProceedingJoinPoint</code> causes the
        underlying method to execute. The <code class="literal">proceed</code> method
        may also be called passing in an <code class="classname">Object[]</code> - the
        values in the array will be used as the arguments to the method
        execution when it proceeds.</p>

        <p class="remark"><i><span class="remark">The behavior of proceed when called with an
        Object[] is a little different than the
        behavior of proceed for around advice compiled by the AspectJ
        compiler. For around advice written using the traditional AspectJ
        language, the number of arguments passed to proceed must match the
        number of arguments passed to the around advice (not the number of
        arguments taken by the underlying join point), and the value passed to
        proceed in a given argument position supplants the original value at
        the join point for the entity the value was bound to (Don't worry if
        this doesn't make sense right now!). The approach taken by Spring is
        simpler and a better match to its proxy-based, execution only
        semantics. You only need to be aware of this difference if you are
        compiling @AspectJ aspects written for Spring and using proceed with
        arguments with the AspectJ compiler and weaver. There is a way to
        write such aspects that is 100% compatible across both Spring AOP and
        AspectJ, and this is discussed in the following section on advice
        parameters.</span></i></p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Around;
<span class="hl-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AroundExample {

  <i><span class="hl-annotation" style="color: gray">@Around("com.xyz.myapp.SystemArchitecture.businessService()")</span></i>
  <span class="hl-keyword">public</span> Object doBasicProfiling(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
    <span class="hl-comment">// start stopwatch</span>
    Object retVal = pjp.proceed();
    <span class="hl-comment">// stop stopwatch</span>
    <span class="hl-keyword">return</span> retVal;
  }

}</pre>

        <p>The value returned by the around advice will be the return value
        seen by the caller of the method. A simple caching aspect for example
        could return a value from a cache if it has one, and invoke proceed()
        if it does not. Note that proceed may be invoked once, many times, or
        not at all within the body of the around advice, all of these are
        quite legal.</p>
      </div>

      <div class="section" title="Advice parameters"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ataspectj-advice-params"></a>Advice parameters</h4></div></div></div>
        

        <p>Spring 2.0 offers fully typed advice - meaning that you declare
        the parameters you need in the advice signature (as we saw for the
        returning and throwing examples above) rather than work with
        <code class="classname">Object[]</code> arrays all the time. We'll see how to
        make argument and other contextual values available to the advice body
        in a moment. First let's take a look at how to write generic advice
        that can find out about the method the advice is currently
        advising.</p>

        <div class="section" title="Access to the current JoinPoint"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-the-joinpoint"></a>Access to the current
          <code class="interfacename">JoinPoint</code></h5></div></div></div>
          

          <p>Any advice method may declare as its first parameter, a
          parameter of type
          <code class="interfacename">org.aspectj.lang.JoinPoint</code> (please
          note that around advice is <span class="emphasis"><em>required</em></span> to declare
          a first parameter of type
          <code class="interfacename">ProceedingJoinPoint</code>, which is a
          subclass of <code class="interfacename">JoinPoint</code>. The
          <code class="interfacename">JoinPoint</code> interface provides a number
          of useful methods such as <code class="literal">getArgs()</code> (returns the
          method arguments), <code class="methodname">getThis()</code> (returns the
          proxy object), <code class="methodname">getTarget()</code> (returns the
          target object), <code class="methodname">getSignature()</code> (returns a
          description of the method that is being advised) and
          <code class="methodname">toString()</code> (prints a useful description of
          the method being advised). Please do consult the Javadocs for full
          details.</p>
        </div>

        <div class="section" title="Passing parameters to advice"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-passing"></a>Passing parameters to advice</h5></div></div></div>
          

          <p>We've already seen how to bind the returned value or exception
          value (using after returning and after throwing advice). To make
          argument values available to the advice body, you can use the
          binding form of <code class="literal">args</code>. If a parameter name is used
          in place of a type name in an args expression, then the value of the
          corresponding argument will be passed as the parameter value when
          the advice is invoked. An example should make this clearer. Suppose
          you want to advise the execution of dao operations that take an
          Account object as the first parameter, and you need access to the
          account in the advice body. You could write the following:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp;" +
        "args(account,..)")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validateAccount(Account account) {
  <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>

          <p>The <code class="literal">args(account,..)</code> part of the pointcut
          expression serves two purposes: firstly, it restricts matching to
          only those method executions where the method takes at least one
          parameter, and the argument passed to that parameter is an instance
          of <code class="classname">Account</code>; secondly, it makes the actual
          <code class="classname">Account</code> object available to the advice via
          the <code class="literal">account</code> parameter.</p>

          <p>Another way of writing this is to declare a pointcut that
          "provides" the <code class="classname">Account</code> object value when it
          matches a join point, and then just refer to the named pointcut from
          the advice. This would look as follows:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp;" +
          "args(account,..)")</span></i>
<span class="hl-keyword">private</span> <span class="hl-keyword">void</span> accountDataAccessOperation(Account account) {}

<i><span class="hl-annotation" style="color: gray">@Before("accountDataAccessOperation(account)")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validateAccount(Account account) {
  <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>

          <p>The interested reader is once more referred to the AspectJ
          programming guide for more details.</p>

          <p>The proxy object (<code class="literal">this</code>), target object
          (<code class="literal">target</code>), and annotations (<code class="literal">@within,
          @target, @annotation, @args</code>) can all be bound in a similar
          fashion. The following example shows how you could match the
          execution of methods annotated with an
          <code class="interfacename">@Auditable</code> annotation, and extract
          the audit code.</p>

          <p>First the definition of the
          <code class="interfacename">@Auditable</code> annotation:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></i>
<i><span class="hl-annotation" style="color: gray">@Target(ElementType.METHOD)</span></i>
<span class="hl-keyword">public</span> <i><span class="hl-annotation" style="color: gray">@interface</span></i> Auditable {
    AuditCode value();
}</pre>

          <p>And then the advice that matches the execution of
          <code class="interfacename">@Auditable</code> methods:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; " +
        "@annotation(auditable)")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> audit(Auditable auditable) {
  AuditCode code = auditable.value();
  <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
        </div>

        <div class="section" title="Advice parameters and generics"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-generics"></a>Advice parameters and generics</h5></div></div></div>
          

          <p>Spring AOP can handle generics used in class declarations and
          method parameters. Suppose you have a generic type like this:</p>

          <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Sample&lt;T&gt; {
  <span class="hl-keyword">void</span> sampleGenericMethod(T param);
  <span class="hl-keyword">void</span> sampleGenericCollectionMethod(Collection&gt;T&gt; param);
}</pre>

          <p>You can restrict interception of method types to certain
          parameter types by simply typing the advice parameter to the
          parameter type you want to intercept the method for:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> beforeSampleMethod(MyType param) {
  <span class="hl-comment">// Advice implementation</span>
}</pre>

          <p>That this works is pretty obvious as we already discussed
          above. However, it's worth pointing out that this won't work for
          generic collections. So you cannot define a pointcut like
          this:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> beforeSampleMethod(Collection&lt;MyType&gt; param) {
  <span class="hl-comment">// Advice implementation</span>
}</pre>

          <p>To make this work we would have to inspect every element of
          the collection, which is not reasonable as we also cannot decide how
          to treat <code class="literal">null</code> values in general. To achieve
          something similar to this you have to type the parameter to
          <code class="interfacename">Collection&lt;?&gt;</code> and manually
          check the type of the elements.</p>
        </div>

        <div class="section" title="Determining argument names"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-names"></a>Determining argument names</h5></div></div></div>
          

          <p>The parameter binding in advice invocations relies on matching
          names used in pointcut expressions to declared parameter names in
          (advice and pointcut) method signatures. Parameter names are
          <span class="emphasis"><em>not</em></span> available through Java reflection, so
          Spring AOP uses the following strategies to determine parameter
          names:</p>

          <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
              <p>If the parameter names have been specified by the user
              explicitly, then the specified parameter names are used: both
              the advice and the pointcut annotations have an optional
              "argNames" attribute which can be used to specify the argument
              names of the annotated method - these argument names
              <span class="emphasis"><em>are</em></span> available at runtime. For
              example:</p>

              <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Before(
   value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
   argNames="bean,auditable")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> audit(Object bean, Auditable auditable) {
  AuditCode code = auditable.value();
  <em class="lineannotation"><span class="lineannotation">// ... use code and bean</span></em>
}</pre>

              <p>If the first parameter is of the
              <code class="interfacename">JoinPoint</code>,
              <code class="interfacename">ProceedingJoinPoint</code>, or
              <code class="interfacename">JoinPoint.StaticPart</code> type, you
              may leave out the name of the parameter from the value of the
              "argNames" attribute. For example, if you modify the preceding
              advice to receive the join point object, the "argNames"
              attribute need not include it:</p>

              <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Before(
   value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
   argNames="bean,auditable")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> audit(JoinPoint jp, Object bean, Auditable auditable) {
  AuditCode code = auditable.value();
  <em class="lineannotation"><span class="lineannotation">// ... use code, bean, and jp</span></em>
}</pre>

              <p>The special treatment given to the first parameter of the
              <code class="interfacename">JoinPoint</code>,
              <code class="interfacename">ProceedingJoinPoint</code>, and
              <code class="interfacename">JoinPoint.StaticPart</code> types is
              particularly convenient for advice that do not collect any other
              join point context. In such situations, you may simply omit the
              "argNames" attribute. For example, the following advice need not
              declare the "argNames" attribute:</p>

              <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Before(
   "com.xyz.lib.Pointcuts.anyPublicMethod()")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> audit(JoinPoint jp) {
  <em class="lineannotation"><span class="lineannotation">// ... use jp</span></em>
}</pre>
            </li><li class="listitem">
              <p>Using the <code class="literal">'argNames'</code> attribute is a
              little clumsy, so if the <code class="literal">'argNames'</code> attribute
              has not been specified, then Spring AOP will look at the debug
              information for the class and try to determine the parameter
              names from the local variable table. This information will be
              present as long as the classes have been compiled with debug
              information (<code class="literal">'-g:vars'</code> at a minimum). The
              consequences of compiling with this flag on are: (1) your code
              will be slightly easier to understand (reverse engineer), (2)
              the class file sizes will be very slightly bigger (typically
              inconsequential), (3) the optimization to remove unused local
              variables will not be applied by your compiler. In other words,
              you should encounter no difficulties building with this flag
              on.</p>

              <p class="remark"><i><span class="remark">If an @AspectJ aspect has been compiled by the AspectJ
              compiler (ajc) even without the debug information then there is
              no need to add the argNames attribute as the
              compiler will retain the needed information.</span></i></p>
            </li><li class="listitem">
              <p>If the code has been compiled without the necessary debug
              information, then Spring AOP will attempt to deduce the pairing
              of binding variables to parameters (for example, if only one
              variable is bound in the pointcut expression, and the advice
              method only takes one parameter, the pairing is obvious!). If
              the binding of variables is ambiguous given the available
              information, then an
              <code class="exceptionname">AmbiguousBindingException</code> will be
              thrown.</p>
            </li><li class="listitem">
              <p>If all of the above strategies fail then an
              <code class="exceptionname">IllegalArgumentException</code> will be
              thrown.</p>
            </li></ol></div>
        </div>

        <div class="section" title="Proceeding with arguments"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-proceeding-with-the-call"></a>Proceeding with arguments</h5></div></div></div>
          

          <p>We remarked earlier that we would describe how to write a
          proceed call <span class="emphasis"><em>with arguments</em></span> that works
          consistently across Spring AOP and AspectJ. The solution is simply
          to ensure that the advice signature binds each of the method
          parameters in order. For example:</p>

          <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp;" +
        "com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; " +
        "args(accountHolderNamePattern)")</span></i>
<span class="hl-keyword">public</span> Object preProcessQueryPattern(ProceedingJoinPoint pjp, String accountHolderNamePattern)
<span class="hl-keyword">throws</span> Throwable {
  String newPattern = preProcess(accountHolderNamePattern);
  <span class="hl-keyword">return</span> pjp.proceed(<span class="hl-keyword">new</span> Object[] {newPattern});
}
</pre>

          <p>In many cases you will be doing this binding anyway (as in the
          example above).</p>
        </div>
      </div>

      <div class="section" title="Advice ordering"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ataspectj-advice-ordering"></a>Advice ordering</h4></div></div></div>
        

        <p>What happens when multiple pieces of advice all want to run at
        the same join point? Spring AOP follows the same precedence rules as
        AspectJ to determine the order of advice execution. The highest
        precedence advice runs first "on the way in" (so given two pieces of
        before advice, the one with highest precedence runs first). "On the
        way out" from a join point, the highest precedence advice runs last
        (so given two pieces of after advice, the one with the highest
        precedence will run second).</p>

        <p>When two pieces of advice defined in
        <span class="emphasis"><em>different</em></span> aspects both need to run at the same
        join point, unless you specify otherwise the order of execution is
        undefined. You can control the order of execution by specifying
        precedence. This is done in the normal Spring way by either
        implementing the
        <code class="interfacename">org.springframework.core.Ordered</code>
        interface in the aspect class or annotating it with the
        <code class="interfacename">Order</code> annotation. Given two aspects,
        the aspect returning the lower value from
        <code class="literal">Ordered.getValue()</code> (or the annotation value) has
        the higher precedence.</p>

        <p>When two pieces of advice defined in <span class="emphasis"><em>the
        same</em></span> aspect both need to run at the same join point, the
        ordering is undefined (since there is no way to retrieve the
        declaration order via reflection for javac-compiled classes). Consider
        collapsing such advice methods into one advice method per join point
        in each aspect class, or refactor the pieces of advice into separate
        aspect classes - which can be ordered at the aspect level.</p>
      </div>
    </div>

    <div class="section" title="9.2.5&nbsp;Introductions"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introductions"></a>9.2.5&nbsp;Introductions</h3></div></div></div>
      

      <p>Introductions (known as inter-type declarations in AspectJ) enable
      an aspect to declare that advised objects implement a given interface,
      and to provide an implementation of that interface on behalf of those
      objects.</p>

      <p>An introduction is made using the
      <code class="interfacename">@DeclareParents</code> annotation. This
      annotation is used to declare that matching types have a new parent
      (hence the name). For example, given an interface
      <code class="interfacename">UsageTracked</code>, and an implementation of
      that interface <code class="classname">DefaultUsageTracked</code>, the following
      aspect declares that all implementors of service interfaces also
      implement the <code class="interfacename">UsageTracked</code> interface. (In
      order to expose statistics via JMX for example.)</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> UsageTracking {

  <i><span class="hl-annotation" style="color: gray">@DeclareParents(value="com.xzy.myapp.service.*+",
                  defaultImpl=DefaultUsageTracked.class)</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> UsageTracked mixin;

  <i><span class="hl-annotation" style="color: gray">@Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp;" +
          "this(usageTracked)")</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> recordUsage(UsageTracked usageTracked) {
    usageTracked.incrementUseCount();
  }

}</pre>

      <p>The interface to be implemented is determined by the type of the
      annotated field. The <code class="literal">value</code> attribute of the
      <code class="interfacename">@DeclareParents</code> annotation is an AspectJ
      type pattern :- any bean of a matching type will implement the
      UsageTracked interface. Note that in the before advice of the above
      example, service beans can be directly used as implementations of the
      <code class="interfacename">UsageTracked</code> interface. If accessing a
      bean programmatically you would write the following:</p>

      <pre class="programlisting">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="hl-string">"myService"</span>);</pre>
    </div>

    <div class="section" title="9.2.6&nbsp;Aspect instantiation models"><div class="titlepage"><div><div><h3 class="title"><a name="aop-instantiation-models"></a>9.2.6&nbsp;Aspect instantiation models</h3></div></div></div>
      

      <p class="remark"><i><span class="remark">(This is an advanced topic, so if you are just starting out with
      AOP you can safely skip it until later.)</span></i></p>

      <p>By default there will be a single instance of each aspect within
      the application context. AspectJ calls this the singleton instantiation
      model. It is possible to define aspects with alternate lifecycles :-
      Spring supports AspectJ's <code class="literal">perthis</code> and
      <code class="literal">pertarget</code> instantiation models (<code class="literal">percflow,
      percflowbelow,</code> and <code class="literal">pertypewithin</code> are not
      currently supported).</p>

      <p>A "perthis" aspect is declared by specifying a
      <code class="literal">perthis</code> clause in the
      <code class="interfacename">@Aspect</code> annotation. Let's look at an
      example, and then we'll explain how it works.</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyAspect {

  <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> someState;

  <i><span class="hl-annotation" style="color: gray">@Before(com.xyz.myapp.SystemArchitecture.businessService())</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> recordServiceUsage() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
  }

}</pre>

      <p>The effect of the <code class="literal">'perthis'</code> clause is that one
      aspect instance will be created for each unique service object executing
      a business service (each unique object bound to 'this' at join points
      matched by the pointcut expression). The aspect instance is created the
      first time that a method is invoked on the service object. The aspect
      goes out of scope when the service object goes out of scope. Before the
      aspect instance is created, none of the advice within it executes. As
      soon as the aspect instance has been created, the advice declared within
      it will execute at matched join points, but only when the service object
      is the one this aspect is associated with. See the AspectJ programming
      guide for more information on per-clauses.</p>

      <p>The <code class="literal">'pertarget'</code> instantiation model works in
      exactly the same way as perthis, but creates one aspect instance for
      each unique target object at matched join points.</p>
    </div>

    <div class="section" title="9.2.7&nbsp;Example"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ataspectj-example"></a>9.2.7&nbsp;Example</h3></div></div></div>
      

      <p>Now that you have seen how all the constituent parts work, let's
      put them together to do something useful!</p>

      <p>The execution of business services can sometimes fail due to
      concurrency issues (for example, deadlock loser). If the operation is
      retried, it is quite likely to succeed next time round. For business
      services where it is appropriate to retry in such conditions (idempotent
      operations that don't need to go back to the user for conflict
      resolution), we'd like to transparently retry the operation to avoid the
      client seeing a
      <code class="classname">PessimisticLockingFailureException</code>. This is a
      requirement that clearly cuts across multiple services in the service
      layer, and hence is ideal for implementing via an aspect.</p>

      <p>Because we want to retry the operation, we will need to use around
      advice so that we can call proceed multiple times. Here's how the basic
      aspect implementation looks:</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ConcurrentOperationExecutor <span class="hl-keyword">implements</span> Ordered {

   <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> DEFAULT_MAX_RETRIES = <span class="hl-number">2</span>;

   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> maxRetries = DEFAULT_MAX_RETRIES;
   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> order = <span class="hl-number">1</span>;

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setMaxRetries(<span class="hl-keyword">int</span> maxRetries) {
      <span class="hl-keyword">this</span>.maxRetries = maxRetries;
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getOrder() {
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.order;
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrder(<span class="hl-keyword">int</span> order) {
      <span class="hl-keyword">this</span>.order = order;
   }

   <i><span class="hl-annotation" style="color: gray">@Around("com.xyz.myapp.SystemArchitecture.businessService()")</span></i>
   <span class="hl-keyword">public</span> Object doConcurrentOperation(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
      <span class="hl-keyword">int</span> numAttempts = <span class="hl-number">0</span>;
      PessimisticLockingFailureException lockFailureException;
      <span class="hl-keyword">do</span> {
         numAttempts++;
         <span class="hl-keyword">try</span> {
            <span class="hl-keyword">return</span> pjp.proceed();
         }
         <span class="hl-keyword">catch</span>(PessimisticLockingFailureException ex) {
            lockFailureException = ex;
         }
      }
      <span class="hl-keyword">while</span>(numAttempts &lt;= <span class="hl-keyword">this</span>.maxRetries);
      <span class="hl-keyword">throw</span> lockFailureException;
   }

}</pre>

      <p>Note that the aspect implements the
      <code class="interfacename">Ordered</code> interface so we can set the
      precedence of the aspect higher than the transaction advice (we want a
      fresh transaction each time we retry). The <code class="literal">maxRetries</code>
      and <code class="literal">order</code> properties will both be configured by
      Spring. The main action happens in the
      <code class="literal">doConcurrentOperation</code> around advice. Notice that for
      the moment we're applying the retry logic to all
      <code class="literal">businessService()s</code>. We try to proceed, and if we fail
      with an <code class="classname">PessimisticLockingFailureException</code> we
      simply try again unless we have exhausted all of our retry
      attempts.</p>

      <p>The corresponding Spring configuration is:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:aspectj-autoproxy/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"concurrentOperationExecutor"</span>
  <span class="hl-attribute">class</span>=<span class="hl-value">"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxRetries"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"3"</span><span class="hl-tag">/&gt;</span>
     <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"order"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>To refine the aspect so that it only retries idempotent
      operations, we might define an <code class="interfacename">Idempotent</code>
      annotation:</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></i>
<span class="hl-keyword">public</span> <i><span class="hl-annotation" style="color: gray">@interface</span></i> Idempotent {
  <em class="lineannotation"><span class="lineannotation">// marker annotation</span></em>
}</pre>

      <p>and use the annotation to annotate the implementation of service
      operations. The change to the aspect to only retry idempotent operations
      simply involves refining the pointcut expression so that only
      <code class="interfacename">@Idempotent</code> operations match:</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Around("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; " +
        "@annotation(com.xyz.myapp.service.Idempotent)")</span></i>
<span class="hl-keyword">public</span> Object doConcurrentOperation(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
  ...
}</pre>
    </div>
  </div>

  <div class="section" title="9.3&nbsp;Schema-based AOP support"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-schema"></a>9.3&nbsp;Schema-based AOP support</h2></div></div></div>
    

    <p>If you are unable to use Java 5, or simply prefer an XML-based
    format, then Spring 2.0 also offers support for defining aspects using the
    new "aop" namespace tags. The exact same pointcut expressions and advice
    kinds are supported as when using the @AspectJ style, hence in this
    section we will focus on the new <span class="emphasis"><em>syntax</em></span> and refer the
    reader to the discussion in the previous section (<a class="xref" href="aop.html#aop-ataspectj" title="9.2&nbsp;@AspectJ support">Section&nbsp;9.2, &#8220;@AspectJ support&#8221;</a>) for an understanding of writing pointcut
    expressions and the binding of advice parameters.</p>

    <p>To use the aop namespace tags described in this section, you need to
    import the spring-aop schema as described in <a class="xref" href="xsd-config.html" title="Appendix&nbsp;E.&nbsp;XML Schema-based configuration">Appendix&nbsp;E, <i>XML Schema-based configuration</i></a>. See <a class="xref" href="xsd-config.html#xsd-config-body-schemas-aop" title="E.2.7&nbsp;The aop schema">Section&nbsp;E.2.7, &#8220;The <code class="literal">aop</code> schema&#8221;</a> for how to import the tags in the
    aop namespace.</p>

    <p>Within your Spring configurations, all aspect and advisor elements
    must be placed within an <code class="literal">&lt;aop:config&gt;</code> element
    (you can have more than one <code class="literal">&lt;aop:config&gt;</code> element
    in an application context configuration). An
    <code class="literal">&lt;aop:config&gt;</code> element can contain pointcut,
    advisor, and aspect elements (note these must be declared in that
    order).</p>

    <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top">
      <p>The <code class="literal">&lt;aop:config&gt;</code> style of configuration
      makes heavy use of Spring's <a class="link" href="aop-api.html#aop-autoproxy" title="10.9&nbsp;Using the &#34;autoproxy&#34; facility">auto-proxying</a> mechanism. This can cause
      issues (such as advice not being woven) if you are already using
      explicit auto-proxying via the use of
      <code class="classname">BeanNameAutoProxyCreator</code> or suchlike. The
      recommended usage pattern is to use either just the
      <code class="literal">&lt;aop:config&gt;</code> style, or just the
      <code class="interfacename">AutoProxyCreator</code> style.</p>
    </td></tr></table></div>

    <div class="section" title="9.3.1&nbsp;Declaring an aspect"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-declaring-an-aspect"></a>9.3.1&nbsp;Declaring an aspect</h3></div></div></div>
      

      <p>Using the schema support, an aspect is simply a regular Java
      object defined as a bean in your Spring application context. The state
      and behavior is captured in the fields and methods of the object, and
      the pointcut and advice information is captured in the XML.</p>

      <p>An aspect is declared using the &lt;aop:aspect&gt; element, and
      the backing bean is referenced using the <code class="literal">ref</code>
      attribute:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>
  <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>
    ...
  <span class="hl-tag">&lt;/aop:aspect&gt;</span>
<span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"aBean"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"..."</span><span class="hl-tag">&gt;</span>
  ...
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>The bean backing the aspect ("<code class="literal">aBean</code>" in this
      case) can of course be configured and dependency injected just like any
      other Spring bean.</p>
    </div>

    <div class="section" title="9.3.2&nbsp;Declaring a pointcut"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-pointcuts"></a>9.3.2&nbsp;Declaring a pointcut</h3></div></div></div>
      

      <p>A named pointcut can be declared inside an &lt;aop:config&gt;
      element, enabling the pointcut definition to be shared across several
      aspects and advisors.</p>

      <p>A pointcut representing the execution of any business service in
      the service layer could be defined as follows:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

  <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..))"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span></pre>

      <p>Note that the pointcut expression itself is using the same AspectJ
      pointcut expression language as described in <a class="xref" href="aop.html#aop-ataspectj" title="9.2&nbsp;@AspectJ support">Section&nbsp;9.2, &#8220;@AspectJ support&#8221;</a>. If you are using the schema based
      declaration style with Java 5, you can refer to named pointcuts defined
      in types (@Aspects) within the pointcut expression, but this feature is
      not available on JDK 1.4 and below (it relies on the Java 5 specific
      AspectJ reflection APIs). On JDK 1.5 therefore, another way of defining
      the above pointcut would be:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

  <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"com.xyz.myapp.SystemArchitecture.businessService()"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span></pre>

      <p>Assuming you have a <code class="literal">SystemArchitecture</code> aspect
      as described in <a class="xref" href="aop.html#aop-common-pointcuts" title="Sharing common pointcut definitions">the section called &#8220;Sharing common pointcut definitions&#8221;</a>.</p>

      <p>Declaring a pointcut inside an aspect is very similar to declaring
      a top-level pointcut:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

  <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
          <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..))"</span><span class="hl-tag">/&gt;</span>

    ...

  <span class="hl-tag">&lt;/aop:aspect&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span></pre>

      <p>Much the same way in an @AspectJ aspect, pointcuts declared using
      the schema based definition style may collect join point context. For
      example, the following pointcut collects the 'this' object as the join
      point context and passes it to advice:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

  <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
          <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;aop:before</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"businessService"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"monitor"</span><span class="hl-tag">/&gt;</span>
    ...

  <span class="hl-tag">&lt;/aop:aspect&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span></pre>

      <p>The advice must be declared to receive the collected join point
      context by including parameters of the matching names:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> monitor(Object service) {
    ...
}</pre>

      <p>When combining pointcut sub-expressions, '&amp;&amp;' is awkward
      within an XML document, and so the keywords 'and', 'or' and 'not' can be
      used in place of '&amp;&amp;', '||' and '!' respectively. For example,
      the previous pointcut may be better written as:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

  <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
          <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..)) </span><span class="bold"><strong>and</strong></span> this(service)"/&gt;
    <span class="hl-tag">&lt;aop:before</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"businessService"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"monitor"</span><span class="hl-tag">/&gt;</span>
    ...

  <span class="hl-tag">&lt;/aop:aspect&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span></pre>

      <p>Note that pointcuts defined in this way are referred to by their
      XML id and cannot be used as named pointcuts to form composite
      pointcuts. The named pointcut support in the schema based definition
      style is thus more limited than that offered by the @AspectJ
      style.</p>
    </div>

    <div class="section" title="9.3.3&nbsp;Declaring advice"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-advice"></a>9.3.3&nbsp;Declaring advice</h3></div></div></div>
      

      <p>The same five advice kinds are supported as for the @AspectJ
      style, and they have exactly the same semantics.</p>

      <div class="section" title="Before advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-before"></a>Before advice</h4></div></div></div>
        

        <p>Before advice runs before a matched method execution. It is
        declared inside an <code class="literal">&lt;aop:aspect&gt;</code> using the
        &lt;aop:before&gt; element.</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"beforeExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:before</span>
      <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
      <span class="hl-attribute">method</span>=<span class="hl-value">"doAccessCheck"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>

        <p>Here <code class="literal">dataAccessOperation</code> is the id of a
        pointcut defined at the top (<code class="literal">&lt;aop:config&gt;</code>)
        level. To define the pointcut inline instead, replace the
        <code class="literal">pointcut-ref</code> attribute with a
        <code class="literal">pointcut</code> attribute:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"beforeExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:before</span>
      <span class="hl-attribute">pointcut</span>=<span class="hl-value">"execution(* com.xyz.myapp.dao.*.*(..))"</span>
      <span class="hl-attribute">method</span>=<span class="hl-value">"doAccessCheck"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>

        <p>As we noted in the discussion of the @AspectJ style, using named
        pointcuts can significantly improve the readability of your
        code.</p>

        <p>The method attribute identifies a method
        (<code class="literal">doAccessCheck</code>) that provides the body of the
        advice. This method must be defined for the bean referenced by the
        aspect element containing the advice. Before a data access operation
        is executed (a method execution join point matched by the pointcut
        expression), the "doAccessCheck" method on the aspect bean will be
        invoked.</p>
      </div>

      <div class="section" title="After returning advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-after-returning"></a>After returning advice</h4></div></div></div>
        

        <p>After returning advice runs when a matched method execution
        completes normally. It is declared inside an
        <code class="literal">&lt;aop:aspect&gt;</code> in the same way as before
        advice. For example:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterReturningExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after-returning</span>
      <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
      <span class="hl-attribute">method</span>=<span class="hl-value">"doAccessCheck"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>

        <p>Just as in the @AspectJ style, it is possible to get hold of the
        return value within the advice body. Use the returning attribute to
        specify the name of the parameter to which the return value should be
        passed:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterReturningExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after-returning</span>
      <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
      <span class="hl-attribute">returning</span>=<span class="hl-value">"retVal"</span>
      <span class="hl-attribute">method</span>=<span class="hl-value">"doAccessCheck"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>

        <p>The doAccessCheck method must declare a parameter named
        <code class="literal">retVal</code>. The type of this parameter constrains
        matching in the same way as described for @AfterReturning. For
        example, the method signature may be declared as:</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doAccessCheck(Object retVal) {...</pre>
      </div>

      <div class="section" title="After throwing advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-after-throwing"></a>After throwing advice</h4></div></div></div>
        

        <p>After throwing advice executes when a matched method execution
        exits by throwing an exception. It is declared inside an
        <code class="literal">&lt;aop:aspect&gt;</code> using the after-throwing
        element:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterThrowingExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after-throwing</span>
      <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
      <span class="hl-attribute">method</span>=<span class="hl-value">"doRecoveryActions"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>

        <p>Just as in the @AspectJ style, it is possible to get hold of the
        thrown exception within the advice body. Use the throwing attribute to
        specify the name of the parameter to which the exception should be
        passed:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterThrowingExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after-throwing</span>
      <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
      <span class="hl-attribute">throwing</span>=<span class="hl-value">"dataAccessEx"</span>
      <span class="hl-attribute">method</span>=<span class="hl-value">"doRecoveryActions"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>

        <p>The doRecoveryActions method must declare a parameter named
        <code class="literal">dataAccessEx</code>. The type of this parameter constrains
        matching in the same way as described for @AfterThrowing. For example,
        the method signature may be declared as:</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doRecoveryActions(DataAccessException dataAccessEx) {...</pre>
      </div>

      <div class="section" title="After (finally) advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-after-finally"></a>After (finally) advice</h4></div></div></div>
        

        <p>After (finally) advice runs however a matched method execution
        exits. It is declared using the <code class="literal">after</code>
        element:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"afterFinallyExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:after</span>
      <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"dataAccessOperation"</span>
      <span class="hl-attribute">method</span>=<span class="hl-value">"doReleaseLock"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>
      </div>

      <div class="section" title="Around advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-around"></a>Around advice</h4></div></div></div>
        

        <p>The final kind of advice is around advice. Around advice runs
        "around" a matched method execution. It has the opportunity to do work
        both before and after the method executes, and to determine when, how,
        and even if, the method actually gets to execute at all. Around advice
        is often used if you need to share state before and after a method
        execution in a thread-safe manner (starting and stopping a timer for
        example). Always use the least powerful form of advice that meets your
        requirements; don't use around advice if simple before advice would
        do.</p>

        <p>Around advice is declared using the
        <code class="literal">aop:around</code> element. The first parameter of the
        advice method must be of type
        <code class="interfacename">ProceedingJoinPoint</code>. Within the body of
        the advice, calling <code class="literal">proceed()</code> on the
        <code class="interfacename">ProceedingJoinPoint</code> causes the
        underlying method to execute. The <code class="literal">proceed</code> method
        may also be calling passing in an <code class="classname">Object[]</code> -
        the values in the array will be used as the arguments to the method
        execution when it proceeds. See <a class="xref" href="aop.html#aop-ataspectj-around-advice" title="Around advice">the section called &#8220;Around advice&#8221;</a> for notes on calling proceed
        with an <code class="classname">Object[]</code>.</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"aroundExample"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"aBean"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:around</span>
      <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"businessService"</span>
      <span class="hl-attribute">method</span>=<span class="hl-value">"doBasicProfiling"</span><span class="hl-tag">/&gt;</span>

    ...

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>

        <p>The implementation of the <code class="literal">doBasicProfiling</code>
        advice would be exactly the same as in the @AspectJ example (minus the
        annotation of course):</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> Object doBasicProfiling(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
    <em class="lineannotation"><span class="lineannotation">// start stopwatch</span></em>
    Object retVal = pjp.proceed();
    <em class="lineannotation"><span class="lineannotation">// stop stopwatch</span></em>
    <span class="hl-keyword">return</span> retVal;
}</pre>
      </div>

      <div class="section" title="Advice parameters"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-params"></a>Advice parameters</h4></div></div></div>
        

        <p>The schema based declaration style supports fully typed advice
        in the same way as described for the @AspectJ support - by matching
        pointcut parameters by name against advice method parameters. See
        <a class="xref" href="aop.html#aop-ataspectj-advice-params" title="Advice parameters">the section called &#8220;Advice parameters&#8221;</a> for details. If you
        wish to explicitly specify argument names for the advice methods (not
        relying on the detection strategies previously described) then this is
        done using the <code class="literal">arg-names</code> attribute of the advice
        element, which is treated in the same manner to the "argNames"
        attribute in an advice annotation as described in <a class="xref" href="aop.html#aop-ataspectj-advice-params-names" title="Determining argument names">the section called &#8220;Determining argument names&#8221;</a>. For example:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;aop:before</span>
  <span class="hl-attribute">pointcut</span>=<span class="hl-value">"com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"</span>
  <span class="hl-attribute">method</span>=<span class="hl-value">"audit"</span>
  <span class="hl-attribute">arg-names</span>=<span class="hl-value">"auditable"</span><span class="hl-tag">/&gt;</span></pre>

        <p>The <code class="literal">arg-names</code> attribute accepts a
        comma-delimited list of parameter names.</p>

        <p>Find below a slightly more involved example of the XSD-based
        approach that illustrates some around advice used in conjunction with
        a number of strongly typed parameters.</p>

        <pre class="programlisting"><span class="hl-keyword">package</span> x.y.service;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FooService {

   Foo getFoo(String fooName, <span class="hl-keyword">int</span> age);
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DefaultFooService <span class="hl-keyword">implements</span> FooService {

   <span class="hl-keyword">public</span> Foo getFoo(String name, <span class="hl-keyword">int</span> age) {
      <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Foo(name, age);
   }
}</pre>

        <p>Next up is the aspect. Notice the fact that the
        <code class="methodname">profile(..)</code> method accepts a number of
        strongly-typed parameters, the first of which happens to be the join
        point used to proceed with the method call: the presence of this
        parameter is an indication that the
        <code class="methodname">profile(..)</code> is to be used as
        <code class="literal">around</code> advice:</p>

        <pre class="programlisting"><span class="hl-keyword">package</span> x.y;

<span class="hl-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;
<span class="hl-keyword">import</span> org.springframework.util.StopWatch;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimpleProfiler {

   <span class="hl-keyword">public</span> Object profile(ProceedingJoinPoint call, String name, <span class="hl-keyword">int</span> age) <span class="hl-keyword">throws</span> Throwable {
      StopWatch clock = <span class="hl-keyword">new</span> StopWatch(
            <span class="hl-string">"Profiling for '"</span> + name + <span class="hl-string">"' and '"</span> + age + <span class="hl-string">"'"</span>);
      <span class="hl-keyword">try</span> {
         clock.start(call.toShortString());
         <span class="hl-keyword">return</span> call.proceed();
      } <span class="hl-keyword">finally</span> {
         clock.stop();
         System.out.println(clock.prettyPrint());
      }
   }
}</pre>

        <p>Finally, here is the XML configuration that is required to
        effect the execution of the above advice for a particular join
        point:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
      <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
      <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">"http://www.springframework.org/schema/aop"</span>
      <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span><span class="hl-tag">&gt;</span>

   <em class="lineannotation"><span class="lineannotation">&lt;!-- this is the object that will be proxied by Spring's AOP infrastructure --&gt;</span></em>
   <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"fooService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"x.y.service.DefaultFooService"</span><span class="hl-tag">/&gt;</span>

   <em class="lineannotation"><span class="lineannotation">&lt;!-- this is the actual advice itself --&gt;</span></em>
   <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"profiler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"x.y.SimpleProfiler"</span><span class="hl-tag">/&gt;</span>

   <span class="hl-tag">&lt;aop:config&gt;</span>
      <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"profiler"</span><span class="hl-tag">&gt;</span>

         <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"theExecutionOfSomeFooServiceMethod"</span>
                    <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* x.y.service.FooService.getFoo(String,int))
                    and args(name, age)"</span><span class="hl-tag">/&gt;</span>

         <span class="hl-tag">&lt;aop:around</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"theExecutionOfSomeFooServiceMethod"</span>
                  <span class="hl-attribute">method</span>=<span class="hl-value">"profile"</span><span class="hl-tag">/&gt;</span>

      <span class="hl-tag">&lt;/aop:aspect&gt;</span>
   <span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

        <p>If we had the following driver script, we would get output
        something like this on standard output:</p>

        <pre class="programlisting"><span class="hl-keyword">import</span> org.springframework.beans.factory.BeanFactory;
<span class="hl-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;
<span class="hl-keyword">import</span> x.y.service.FooService;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> Boot {

   <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(<span class="hl-keyword">final</span> String[] args) <span class="hl-keyword">throws</span> Exception {
      BeanFactory ctx = <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-string">"x/y/plain.xml"</span>);
      FooService foo = (FooService) ctx.getBean(<span class="hl-string">"fooService"</span>);
      foo.getFoo(<span class="hl-string">"Pengo"</span>, <span class="hl-number">12</span>);
   }
}</pre>

        <pre class="programlisting">StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)</pre>
      </div>

      <div class="section" title="Advice ordering"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ordering"></a>Advice ordering</h4></div></div></div>
        

        <p>When multiple advice needs to execute at the same join point
        (executing method) the ordering rules are as described in <a class="xref" href="aop.html#aop-ataspectj-advice-ordering" title="Advice ordering">the section called &#8220;Advice ordering&#8221;</a>. The precedence between
        aspects is determined by either adding the
        <code class="interfacename">Order</code> annotation to the bean backing
        the aspect or by having the bean implement the
        <code class="interfacename">Ordered</code> interface.</p>
      </div>
    </div>

    <div class="section" title="9.3.4&nbsp;Introductions"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-introductions"></a>9.3.4&nbsp;Introductions</h3></div></div></div>
      

      <p>Introductions (known as inter-type declarations in AspectJ) enable
      an aspect to declare that advised objects implement a given interface,
      and to provide an implementation of that interface on behalf of those
      objects.</p>

      <p>An introduction is made using the
      <code class="literal">aop:declare-parents</code> element inside an
      <code class="literal">aop:aspect</code> This element is used to declare that
      matching types have a new parent (hence the name). For example, given an
      interface <code class="interfacename">UsageTracked</code>, and an
      implementation of that interface
      <code class="classname">DefaultUsageTracked</code>, the following aspect
      declares that all implementors of service interfaces also implement the
      <code class="interfacename">UsageTracked</code> interface. (In order to
      expose statistics via JMX for example.)</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"usageTrackerAspect"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"usageTracking"</span><span class="hl-tag">&gt;</span>

  <span class="hl-tag">&lt;aop:declare-parents</span>
      <span class="hl-attribute">types-matching</span>=<span class="hl-value">"com.xzy.myapp.service.*+"</span>
      <span class="hl-attribute">implement-interface</span>=<span class="hl-value">"com.xyz.myapp.service.tracking.UsageTracked"</span>
      <span class="hl-attribute">default-impl</span>=<span class="hl-value">"com.xyz.myapp.service.tracking.DefaultUsageTracked"</span><span class="hl-tag">/&gt;</span>

  <span class="hl-tag">&lt;aop:before</span>
    <span class="hl-attribute">pointcut</span>=<span class="hl-value">"com.xyz.myapp.SystemArchitecture.businessService()
              and this(usageTracked)"</span>
    <span class="hl-attribute">method</span>=<span class="hl-value">"recordUsage"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/aop:aspect&gt;</span></pre>

      <p>The class backing the <code class="literal">usageTracking</code> bean would
      contain the method:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> recordUsage(UsageTracked usageTracked) {
    usageTracked.incrementUseCount();
}</pre>

      <p>The interface to be implemented is determined by
      <code class="literal">implement-interface</code> attribute. The value of the
      <code class="literal">types-matching</code> attribute is an AspectJ type pattern
      :- any bean of a matching type will implement the
      <code class="interfacename">UsageTracked</code> interface. Note that in the
      before advice of the above example, service beans can be directly used
      as implementations of the <code class="interfacename">UsageTracked</code>
      interface. If accessing a bean programmatically you would write the
      following:</p>

      <pre class="programlisting">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="hl-string">"myService"</span>);</pre>
    </div>

    <div class="section" title="9.3.5&nbsp;Aspect instantiation models"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-instatiation-models"></a>9.3.5&nbsp;Aspect instantiation models</h3></div></div></div>
      

      <p>The only supported instantiation model for schema-defined aspects
      is the singleton model. Other instantiation models may be supported in
      future releases.</p>
    </div>

    <div class="section" title="9.3.6&nbsp;Advisors"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-advisors"></a>9.3.6&nbsp;Advisors</h3></div></div></div>
      

      <p>The concept of "advisors" is brought forward from the AOP support
      defined in Spring 1.2 and does not have a direct equivalent in AspectJ.
      An advisor is like a small self-contained aspect that has a single piece
      of advice. The advice itself is represented by a bean, and must
      implement one of the advice interfaces described in <a class="xref" href="aop-api.html#aop-api-advice-types" title="10.3.2&nbsp;Advice types in Spring">Section&nbsp;10.3.2, &#8220;Advice types in Spring&#8221;</a>. Advisors can take advantage of
      AspectJ pointcut expressions though.</p>

      <p>Spring 2.0 supports the advisor concept with the
      <code class="literal">&lt;aop:advisor&gt;</code> element. You will most commonly
      see it used in conjunction with transactional advice, which also has its
      own namespace support in Spring 2.0. Here's how it looks:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

  <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"businessService"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..))"</span><span class="hl-tag">/&gt;</span>

  <span class="hl-tag">&lt;aop:advisor</span>
      <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"businessService"</span>
      <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"tx-advice"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"tx-advice"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;tx:attributes&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/tx:attributes&gt;</span>
<span class="hl-tag">&lt;/tx:advice&gt;</span></pre>

      <p>As well as the <code class="literal">pointcut-ref</code> attribute used in the
      above example, you can also use the <code class="literal">pointcut</code> attribute
      to define a pointcut expression inline.</p>

      <p>To define the precedence of an advisor so that the advice can
      participate in ordering, use the <code class="literal">order</code> attribute to
      define the <code class="literal">Ordered</code> value of the advisor.</p>

    </div>

    <div class="section" title="9.3.7&nbsp;Example"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-example"></a>9.3.7&nbsp;Example</h3></div></div></div>
      

      <p>Let's see how the concurrent locking failure retry example from
      <a class="xref" href="aop.html#aop-ataspectj-example" title="9.2.7&nbsp;Example">Section&nbsp;9.2.7, &#8220;Example&#8221;</a> looks when rewritten using the
      schema support.</p>

      <p>The execution of business services can sometimes fail due to
      concurrency issues (for example, deadlock loser). If the operation is
      retried, it is quite likely it will succeed next time round. For
      business services where it is appropriate to retry in such conditions
      (idempotent operations that don't need to go back to the user for
      conflict resolution), we'd like to transparently retry the operation to
      avoid the client seeing a
      <code class="classname">PessimisticLockingFailureException</code>. This is a
      requirement that clearly cuts across multiple services in the service
      layer, and hence is ideal for implementing via an aspect.</p>

      <p>Because we want to retry the operation, we'll need to use around
      advice so that we can call proceed multiple times. Here's how the basic
      aspect implementation looks (it's just a regular Java class using the
      schema support):</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ConcurrentOperationExecutor <span class="hl-keyword">implements</span> Ordered {

   <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> DEFAULT_MAX_RETRIES = <span class="hl-number">2</span>;

   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> maxRetries = DEFAULT_MAX_RETRIES;
   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> order = <span class="hl-number">1</span>;

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setMaxRetries(<span class="hl-keyword">int</span> maxRetries) {
      <span class="hl-keyword">this</span>.maxRetries = maxRetries;
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getOrder() {
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.order;
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrder(<span class="hl-keyword">int</span> order) {
      <span class="hl-keyword">this</span>.order = order;
   }

   <span class="hl-keyword">public</span> Object doConcurrentOperation(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
      <span class="hl-keyword">int</span> numAttempts = <span class="hl-number">0</span>;
      PessimisticLockingFailureException lockFailureException;
      <span class="hl-keyword">do</span> {
         numAttempts++;
         <span class="hl-keyword">try</span> {
            <span class="hl-keyword">return</span> pjp.proceed();
         }
         <span class="hl-keyword">catch</span>(PessimisticLockingFailureException ex) {
            lockFailureException = ex;
         }
      }
      <span class="hl-keyword">while</span>(numAttempts &lt;= <span class="hl-keyword">this</span>.maxRetries);
      <span class="hl-keyword">throw</span> lockFailureException;
   }

}</pre>

      <p>Note that the aspect implements the
      <code class="interfacename">Ordered</code> interface so we can set the
      precedence of the aspect higher than the transaction advice (we want a
      fresh transaction each time we retry). The <code class="literal">maxRetries</code>
      and <code class="literal">order</code> properties will both be configured by
      Spring. The main action happens in the
      <code class="literal">doConcurrentOperation</code> around advice method. We try to
      proceed, and if we fail with a
      <code class="classname">PessimisticLockingFailureException</code> we simply try
      again unless we have exhausted all of our retry attempts.</p>

      <p class="remark"><i><span class="remark">This class is identical to the one used in the @AspectJ example,
      but with the annotations removed.</span></i></p>

      <p>The corresponding Spring configuration is:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>

  <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">"concurrentOperationRetry"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"concurrentOperationExecutor"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"idempotentOperation"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..))"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;aop:around</span>
       <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"idempotentOperation"</span>
       <span class="hl-attribute">method</span>=<span class="hl-value">"doConcurrentOperation"</span><span class="hl-tag">/&gt;</span>

  <span class="hl-tag">&lt;/aop:aspect&gt;</span>

<span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"concurrentOperationExecutor"</span>
  <span class="hl-attribute">class</span>=<span class="hl-value">"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxRetries"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"3"</span><span class="hl-tag">/&gt;</span>
     <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"order"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>Notice that for the time being we assume that all business
      services are idempotent. If this is not the case we can refine the
      aspect so that it only retries genuinely idempotent operations, by
      introducing an <code class="interfacename">Idempotent</code>
      annotation:</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></i>
<span class="hl-keyword">public</span> <i><span class="hl-annotation" style="color: gray">@interface</span></i> Idempotent {
  <em class="lineannotation"><span class="lineannotation">// marker annotation</span></em>
}</pre>

      <p>and using the annotation to annotate the implementation of service
      operations. The change to the aspect to retry only idempotent operations
      simply involves refining the pointcut expression so that only
      <code class="interfacename">@Idempotent</code> operations match:</p>

      <pre class="programlisting">  <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"idempotentOperation"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.xyz.myapp.service.*.*(..)) and
                    @annotation(com.xyz.myapp.service.Idempotent)"</span><span class="hl-tag">/&gt;</span></pre>
    </div>
  </div>

  <div class="section" title="9.4&nbsp;Choosing which AOP declaration style to use"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-choosing"></a>9.4&nbsp;Choosing which AOP declaration style to use</h2></div></div></div>
    

    <p>Once you have decided that an aspect is the best approach for
    implementing a given requirement, how do you decide between using Spring
    AOP or AspectJ, and between the Aspect language (code) style, @AspectJ
    annotation style, or the Spring XML style? These decisions are influenced
    by a number of factors including application requirements, development
    tools, and team familiarity with AOP.</p>

    <div class="section" title="9.4.1&nbsp;Spring AOP or full AspectJ?"><div class="titlepage"><div><div><h3 class="title"><a name="aop-spring-or-aspectj"></a>9.4.1&nbsp;Spring AOP or full AspectJ?</h3></div></div></div>
      

      <p>Use the simplest thing that can work. Spring AOP is simpler than
      using full AspectJ as there is no requirement to introduce the AspectJ
      compiler / weaver into your development and build processes. If you only
      need to advise the execution of operations on Spring beans, then Spring
      AOP is the right choice. If you need to advise objects not managed by
      the Spring container (such as domain objects typically), then you will
      need to use AspectJ. You will also need to use AspectJ if you wish to
      advise join points other than simple method executions (for example,
      field get or set join points, and so on).</p>

      <p>When using AspectJ, you have the choice of the AspectJ language
      syntax (also known as the "code style") or the @AspectJ annotation
      style. Clearly, if you are not using Java 5+ then the choice has been
      made for you... use the code style. If aspects play a large role in your
      design, and you are able to use the <a class="ulink" href="http://www.eclipse.org/ajdt/" target="_top">AspectJ Development Tools
      (AJDT)</a> plugin for Eclipse, then the AspectJ language syntax is
      the preferred option: it is cleaner and simpler because the language was
      purposefully designed for writing aspects. If you are not using Eclipse,
      or have only a few aspects that do not play a major role in your
      application, then you may want to consider using the @AspectJ style and
      sticking with a regular Java compilation in your IDE, and adding an
      aspect weaving phase to your build script.</p>
    </div>

    <div class="section" title="9.4.2&nbsp;@AspectJ or XML for Spring AOP?"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ataspectj-or-xml"></a>9.4.2&nbsp;@AspectJ or XML for Spring AOP?</h3></div></div></div>
      

      <p>If you have chosen to use Spring AOP, then you have a choice of
      @AspectJ or XML style. Clearly if you are not running on Java 5+, then
      the XML style is the appropriate choice; for Java 5 projects there are
      various tradeoffs to consider.</p>

      <p>The XML style will be most familiar to existing Spring users. It
      can be used with any JDK level (referring to named pointcuts from within
      pointcut expressions does still require Java 5+ though) and is backed by
      genuine POJOs. When using AOP as a tool to configure enterprise services
      then XML can be a good choice (a good test is whether you consider the
      pointcut expression to be a part of your configuration you might want to
      change independently). With the XML style arguably it is clearer from
      your configuration what aspects are present in the system.</p>

      <p>The XML style has two disadvantages. Firstly it does not fully
      encapsulate the implementation of the requirement it addresses in a
      single place. The DRY principle says that there should be a single,
      unambiguous, authoritative representation of any piece of knowledge
      within a system. When using the XML style, the knowledge of
      <span class="emphasis"><em>how</em></span> a requirement is implemented is split across
      the declaration of the backing bean class, and the XML in the
      configuration file. When using the @AspectJ style there is a single
      module - the aspect - in which this information is encapsulated.
      Secondly, the XML style is slightly more limited in what it can express
      than the @AspectJ style: only the "singleton" aspect instantiation model
      is supported, and it is not possible to combine named pointcuts declared
      in XML. For example, in the @AspectJ style you can write something
      like:</p>

      <pre class="programlisting">  <i><span class="hl-annotation" style="color: gray">@Pointcut(execution(* get*()))</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> propertyAccess() {}

  @Pointcut(execution(org.xyz.Account+ *(..))
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> operationReturningAnAccount() {}

  <i><span class="hl-annotation" style="color: gray">@Pointcut(propertyAccess() &amp;&amp; operationReturningAnAccount())</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> accountPropertyAccess() {}</pre>

      <p>In the XML style I can declare the first two pointcuts:</p>

      <pre class="programlisting">  <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"propertyAccess"</span>
      <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* get*())"</span><span class="hl-tag">/&gt;</span>

  <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"operationReturningAnAccount"</span>
      <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(org.xyz.Account+ *(..))"</span><span class="hl-tag">/&gt;</span></pre>

      <p>The downside of the XML approach is that you cannot define the
      '<code class="literal">accountPropertyAccess</code>' pointcut by combining these
      definitions.</p>

      <p>The @AspectJ style supports additional instantiation models, and
      richer pointcut composition. It has the advantage of keeping the aspect
      as a modular unit. It also has the advantage the @AspectJ aspects can be
      understood (and thus consumed) both by Spring AOP and by AspectJ - so if
      you later decide you need the capabilities of AspectJ to implement
      additional requirements then it is very easy to migrate to an
      AspectJ-based approach. On balance the Spring team prefer the @AspectJ
      style whenever you have aspects that do more than simple "configuration"
      of enterprise services.</p>
    </div>
  </div>

  <div class="section" title="9.5&nbsp;Mixing aspect types"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-mixing-styles"></a>9.5&nbsp;Mixing aspect types</h2></div></div></div>
    

    <p>It is perfectly possible to mix @AspectJ style aspects using the
    autoproxying support, schema-defined <code class="literal">&lt;aop:aspect&gt;</code>
    aspects, <code class="literal">&lt;aop:advisor&gt;</code> declared advisors and even
    proxies and interceptors defined using the Spring 1.2 style in the same
    configuration. All of these are implemented using the same underlying
    support mechanism and will co-exist without any difficulty.</p>
  </div>

  <div class="section" title="9.6&nbsp;Proxying mechanisms"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-proxying"></a>9.6&nbsp;Proxying mechanisms</h2></div></div></div>
    

    <p>Spring AOP uses either JDK dynamic proxies or CGLIB to create the
    proxy for a given target object. (JDK dynamic proxies are preferred
    whenever you have a choice).</p>

    <p>If the target object to be proxied implements at least one interface
    then a JDK dynamic proxy will be used. All of the interfaces implemented
    by the target type will be proxied. If the target object does not
    implement any interfaces then a CGLIB proxy will be created.</p>

    <p>If you want to force the use of CGLIB proxying (for example, to
    proxy every method defined for the target object, not just those
    implemented by its interfaces) you can do so. However, there are some
    issues to consider:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="literal">final</code> methods cannot be advised, as they
        cannot be overridden.</p>
      </li><li class="listitem">
        <p>As of Spring 3.2, it is no longer necessary to add CGLIB to your
        project classpath, as CGLIB classes are repackaged under
        org.springframework and included directly in the spring-core JAR. This
        means that CGLIB-based proxy support 'just works' in the same way that
        JDK dynamic proxies always have.
        </p>
      </li><li class="listitem">
        <p>The constructor of your proxied object will be called twice.
        This is a natural consequence of the CGLIB proxy model whereby a
        subclass is generated for each proxied object. For each proxied
        instance, two objects are created: the actual proxied object and an
        instance of the subclass that implements the advice. This behavior is
        not exhibited when using JDK proxies. Usually, calling the constructor
        of the proxied type twice, is not an issue, as there are usually only
        assignments taking place and no real logic is implemented in the
        constructor.</p>
      </li></ul></div>

    <p><a name="aop-autoproxy-force-CGLIB"></a>To force the use of CGLIB proxies set
    the value of the <code class="literal">proxy-target-class</code> attribute of the
    <code class="literal">&lt;aop:config&gt;</code> element to true:</p>

    
    <pre class="programlisting"><span class="hl-tag">&lt;aop:config</span> <span class="hl-attribute">proxy-target-class</span>=<span class="hl-value">"true"</span><span class="hl-tag">&gt;</span>
    <em class="lineannotation"><span class="lineannotation">&lt;!-- other beans defined here... --&gt;</span></em>
<span class="hl-tag">&lt;/aop:config&gt;</span></pre>

    <p>To force CGLIB proxying when using the @AspectJ autoproxy support,
    set the <code class="literal">'proxy-target-class'</code> attribute of the
    <code class="literal">&lt;aop:aspectj-autoproxy&gt;</code> element to
    <code class="literal">true</code>:</p>

    
    <pre class="programlisting"><span class="hl-tag">&lt;aop:aspectj-autoproxy</span> <span class="hl-attribute">proxy-target-class</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span></pre>

    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      <p>Multiple <code class="literal">&lt;aop:config/&gt;</code> sections are
      collapsed into a single unified auto-proxy creator at runtime, which
      applies the <span class="emphasis"><em>strongest</em></span> proxy settings that any of
      the <code class="literal">&lt;aop:config/&gt;</code> sections (typically from
      different XML bean definition files) specified. This also applies to the
      <code class="literal">&lt;tx:annotation-driven/&gt;</code> and
      <code class="literal">&lt;aop:aspectj-autoproxy/&gt;</code> elements.</p>

      <p>To be clear: using '<code class="literal">proxy-target-class="true"</code>'
      on <code class="literal">&lt;tx:annotation-driven/&gt;</code>,
      <code class="literal">&lt;aop:aspectj-autoproxy/&gt;</code> or
      <code class="literal">&lt;aop:config/&gt;</code> elements will force the use of
      CGLIB proxies <span class="emphasis"><em>for all three of them</em></span>.</p>
    </td></tr></table></div>

    <div class="section" title="9.6.1&nbsp;Understanding AOP proxies"><div class="titlepage"><div><div><h3 class="title"><a name="aop-understanding-aop-proxies"></a>9.6.1&nbsp;Understanding AOP proxies</h3></div></div></div>
      

      <p>Spring AOP is <span class="emphasis"><em>proxy-based</em></span>. It is vitally
      important that you grasp the semantics of what that last statement
      actually means before you write your own aspects or use any of the
      Spring AOP-based aspects supplied with the Spring Framework.</p>

      <p>Consider first the scenario where you have a plain-vanilla,
      un-proxied, nothing-special-about-it, straight object reference, as
      illustrated by the following code snippet.</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimplePojo <span class="hl-keyword">implements</span> Pojo {

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo() {
      <em class="lineannotation"><span class="lineannotation">// this next method invocation is a direct
      call on the 'this' reference</span></em>
      <span class="hl-keyword">this</span>.bar();
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> bar() {
      <em class="lineannotation"><span class="lineannotation">// some logic...</span></em>
   }
}</pre>

      <p>If you invoke a method on an object reference, the method is
      invoked <span class="emphasis"><em>directly</em></span> on that object reference, as can
      be seen below.</p>

      <div class="mediaobject" align="center"><img src="images/aop-proxy-plain-pojo-call.png" align="middle"></div>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Main {

   <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

      Pojo pojo = <span class="hl-keyword">new</span> SimplePojo();

      <em class="lineannotation"><span class="lineannotation">// this is a direct method call on the 'pojo' reference</span></em>
      pojo.foo();
   }
}</pre>

      <p>Things change slightly when the reference that client code has is
      a proxy. Consider the following diagram and code snippet.</p>

      <div class="mediaobject" align="center"><img src="images/aop-proxy-call.png" align="middle"></div>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Main {

   <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

      ProxyFactory factory = <span class="hl-keyword">new</span> ProxyFactory(<span class="hl-keyword">new</span> SimplePojo());
      factory.addInterface(Pojo.<span class="hl-keyword">class</span>);
      factory.addAdvice(<span class="hl-keyword">new</span> RetryAdvice());

      Pojo pojo = (Pojo) factory.getProxy();

      <em class="lineannotation"><span class="lineannotation">// this is a method call on the proxy!</span></em>
      pojo.foo();
   }
}</pre>

      <p>The key thing to understand here is that the client code inside
      the <code class="methodname">main(..)</code> of the <code class="classname">Main</code>
      class <span class="emphasis"><em>has a reference to the proxy</em></span>. This means that
      method calls on that object reference will be calls on the proxy, and as
      such the proxy will be able to delegate to all of the interceptors
      (advice) that are relevant to that particular method call. However, once
      the call has finally reached the target object, the
      <code class="classname">SimplePojo</code> reference in this case, any method
      calls that it may make on itself, such as
      <code class="methodname">this.bar()</code> or
      <code class="methodname">this.foo()</code>, are going to be invoked against the
      <span class="emphasis"><em><code class="literal">this</code></em></span> reference, and
      <span class="emphasis"><em>not</em></span> the proxy. This has important implications. It
      means that self-invocation is <span class="emphasis"><em>not</em></span> going to result
      in the advice associated with a method invocation getting a chance to
      execute.</p>

      <p>Okay, so what is to be done about this? The best approach (the
      term best is used loosely here) is to refactor your code such that the
      self-invocation does not happen. For sure, this does entail some work on
      your part, but it is the best, least-invasive approach. The next
      approach is absolutely horrendous, and I am almost reticent to point it
      out precisely because it is so horrendous. You can (choke!) totally tie
      the logic within your class to Spring AOP by doing this:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimplePojo <span class="hl-keyword">implements</span> Pojo {

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo() {
      <em class="lineannotation"><span class="lineannotation">// this works, but... gah!</span></em>
      ((Pojo) AopContext.currentProxy()).bar();
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> bar() {
      <em class="lineannotation"><span class="lineannotation">// some logic...</span></em>
   }
}</pre>

      <p>This totally couples your code to Spring AOP,
      <span class="emphasis"><em>and</em></span> it makes the class itself aware of the fact
      that it is being used in an AOP context, which flies in the face of AOP.
      It also requires some additional configuration when the proxy is being
      created:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Main {

   <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

      ProxyFactory factory = <span class="hl-keyword">new</span> ProxyFactory(<span class="hl-keyword">new</span> SimplePojo());
      factory.adddInterface(Pojo.<span class="hl-keyword">class</span>);
      factory.addAdvice(<span class="hl-keyword">new</span> RetryAdvice());
      <em class="lineannotation"><span class="lineannotation">factory.setExposeProxy(true);</span></em>

      Pojo pojo = (Pojo) factory.getProxy();

      <em class="lineannotation"><span class="lineannotation">// this is a method call on the proxy!</span></em>
      pojo.foo();
   }
}</pre>

      <p>Finally, it must be noted that AspectJ does not have this
      self-invocation issue because it is not a proxy-based AOP
      framework.</p>
    </div>
  </div>

  <div class="section" title="9.7&nbsp;Programmatic creation of @AspectJ Proxies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-aspectj-programmatic"></a>9.7&nbsp;Programmatic creation of @AspectJ Proxies</h2></div></div></div>
    

    <p>In addition to declaring aspects in your configuration using either
    <code class="literal">&lt;aop:config&gt;</code> or
    <code class="literal">&lt;aop:aspectj-autoproxy&gt;</code>, it is also possible
    programmatically to create proxies that advise target objects. For the
    full details of Spring's AOP API, see the next chapter. Here we want to
    focus on the ability to automatically create proxies using @AspectJ
    aspects.</p>

    <p>The class
    <code class="classname">org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code>
    can be used to create a proxy for a target object that is advised by one
    or more @AspectJ aspects. Basic usage for this class is very simple, as
    illustrated below. See the Javadocs for full information.</p>

    <pre class="programlisting"><em class="lineannotation"><span class="lineannotation">// create a factory that can generate a proxy for the given target object</span></em>
AspectJProxyFactory factory = <span class="hl-keyword">new</span> AspectJProxyFactory(targetObject);

<em class="lineannotation"><span class="lineannotation">// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects</span></em>
factory.addAspect(SecurityManager.<span class="hl-keyword">class</span>);

<em class="lineannotation"><span class="lineannotation">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span></em>
factory.addAspect(usageTracker);

<em class="lineannotation"><span class="lineannotation">// now get the proxy object...</span></em>
MyInterfaceType proxy = factory.getProxy();</pre>
  </div>

  <div class="section" title="9.8&nbsp;Using AspectJ with Spring applications"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-using-aspectj"></a>9.8&nbsp;Using AspectJ with Spring applications</h2></div></div></div>
    

    <p>Everything we've covered so far in this chapter is pure Spring AOP.
    In this section, we're going to look at how you can use the AspectJ
    compiler/weaver instead of, or in addition to, Spring AOP if your needs go
    beyond the facilities offered by Spring AOP alone.</p>

    <p>Spring ships with a small AspectJ aspect library, which is available
    standalone in your distribution as <code class="filename">spring-aspects.jar</code>; you'll need to add this
    to your classpath in order to use the aspects in it. <a class="xref" href="aop.html#aop-atconfigurable" title="9.8.1&nbsp;Using AspectJ to dependency inject domain objects with Spring">Section&nbsp;9.8.1, &#8220;Using AspectJ to dependency inject domain objects with
      Spring&#8221;</a> and <a class="xref" href="aop.html#aop-ajlib-other" title="9.8.2&nbsp;Other Spring aspects for AspectJ">Section&nbsp;9.8.2, &#8220;Other Spring aspects for AspectJ&#8221;</a>
    discuss the content of this library and how you can use it. <a class="xref" href="aop.html#aop-aj-configure" title="9.8.3&nbsp;Configuring AspectJ aspects using Spring IoC">Section&nbsp;9.8.3, &#8220;Configuring AspectJ aspects using Spring IoC&#8221;</a> discusses how to dependency inject AspectJ
    aspects that are woven using the AspectJ compiler. Finally, <a class="xref" href="aop.html#aop-aj-ltw" title="9.8.4&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;9.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;</a> provides an introduction to load-time weaving for
    Spring applications using AspectJ.</p>

    <div class="section" title="9.8.1&nbsp;Using AspectJ to dependency inject domain objects with Spring"><div class="titlepage"><div><div><h3 class="title"><a name="aop-atconfigurable"></a>9.8.1&nbsp;Using AspectJ to dependency inject domain objects with
      Spring</h3></div></div></div>
      

      <p>The Spring container instantiates and configures beans defined in
      your application context. It is also possible to ask a bean factory to
      configure a <span class="emphasis"><em>pre-existing</em></span> object given the name of a
      bean definition containing the configuration to be applied. The
      <code class="filename">spring-aspects.jar</code> contains an
      annotation-driven aspect that exploits this capability to allow
      dependency injection of <span class="emphasis"><em>any object</em></span>. The support is
      intended to be used for objects created <span class="emphasis"><em>outside of the control
      of any container</em></span>. Domain objects often fall into this
      category because they are often created programmatically using the
      <code class="literal">new</code> operator, or by an ORM tool as a result of a
      database query.</p>

      <p>The <code class="interfacename">@Configurable</code> annotation marks
      a class as eligible for Spring-driven configuration. In the simplest
      case it can be used just as a marker annotation:</p>

      <pre class="programlisting"><span class="hl-keyword">package</span> com.xyz.myapp.domain;

<span class="hl-keyword">import</span> org.springframework.beans.factory.annotation.Configurable;

<i><span class="hl-annotation" style="color: gray">@Configurable</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Account {
   <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>

      <p>When used as a marker interface in this way, Spring will configure
      new instances of the annotated type (<code class="classname">Account</code> in
      this case) using a prototype-scoped bean definition with the same name
      as the fully-qualified type name
      (<code class="classname">com.xyz.myapp.domain.Account</code>). Since the default
      name for a bean is the fully-qualified name of its type, a convenient
      way to declare the prototype definition is simply to omit the
      <code class="literal">id</code> attribute:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.xyz.myapp.domain.Account"</span> <span class="hl-attribute">scope</span>=<span class="hl-value">"prototype"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"fundsTransferService"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"fundsTransferService"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>If you want to explicitly specify the name of the prototype bean
      definition to use, you can do so directly in the annotation:</p>

      <pre class="programlisting"><span class="hl-keyword">package</span> com.xyz.myapp.domain;

<span class="hl-keyword">import</span> org.springframework.beans.factory.annotation.Configurable;

<i><span class="hl-annotation" style="color: gray">@Configurable("account")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Account {
   <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>

      <p>Spring will now look for a bean definition named
      "<code class="literal">account</code>" and use that as the definition to configure
      new <code class="classname">Account</code> instances.</p>

      <p>You can also use autowiring to avoid having to specify a
      prototype-scoped bean definition at all. To have Spring apply autowiring
      use the '<code class="literal">autowire</code>' property of the
      <code class="interfacename">@Configurable</code> annotation: specify either
      <code class="literal">@Configurable(autowire=Autowire.BY_TYPE)</code> or
      <code class="literal">@Configurable(autowire=Autowire.BY_NAME</code> for
      autowiring by type or by name respectively. As an alternative, as of
      Spring 2.5 it is preferable to specify explicit, annotation-driven
      dependency injection for your <code class="interfacename">@Configurable</code>
      beans by using <code class="interfacename">@Autowired</code> or
      <code class="interfacename">@Inject</code> at the field or method level (see
      <a class="xref" href="beans.html#beans-annotation-config" title="5.9&nbsp;Annotation-based container configuration">Section&nbsp;5.9, &#8220;Annotation-based container configuration&#8221;</a> for further details).</p>

      <p>Finally you can enable Spring dependency checking for the object
      references in the newly created and configured object by using the
      <code class="literal">dependencyCheck</code> attribute (for example:
      <code class="literal">@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>).
      If this attribute is set to true, then Spring will validate after
      configuration that all properties (<span class="emphasis"><em>which are not primitives or
      collections</em></span>) have been set.</p>

      <p>Using the annotation on its own does nothing of course. It is the
      <code class="classname">AnnotationBeanConfigurerAspect</code> in <code class="filename">spring-aspects.jar</code> that acts on the
      presence of the annotation. In essence the aspect says "after returning
      from the initialization of a new object of a type annotated with
      <code class="interfacename">@Configurable</code>, configure the newly
      created object using Spring in accordance with the properties of the
      annotation". In this context, <span class="emphasis"><em>initialization</em></span> refers
      to newly instantiated objects (e.g., objects instantiated with the
      '<code class="literal">new</code>' operator) as well as to
      <code class="interfacename">Serializable</code> objects that are undergoing
      deserialization (e.g., via <a class="ulink" href="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html" target="_top">readResolve()</a>).</p>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>One of the key phrases in the above paragraph is '<span class="emphasis"><em>in
        essence</em></span>'. For most cases, the exact semantics of
        '<span class="emphasis"><em>after returning from the initialization of a new
        object</em></span>' will be fine... in this context, '<span class="emphasis"><em>after
        initialization</em></span>' means that the dependencies will be
        injected <span class="emphasis"><em>after</em></span> the object has been constructed -
        this means that the dependencies will not be available for use in the
        constructor bodies of the class. If you want the dependencies to be
        injected <span class="emphasis"><em>before</em></span> the constructor bodies execute,
        and thus be available for use in the body of the constructors, then
        you need to define this on the
        <code class="interfacename">@Configurable</code> declaration like
        so:</p>

        <pre class="programlisting">@Configurable(preConstruction=true)</pre>

        <p>You can find out more information about the language semantics
        of the various pointcut types in AspectJ <a class="ulink" href="http://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html" target="_top">in
        this appendix</a> of the <a class="ulink" href="http://www.eclipse.org/aspectj/doc/next/progguide/index.html" target="_top">AspectJ
        Programming Guide</a>.</p>
      </td></tr></table></div>

      <p>For this to work the annotated types must be woven with the
      AspectJ weaver - you can either use a build-time Ant or Maven task to do
      this (see for example the <a class="ulink" href="http://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html" target="_top">AspectJ
      Development Environment Guide</a>) or load-time weaving (see <a class="xref" href="aop.html#aop-aj-ltw" title="9.8.4&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;9.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;</a>). The
      <code class="classname">AnnotationBeanConfigurerAspect</code> itself needs
      configuring by Spring (in order to obtain a reference to the bean
      factory that is to be used to configure new objects). If you are
      using Java based configuration simply add
      <code class="interfacename">@EnableSpringConfigured</code> to any
      <code class="interfacename">@Configuration</code> class.</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Configuration</span></i>
<i><span class="hl-annotation" style="color: gray">@EnableSpringConfigured</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

}</pre>

      <p>If you prefer XML based configuration, the Spring <a class="link" href="xsd-config.html#xsd-config-body-schemas-context" title="E.2.8&nbsp;The context schema"><code class="literal">context</code>
      namespace</a> defines a convenient
      <code class="literal">context:spring-configured</code> element:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;context:spring-configured/&gt;</span></pre>

      <p>If you are using the DTD instead of schema, the equivalent
      definition is:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span>
      <span class="hl-attribute">factory-method</span>=<span class="hl-value">"aspectOf"</span><span class="hl-tag">/&gt;</span></pre>

      <p>Instances of <code class="interfacename">@Configurable</code> objects
      created <span class="emphasis"><em>before</em></span> the aspect has been configured will
      result in a warning being issued to the log and no configuration of the
      object taking place. An example might be a bean in the Spring
      configuration that creates domain objects when it is initialized by
      Spring. In this case you can use the "depends-on" bean attribute to
      manually specify that the bean depends on the configuration
      aspect.</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myService"</span>
  <span class="hl-attribute">class</span>=<span class="hl-value">"com.xzy.myapp.service.MyService"</span>
  <span class="hl-attribute">depends-on</span>=<span class="hl-value">"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span><span class="hl-tag">&gt;</span>

  <em class="lineannotation"><span class="lineannotation">&lt;!-- ... --&gt;</span></em>

<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>Do not activate <code class="interfacename">@Configurable</code>
        processing through the bean configurer aspect unless you really
        mean to rely on its semantics at runtime. In particular, make sure
        that you do not use <code class="interfacename">@Configurable</code>
        on bean classes which are registered as regular Spring beans with
        the container: You would get double initialization otherwise, once
        through the container and once through the aspect.</p>
      </td></tr></table></div>

      <div class="section" title="Unit testing @Configurable objects"><div class="titlepage"><div><div><h4 class="title"><a name="aop-configurable-testing"></a>Unit testing <code class="interfacename">@Configurable</code>
        objects</h4></div></div></div>
        

        <p>One of the goals of the
        <code class="interfacename">@Configurable</code> support is to enable
        independent unit testing of domain objects without the difficulties
        associated with hard-coded lookups. If
        <code class="interfacename">@Configurable</code> types have not been woven
        by AspectJ then the annotation has no affect during unit testing, and
        you can simply set mock or stub property references in the object
        under test and proceed as normal. If
        <code class="interfacename">@Configurable</code> types
        <span class="emphasis"><em>have</em></span> been woven by AspectJ then you can still
        unit test outside of the container as normal, but you will see a
        warning message each time that you construct an
        <code class="interfacename">@Configurable</code> object indicating that it
        has not been configured by Spring.</p>
      </div>

      <div class="section" title="Working with multiple application contexts"><div class="titlepage"><div><div><h4 class="title"><a name="aop-configurable-container"></a>Working with multiple application contexts</h4></div></div></div>
        

        <p>The <code class="classname">AnnotationBeanConfigurerAspect</code> used
        to implement the <code class="interfacename">@Configurable</code> support
        is an AspectJ singleton aspect. The scope of a singleton aspect is the
        same as the scope of <code class="literal">static</code> members, that is to say
        there is one aspect instance per classloader that defines the type.
        This means that if you define multiple application contexts within the
        same classloader hierarchy you need to consider where to define the
        <code class="interfacename">@EnableSpringConfigured</code> bean and where to
        place <code class="filename">spring-aspects.jar</code> on
        the classpath.</p>

        <p>Consider a typical Spring web-app configuration with a shared
        parent application context defining common business services and
        everything needed to support them, and one child application context
        per servlet containing definitions particular to that servlet. All of
        these contexts will co-exist within the same classloader hierarchy,
        and so the <code class="literal">AnnotationBeanConfigurerAspect</code> can only
        hold a reference to one of them. In this case we recommend defining
        the <code class="interfacename">@EnableSpringConfigured</code> bean in the
        shared (parent) application context: this defines the services that
        you are likely to want to inject into domain objects. A consequence is
        that you cannot configure domain objects with references to beans
        defined in the child (servlet-specific) contexts using the
        @Configurable mechanism (probably not something you want to do
        anyway!).</p>

        <p>When deploying multiple web-apps within the same container,
        ensure that each web-application loads the types in <code class="filename">spring-aspects.jar</code> using its own
        classloader (for example, by placing <code class="filename">spring-aspects.jar</code> in <code class="filename">'WEB-INF/lib'</code>). If <code class="filename">spring-aspects.jar</code> is only added to the
        container wide classpath (and hence loaded by the shared parent
        classloader), all web applications will share the same aspect instance
        which is probably not what you want.</p>
      </div>
    </div>

    <div class="section" title="9.8.2&nbsp;Other Spring aspects for AspectJ"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ajlib-other"></a>9.8.2&nbsp;Other Spring aspects for AspectJ</h3></div></div></div>
      

      <p>In addition to the <code class="interfacename">@Configurable</code>
      aspect, <code class="filename">spring-aspects.jar</code>
      contains an AspectJ aspect that can be used to drive Spring's
      transaction management for types and methods annotated with the
      <code class="interfacename">@Transactional</code> annotation. This is
      primarily intended for users who want to use the Spring Framework's
      transaction support outside of the Spring container.</p>

      <p>The aspect that interprets
      <code class="interfacename">@Transactional</code> annotations is the
      <code class="classname">AnnotationTransactionAspect</code>. When using this
      aspect, you must annotate the <span class="emphasis"><em>implementation</em></span> class
      (and/or methods within that class), <span class="emphasis"><em>not</em></span> the
      interface (if any) that the class implements. AspectJ follows Java's
      rule that annotations on interfaces are <span class="emphasis"><em>not
      inherited</em></span>.</p>

      <p>A <code class="interfacename">@Transactional</code> annotation on a
      class specifies the default transaction semantics for the execution of
      any <span class="emphasis"><em>public</em></span> operation in the class.</p>

      <p>A <code class="interfacename">@Transactional</code> annotation on a
      method within the class overrides the default transaction semantics
      given by the class annotation (if present). Methods with
      <code class="literal">public</code>, <code class="literal">protected</code>, and default
      visibility may all be annotated. Annotating <code class="literal">protected</code>
      and default visibility methods directly is the only way to get
      transaction demarcation for the execution of such methods.</p>

      <p>For AspectJ programmers that want to use the Spring configuration
      and transaction management support but don't want to (or cannot) use
      annotations, <code class="filename">spring-aspects.jar</code>
      also contains <code class="literal">abstract</code> aspects you can extend to
      provide your own pointcut definitions. See the sources for the
      <code class="classname">AbstractBeanConfigurerAspect</code> and
      <code class="classname">AbstractTransactionAspect</code> aspects for more
      information. As an example, the following excerpt shows how you could
      write an aspect to configure all instances of objects defined in the
      domain model using prototype bean definitions that match the
      fully-qualified class names:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> aspect DomainObjectConfiguration <span class="hl-keyword">extends</span> AbstractBeanConfigurerAspect {

  <span class="hl-keyword">public</span> DomainObjectConfiguration() {
    setBeanWiringInfoResolver(<span class="hl-keyword">new</span> ClassNameBeanWiringInfoResolver());
  }

  <em class="lineannotation"><span class="lineannotation">// the creation of a new bean (any object in the domain model)</span></em>
  <span class="hl-keyword">protected</span> pointcut beanCreation(Object beanInstance) :
    initialization(<span class="hl-keyword">new</span>(..)) &amp;&amp;
    SystemArchitecture.inDomainModel() &amp;&amp;
    <span class="hl-keyword">this</span>(beanInstance);

}</pre>
    </div>

    <div class="section" title="9.8.3&nbsp;Configuring AspectJ aspects using Spring IoC"><div class="titlepage"><div><div><h3 class="title"><a name="aop-aj-configure"></a>9.8.3&nbsp;Configuring AspectJ aspects using Spring IoC</h3></div></div></div>
      

      <p>When using AspectJ aspects with Spring applications, it is natural
      to both want and expect to be able to configure such aspects using
      Spring. The AspectJ runtime itself is responsible for aspect creation,
      and the means of configuring the AspectJ created aspects via Spring
      depends on the AspectJ instantiation model (the
      '<code class="literal">per-xxx</code>' clause) used by the aspect.</p>

      <p>The majority of AspectJ aspects are <span class="emphasis"><em>singleton</em></span>
      aspects. Configuration of these aspects is very easy: simply create a
      bean definition referencing the aspect type as normal, and include the
      bean attribute <code class="literal">'factory-method="aspectOf"'</code>. This
      ensures that Spring obtains the aspect instance by asking AspectJ for it
      rather than trying to create an instance itself. For example:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"profiler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.xyz.profiler.Profiler"</span>
      <span class="bold"><strong>factory-method="aspectOf"</strong></span>&gt;
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"profilingStrategy"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"jamonProfilingStrategy"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

      <p>Non-singleton aspects are harder to configure: however it is
      possible to do so by creating prototype bean definitions and using the
      <code class="interfacename">@Configurable</code> support from <code class="filename">spring-aspects.jar</code> to configure the
      aspect instances once they have bean created by the AspectJ
      runtime.</p>

      <p>If you have some @AspectJ aspects that you want to weave with
      AspectJ (for example, using load-time weaving for domain model types)
      and other @AspectJ aspects that you want to use with Spring AOP, and
      these aspects are all configured using Spring, then you will need to
      tell the Spring AOP @AspectJ autoproxying support which exact subset of
      the @AspectJ aspects defined in the configuration should be used for
      autoproxying. You can do this by using one or more
      <code class="literal">&lt;include/&gt;</code> elements inside the
      <code class="literal">&lt;aop:aspectj-autoproxy/&gt;</code> declaration. Each
      <code class="literal">&lt;include/&gt;</code> element specifies a name pattern,
      and only beans with names matched by at least one of the patterns will
      be used for Spring AOP autoproxy configuration:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;aop:aspectj-autoproxy&gt;</span>
  <span class="hl-tag">&lt;aop:include</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thisBean"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;aop:include</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thatBean"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/aop:aspectj-autoproxy&gt;</span></pre>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>Do not be misled by the name of the
        <code class="literal">&lt;aop:aspectj-autoproxy/&gt;</code> element: using it
        will result in the creation of <span class="emphasis"><em>Spring AOP
        proxies</em></span>. The @AspectJ style of aspect declaration is just
        being used here, but the AspectJ runtime is <span class="emphasis"><em>not</em></span>
        involved.</p>
      </td></tr></table></div>
    </div>

    <div class="section" title="9.8.4&nbsp;Load-time weaving with AspectJ in the Spring Framework"><div class="titlepage"><div><div><h3 class="title"><a name="aop-aj-ltw"></a>9.8.4&nbsp;Load-time weaving with AspectJ in the Spring Framework</h3></div></div></div>
      

      <p>Load-time weaving (LTW) refers to the process of weaving AspectJ
      aspects into an application's class files as they are being loaded into
      the Java virtual machine (JVM). The focus of this section is on
      configuring and using LTW in the specific context of the Spring
      Framework: this section is not an introduction to LTW though. For full
      details on the specifics of LTW and configuring LTW with just AspectJ
      (with Spring not being involved at all), see the <a class="ulink" href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html" target="_top">LTW
      section of the AspectJ Development Environment Guide</a>.</p>

      <p>The value-add that the Spring Framework brings to AspectJ LTW is
      in enabling much finer-grained control over the weaving process.
      'Vanilla' AspectJ LTW is effected using a Java (5+) agent, which is
      switched on by specifying a VM argument when starting up a JVM. It is
      thus a JVM-wide setting, which may be fine in some situations, but often
      is a little too coarse. Spring-enabled LTW enables you to switch on LTW
      on a <span class="emphasis"><em>per-<code class="classname">ClassLoader</code></em></span> basis,
      which obviously is more fine-grained and which can make more sense in a
      'single-JVM-multiple-application' environment (such as is found in a
      typical application server environment).</p>

      <p>Further, <a class="link" href="aop.html#aop-aj-ltw-environments" title="Environment-specific configuration">in certain
      environments</a>, this support enables load-time weaving
      <span class="emphasis"><em>without making any modifications to the application server's
      launch script</em></span> that will be needed to add
      <code class="literal">-javaagent:path/to/aspectjweaver.jar</code> or (as we describe later in this
      section) <code class="literal">-javaagent:path/to/org.springframework.instrument-{version}.jar</code>
      (previously named <code class="literal">spring-agent.jar</code>). Developers simply modify
      one or more files that form the application context to enable load-time
      weaving instead of relying on administrators who typically are in charge
      of the deployment configuration such as the launch script.</p>

      <p>Now that the sales pitch is over, let us first walk through a
      quick example of AspectJ LTW using Spring, followed by detailed
      specifics about elements introduced in the following example. For a
      complete example, please see the Petclinic <a class="link" href="new-in-3.0.html#new-in-3.0-samples">sample</a> application.</p>

      <div class="section" title="A first example"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-first-example"></a>A first example</h4></div></div></div>
        

        <p>Let us assume that you are an application developer who has been
        tasked with diagnosing the cause of some performance problems in a
        system. Rather than break out a profiling tool, what we are going to
        do is switch on a simple profiling aspect that will enable us to very
        quickly get some performance metrics, so that we can then apply a
        finer-grained profiling tool to that specific area immediately
        afterwards.</p>

        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p>The example presented here uses XML style configuration, it is
          also possible to configure and use @AspectJ with
          <a class="link" href="beans.html#beans-java" title="5.12&nbsp;Java-based container configuration">Java Configuration</a>.
          Specifically the <code class="interfacename">@EnableLoadTimeWeaving</code>
          annotation can be used as an alternative to
          <code class="literal">&lt;context:load-time-weaver/&gt;</code>
          (see <a class="link" href="aop.html#aop-aj-ltw-spring" title="Spring configuration">below</a> for details).</p>
        </td></tr></table></div>

        <p>Here is the profiling aspect. Nothing too fancy, just a
        quick-and-dirty time-based profiler, using the @AspectJ-style of
        aspect declaration.</p>

        <pre class="programlisting"><span class="hl-keyword">package</span> foo;

<span class="hl-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Aspect;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Around;
<span class="hl-keyword">import</span> org.aspectj.lang.annotation.Pointcut;
<span class="hl-keyword">import</span> org.springframework.util.StopWatch;
<span class="hl-keyword">import</span> org.springframework.core.annotation.Order;

<i><span class="hl-annotation" style="color: gray">@Aspect</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProfilingAspect {

    <i><span class="hl-annotation" style="color: gray">@Around("methodsToBeProfiled()")</span></i>
    <span class="hl-keyword">public</span> Object profile(ProceedingJoinPoint pjp) <span class="hl-keyword">throws</span> Throwable {
        StopWatch sw = <span class="hl-keyword">new</span> StopWatch(getClass().getSimpleName());
        <span class="hl-keyword">try</span> {
            sw.start(pjp.getSignature().getName());
            <span class="hl-keyword">return</span> pjp.proceed();
        } <span class="hl-keyword">finally</span> {
            sw.stop();
            System.out.println(sw.prettyPrint());
        }
    }

    <i><span class="hl-annotation" style="color: gray">@Pointcut("execution(public * foo..*.*(..))")</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> methodsToBeProfiled(){}
}
</pre>

        <p>We will also need to create an
        '<code class="filename">META-INF/aop.xml</code>' file, to inform the AspectJ
        weaver that we want to weave our
        <code class="classname">ProfilingAspect</code> into our classes. This file
        convention, namely the presence of a file (or files) on the Java
        classpath called ' <code class="filename">META-INF/aop.xml</code>' is standard
        AspectJ.</p>

        <pre class="programlisting"><b class="hl-tag" style="color: blue">&lt;!DOCTYPE aspectj PUBLIC
        "-//AspectJ//DTD//EN" "http://www.eclipse.org/aspectj/dtd/aspectj.dtd"&gt;</b>
<span class="hl-tag">&lt;aspectj&gt;</span>

    <span class="hl-tag">&lt;weaver&gt;</span>

        <em class="lineannotation"><span class="lineannotation">&lt;!-- only weave classes in our application-specific packages --&gt;</span></em>
        <span class="hl-tag">&lt;include</span> <span class="hl-attribute">within</span>=<span class="hl-value">"foo.*"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;/weaver&gt;</span>

    <span class="hl-tag">&lt;aspects&gt;</span>

        <em class="lineannotation"><span class="lineannotation">&lt;!-- weave in just this aspect --&gt;</span></em>
        <span class="hl-tag">&lt;aspect</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo.ProfilingAspect"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;/aspects&gt;</span>

  <span class="hl-tag">&lt;/aspectj&gt;</span></pre>

        <p>Now to the Spring-specific portion of the configuration. We need
        to configure a <code class="interfacename">LoadTimeWeaver</code> (all
        explained later, just take it on trust for now). This load-time weaver
        is the essential component responsible for weaving the aspect
        configuration in one or more '<code class="filename">META-INF/aop.xml</code>'
        files into the classes in your application. The good thing is that it
        does not require a lot of configuration, as can be seen below (there
        are some more options that you can specify, but these are detailed
        later).</p>

        <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="hl-tag">&gt;</span>

    <em class="lineannotation"><span class="lineannotation">&lt;!-- a service object; we will be profiling its methods --&gt;</span></em>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"entitlementCalculationService"</span>
          <span class="hl-attribute">class</span>=<span class="hl-value">"foo.StubEntitlementCalculationService"</span><span class="hl-tag">/&gt;</span>

    <em class="lineannotation"><span class="lineannotation">&lt;!-- this switches on the load-time weaving --&gt;</span></em>
    <span class="bold"><strong>&lt;context:load-time-weaver/&gt;</strong></span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

        <p>Now that all the required artifacts are in place - the aspect,
        the '<code class="filename">META-INF/aop.xml</code>' file, and the Spring
        configuration -, let us create a simple driver class with a
        <code class="methodname">main(..)</code> method to demonstrate the LTW in
        action.</p>

        <pre class="programlisting"><span class="hl-keyword">package</span> foo;

<span class="hl-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> Main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

        ApplicationContext ctx = <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-string">"beans.xml"</span>, Main.<span class="hl-keyword">class</span>);

        EntitlementCalculationService entitlementCalculationService
            = (EntitlementCalculationService) ctx.getBean(<span class="hl-string">"entitlementCalculationService"</span>);

        <em class="lineannotation"><span class="lineannotation">// the profiling aspect is 'woven' around this method execution</span></em>
        entitlementCalculationService.calculateEntitlement();
    }
}</pre>

        <p>There is one last thing to do. The introduction to this section
        did say that one could switch on LTW selectively on a
        per-<code class="classname">ClassLoader</code> basis with Spring, and this is
        true. However, just for this example, we are going to use a Java agent
        (supplied with Spring) to switch on the LTW. This is the command line
        we will use to run the above <code class="classname">Main</code> class:</p>

        <pre class="programlisting">java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main</pre>

        <p>The '<code class="literal">-javaagent</code>' is a Java 5+ flag for
        specifying and enabling <a class="ulink" href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/instrument/package-summary.html" target="_top">agents
        to instrument programs running on the JVM</a>. The Spring
        Framework ships with such an agent, the
        <code class="classname">InstrumentationSavingAgent</code>, which is packaged
        in the <code class="filename">spring-instrument.jar</code>
        that
        was supplied as the value of the <code class="literal">-javaagent</code>
        argument in the above example.</p>

        <p>The output from the execution of the <code class="classname">Main</code>
        program will look something like that below. (I have introduced a
        <code class="methodname">Thread.sleep(..)</code> statement into the
        <code class="methodname">calculateEntitlement()</code> implementation so that
        the profiler actually captures something other than 0 milliseconds -
        the <code class="literal">01234</code> milliseconds is <span class="emphasis"><em>not</em></span>
        an overhead introduced by the AOP :) )</p>

        <pre class="programlisting">Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement</pre>

        <p>Since this LTW is effected using full-blown AspectJ, we are not
        just limited to advising Spring beans; the following slight variation
        on the <code class="classname">Main</code> program will yield the same
        result.</p>

        <pre class="programlisting"><span class="hl-keyword">package</span> foo;

<span class="hl-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> Main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {

        <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-string">"beans.xml"</span>, Main.<span class="hl-keyword">class</span>);

        EntitlementCalculationService entitlementCalculationService =
            <span class="hl-keyword">new</span> StubEntitlementCalculationService();

        <em class="lineannotation"><span class="lineannotation">// the profiling aspect will be 'woven' around this method execution</span></em>
        entitlementCalculationService.calculateEntitlement();
    }
}</pre>

        <p>Notice how in the above program we are simply bootstrapping the
        Spring container, and then creating a new instance of the
        <code class="classname">StubEntitlementCalculationService</code> totally
        outside the context of Spring... the profiling advice still gets woven
        in.</p>

        <p>The example admittedly is simplistic... however the basics of
        the LTW support in Spring have all been introduced in the above
        example, and the rest of this section will explain the 'why' behind
        each bit of configuration and usage in detail.</p>

        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p>The <code class="classname">ProfilingAspect</code> used in this
          example may be basic, but it is quite useful. It is a nice example
          of a development-time aspect that developers can use during
          development (of course), and then quite easily exclude from builds
          of the application being deployed into UAT or production.</p>
        </td></tr></table></div>
      </div>

      <div class="section" title="Aspects"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-the-aspects"></a>Aspects</h4></div></div></div>
        

        <p>The aspects that you use in LTW have to be AspectJ aspects. They
        can be written in either the AspectJ language itself or you can write
        your aspects in the @AspectJ-style. The latter option is of course
        only an option if you are using Java 5+, but it does mean that your
        aspects are then both valid AspectJ <span class="emphasis"><em>and</em></span> Spring
        AOP aspects. Furthermore, the compiled aspect classes need to be
        available on the classpath.</p>
      </div>

      <div class="section" title="'META-INF/aop.xml'"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-aop_dot_xml"></a>'<code class="filename">META-INF/aop.xml</code>'</h4></div></div></div>
        

        <p>The AspectJ LTW infrastructure is configured using one or more
        '<code class="filename">META-INF/aop.xml</code>' files, that are on the Java
        classpath (either directly, or more typically in jar files).</p>

        <p>The structure and contents of this file is detailed in the main
        AspectJ reference documentation, and the interested reader is <a class="ulink" href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html" target="_top">referred
        to that resource</a>. (I appreciate that this section is brief,
        but the '<code class="filename">aop.xml</code>' file is 100% AspectJ - there is
        no Spring-specific information or semantics that apply to it, and so
        there is no extra value that I can contribute either as a result), so
        rather than rehash the quite satisfactory section that the AspectJ
        developers wrote, I am just directing you there.)</p>
      </div>

      <div class="section" title="Required libraries (JARS)"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-libraries"></a>Required libraries (JARS)</h4></div></div></div>
        

        <p>At a minimum you will need the following libraries to use the
        Spring Framework's support for AspectJ LTW:</p>

        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            <p><code class="filename">spring-aop.jar</code> (version
            2.5 or later, plus all mandatory dependencies)</p>
          </li><li class="listitem">
            <p><code class="filename">aspectjweaver.jar</code>
            (version 1.6.8 or later)</p>
          </li></ol></div>

        <p>If you are using the <a class="link" href="aop.html#aop-aj-ltw-environment-generic" title="Generic Java applications">Spring-provided agent to
        enable instrumentation</a>, you will also need:</p>

        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            <p><code class="filename">spring-instrument.jar</code></p>
          </li></ol></div>
      </div>

      <div class="section" title="Spring configuration"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-spring"></a>Spring configuration</h4></div></div></div>
        

        <p>The key component in Spring's LTW support is the
        <code class="interfacename">LoadTimeWeaver</code> interface (in the
        <code class="literal">org.springframework.instrument.classloading</code>
        package), and the numerous implementations of it that ship with the
        Spring distribution. A <code class="interfacename">LoadTimeWeaver</code>
        is responsible for adding one or more
        <code class="classname">java.lang.instrument.ClassFileTransformers</code> to a
        <code class="classname">ClassLoader</code> at runtime, which opens the door to
        all manner of interesting applications, one of which happens to be the
        LTW of aspects.</p>

        <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
          <p>If you are unfamiliar with the idea of runtime class file
          transformation, you are encouraged to read the Javadoc API
          documentation for the <code class="literal">java.lang.instrument</code>
          package before continuing. This is not a huge chore because there is
          - rather annoyingly - precious little documentation there... the key
          interfaces and classes will at least be laid out in front of you for
          reference as you read through this section.</p>
        </td></tr></table></div>

        <p>Configuring a <code class="interfacename">LoadTimeWeaver</code>
        for a particular
        <code class="interfacename">ApplicationContext</code> can be as easy as
        adding one line. (Please note that you almost certainly will need to
        be using an <code class="interfacename">ApplicationContext</code> as your
        Spring container - typically a
        <code class="interfacename">BeanFactory</code> will not be enough because
        the LTW support makes use of
        <code class="interfacename">BeanFactoryPostProcessors</code>.)</p>

        <p>To enable the Spring Framework's LTW support, you need to
        configure a <code class="interfacename">LoadTimeWeaver</code>, which
        typically is done using the
        <code class="interfacename">@EnableLoadTimeWeaving</code> annotation.</p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Configuration</span></i>
<i><span class="hl-annotation" style="color: gray">@EnableLoadTimeWeaving</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

}</pre>

        <p>Alternatively, if you prefer XML based configuration, use the
        <code class="literal">&lt;context:load-time-weaver/&gt;</code> element. Note
        that the element is defined in the '<code class="literal">context</code>' namespace.</p>

        <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;context:load-time-weaver/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

        <p>The above configuration will define and register a number of
        LTW-specific infrastructure beans for you automatically, such
        as a <code class="interfacename">LoadTimeWeaver</code> and an
        <code class="classname">AspectJWeavingEnabler</code>.  The default
        <code class="interfacename">LoadTimeWeaver</code> is the
        <code class="classname">DefaultContextLoadTimeWeaver</code> class, which
        attempts to decorate an automatically detected
        <code class="interfacename">LoadTimeWeaver</code>: the exact type of
        <code class="interfacename">LoadTimeWeaver</code> that will be
        'automatically detected' is dependent upon your runtime environment
        (summarized in the following table).</p>

        <div class="table"><a name="aop-aj-ltw-spring-env-impls"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;<code class="classname">DefaultContextLoadTimeWeaver</code>
          <code class="interfacename">LoadTimeWeavers</code></b></p><div class="table-contents">
          

          <table summary="DefaultContextLoadTimeWeaver&#xA;          LoadTimeWeavers" width="100%" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Runtime Environment</th><th style="border-bottom: 0.5pt solid ; "><code class="interfacename">LoadTimeWeaver</code> implementation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><p>Running in <a class="ulink" href="http://www.bea.com/framework.jsp?CNT=index.htm&amp;FP=/content/products/weblogic/server" target="_top">BEA's
                Weblogic 10</a></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="classname">WebLogicLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><p>Running in <a class="ulink" href="http://www-01.ibm.com/software/webservers/appserv/was/" target="_top">IBM WebSphere Application Server 7</a></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="classname">WebSphereLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><p>Running in <a class="ulink" href="http://www.oracle.com/technology/products/oc4j/index.html" target="_top">Oracle's
                OC4J</a></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="classname">OC4JLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><p>Running in <a class="ulink" href="http://glassfish.dev.java.net/" target="_top">GlassFish</a></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="classname">GlassFishLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><p>Running in <a class="ulink" href="http://www.jboss.org/jbossas/" target="_top">JBoss AS</a></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="classname">JBossLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><p>JVM started with Spring
                <code class="classname">InstrumentationSavingAgent</code></p>
                <p><span class="emphasis"><em><code class="literal">(java
                -javaagent:path/to/spring-instrument.jar)</code></em></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="classname">InstrumentationLoadTimeWeaver</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left"><p>Fallback, expecting the underlying ClassLoader to follow common conventions
                (e.g. applicable to <code class="classname">TomcatInstrumentableClassLoader</code> and
                <a class="ulink" href="http://www.caucho.com/" target="_top">Resin</a>)</p></td><td style=""><p><code class="classname">ReflectiveLoadTimeWeaver</code></p></td></tr></tbody></table>
        </div></div><br class="table-break">

        <p>Note that these are just the
        <code class="interfacename">LoadTimeWeavers</code> that are autodetected
        when using the <code class="classname">DefaultContextLoadTimeWeaver</code>: it
        is of course possible to specify exactly which
        <code class="interfacename">LoadTimeWeaver</code> implementation that you
        wish to use.</p>

        <p>To specify a specific <code class="interfacename">LoadTimeWeaver</code>
        with Java configuration implement the
        <code class="interfacename">LoadTimeWeavingConfigurer</code> interface and override
        the <code class="literal">getLoadTimeWeaver()</code> method:</p>

        <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Configuration</span></i>
<i><span class="hl-annotation" style="color: gray">@EnableLoadTimeWeaving</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig <span class="hl-keyword">implements</span> LoadTimeWeavingConfigurer {
    <i><span class="hl-annotation" style="color: gray">@Override</span></i>
    <span class="hl-keyword">public</span> LoadTimeWeaver getLoadTimeWeaver() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> ReflectiveLoadTimeWeaver();
    }
}</pre>

        <p>If you are using XML based configuration you can specify the fully-qualified
        classname as the value of the '<code class="literal">weaver-class</code>' attribute on the
        <code class="literal">&lt;context:load-time-weaver/&gt;</code> element:</p>

        <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;context:load-time-weaver</span>
            <span class="hl-attribute">weaver-class</span>=<span class="hl-value">"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

        <p>The <code class="interfacename">LoadTimeWeaver</code> that is
        defined and registered by the configuration can be
        later retrieved from the Spring container using the well-known name
        '<code class="literal">loadTimeWeaver</code>'. Remember that the
        <code class="interfacename">LoadTimeWeaver</code> exists just as a
        mechanism for Spring's LTW infrastructure to add one or more
        <code class="interfacename">ClassFileTransformers</code>. The actual
        <code class="classname">ClassFileTransformer</code> that does the LTW is the
        <code class="classname">ClassPreProcessorAgentAdapter</code> (from the
        <code class="literal">org.aspectj.weaver.loadtime</code> package) class. See the
        class-level Javadoc for the
        <code class="classname">ClassPreProcessorAgentAdapter</code> class for further
        details, because the specifics of how the weaving is actually effected
        is beyond the scope of this section.</p>

        <p>There is one final attribute of the configuration left to discuss:
        the '<code class="literal">aspectjWeaving</code>' attribute
        (or '<code class="literal">aspectj-weaving</code>' if you are using XML). This is a simple
        attribute that controls whether LTW is enabled or not, it is as simple
        as that. It accepts one of three possible values, summarized below,
        with the default value if the attribute is not present being
        '<code class="literal">autodetect</code>'</p>

        <div class="table"><a name="aop-aj-ltw-ltw-tag-attrs"></a><p class="title"><b>Table&nbsp;9.2.&nbsp;AspectJ weaving attribute values</b></p><div class="table-contents">
          

          <table summary="AspectJ weaving attribute values" width="100%" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Annotation Value</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">XML Value</th><th style="border-bottom: 0.5pt solid ; ">Explanation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><p><code class="literal">ENABLED</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">on</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>AspectJ weaving is on, and aspects will be woven
                at load-time as appropriate.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left"><p><code class="literal">DISABLED</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">off</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>LTW is off... no aspect will be woven at
                load-time.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left"><p><code class="literal">AUTODETECT</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">autodetect</code></p></td><td style=""><p>If the Spring LTW infrastructure can find at
                least one '<code class="filename">META-INF/aop.xml</code>' file, then
                AspectJ weaving is on, else it is off. This is the default
                value.</p></td></tr></tbody></table>
        </div></div><br class="table-break">
      </div>

      <div class="section" title="Environment-specific configuration"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-environments"></a>Environment-specific configuration</h4></div></div></div>
        

        <p>This last section contains any additional settings and
        configuration that you will need when using Spring's LTW support in
        environments such as application servers and web containers.</p>

        <div class="section" title="Tomcat"><div class="titlepage"><div><div><h5 class="title"><a name="aop-aj-ltw-environment-tomcat"></a>Tomcat</h5></div></div></div>
          

          <p><a class="ulink" href="http://tomcat.apache.org/" target="_top">Apache Tomcat</a>'s default class loader
          does not support class transformation which is why Spring provides an enhanced implementation that
          addresses this need. Named <code class="classname">TomcatInstrumentableClassLoader</code>, the loader works
          on Tomcat 5.0 and above and can be registered individually for <span class="emphasis"><em>each</em></span> web application
          as follows:</p>

          <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <p>Tomcat 6.0.x or higher</p>

            <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>Copy <code class="literal">org.springframework.instrument.tomcat.jar</code>
                into <span class="emphasis"><em>$CATALINA_HOME</em></span>/lib, where
                <span class="emphasis"><em>$CATALINA_HOME</em></span> represents the root of the
                Tomcat installation)</p>
              </li><li class="listitem">
                <p>Instruct Tomcat to use the custom class loader (instead
                of the default) by editing the web application context
                file:</p>

                <pre class="programlisting"><span class="hl-tag">&lt;Context</span> <span class="hl-attribute">path</span>=<span class="hl-value">"/myWebApp"</span> <span class="hl-attribute">docBase</span>=<span class="hl-value">"/my/webApp/location"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;Loader</span>
        <span class="hl-attribute">loaderClass</span>=<span class="hl-value">"org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/Context&gt;</span></pre>

                <p>Apache Tomcat 6.0.x (similar to 5.0.x/5.5.x) series supports several context locations:</p>
                    <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>server configuration file - <span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span></p></li><li class="listitem"><p>default context configuration - <span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span> - that
                        affects all deployed web applications</p></li><li class="listitem"><p>per-web application configuration which can be deployed either on the server-side at
                        <span class="emphasis"><em>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</em></span> or embedded inside
                        the web-app archive at <span class="emphasis"><em>META-INF/context.xml</em></span></p></li></ul></div>
                <p>For efficiency, the embedded per-web-app configuration style is
                recommended because it will impact only applications that use
                the custom class loader and does not require any changes to the server configuration.
                See the Tomcat 6.0.x <a class="ulink" href="http://tomcat.apache.org/tomcat-6.0-doc/config/context.html" target="_top">documentation</a>
                for more details about available context locations.</p>
              </li></ol></div>
            </li><li class="listitem">
              <p>Tomcat 5.0.x/5.5.x</p>

            <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>Copy <code class="literal">org.springframework.instrument.tomcat.jar</code>
                into <span class="emphasis"><em>$CATALINA_HOME</em></span>/server/lib, where
                <span class="emphasis"><em>$CATALINA_HOME</em></span> represents the root of the
                Tomcat installation.</p>
              </li><li class="listitem">
                <p>Instruct Tomcat to use the custom class loader instead
                of the default one by editing the web application context
                file:</p>

                <pre class="programlisting"><span class="hl-tag">&lt;Context</span> <span class="hl-attribute">path</span>=<span class="hl-value">"/myWebApp"</span> <span class="hl-attribute">docBase</span>=<span class="hl-value">"/my/webApp/location"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;Loader</span>
        <span class="hl-attribute">loaderClass</span>=<span class="hl-value">"org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/Context&gt;</span></pre>

                <p>Tomcat 5.0.x and 5.5.x series supports several context locations:</p>
                    <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>server configuration file - <span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span></p></li><li class="listitem"><p>default context configuration - <span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span> - that
                        affects all deployed web applications</p></li><li class="listitem"><p>per-web application configuration which can be deployed either on the server-side at
                        <span class="emphasis"><em>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</em></span> or embedded inside
                        the web-app archive at <span class="emphasis"><em>META-INF/context.xml</em></span></p></li></ul></div>
                <p>For efficiency, the embedded web-app configuration style is recommended
                recommended because it will impact only applications that use the class loader. See the Tomcat 5.x <a class="ulink" href="http://tomcat.apache.org/tomcat-5.5-doc/config/context.html" target="_top">documentation</a>
                for more details about available context locations.</p>

                <p>Tomcat versions prior to 5.5.20 contained a bug in the
                XML configuration parsing that prevented usage of the
                <code class="literal">Loader</code> tag inside
                <span class="emphasis"><em>server.xml</em></span> configuration, regardless of whether a class
                loader is specified or whether it is the official or a custom
                one. See Tomcat's bugzilla for <a class="ulink" href="http://issues.apache.org/bugzilla/show_bug.cgi?id=39704" target="_top">more
                details</a>.</p>

                <p>In Tomcat 5.5.x, versions 5.5.20 or later, you should set
                <span class="emphasis"><em>useSystemClassLoaderAsParent</em></span> to
                <code class="literal">false</code> to fix this problem:
                </p>
                <pre class="programlisting"><span class="hl-tag">&lt;Context</span> <span class="hl-attribute">path</span>=<span class="hl-value">"/myWebApp"</span> <span class="hl-attribute">docBase</span>=<span class="hl-value">"/my/webApp/location"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;Loader</span>
        <span class="hl-attribute">loaderClass</span>=<span class="hl-value">"org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"</span>
            <span class="bold"><strong>useSystemClassLoaderAsParent="false"</strong></span>/&gt;
<span class="hl-tag">&lt;/Context&gt;</span></pre><p>This setting is not needed on Tomcat 6 or higher.</p>
              </li></ol></div>

            </li></ul></div>

          <p>Alternatively, consider the use of the Spring-provided generic
          VM agent, to be specified in Tomcat's launch script (see above).
          This will make instrumentation available to all deployed web
          applications, no matter what ClassLoader they happen to run on.</p>
        </div>

        <div class="section" title="WebLogic, WebSphere, OC4J, Resin, GlassFish, JBoss"><div class="titlepage"><div><div><h5 class="title"><a name="aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss"></a>WebLogic, WebSphere, OC4J, Resin, GlassFish, JBoss</h5></div></div></div>
          

          <p>Recent versions of BEA WebLogic (version 10 and above), IBM WebSphere Application Server (version 7 and above),
          Oracle Containers for Java EE (OC4J 10.1.3.1 and above), Resin (3.1 and above) and JBoss (5.x or above)
          provide a ClassLoader that is capable of local instrumentation.
          Spring's native LTW leverages such ClassLoaders to enable AspectJ weaving.
          You can enable LTW by simply activating load-time weaving
          as described earlier. Specifically, you do <span class="emphasis"><em>not</em></span>
          need to modify the launch script to add
          <code class="literal">-javaagent:path/to/spring-instrument.jar</code>.</p>

          <p>Note that GlassFish instrumentation-capable ClassLoader is available only in its EAR environment.
          For GlassFish web applications, follow the Tomcat setup instructions as outlined above.</p>

          <p>Note that on JBoss 6.x, the app server scanning needs to be disabled to prevent it from loading the classes
          before the application actually starts. A quick workaround is to add to your artifact a file named
          <code class="filename">WEB-INF/jboss-scanning.xml</code> with the following content:</p>

          <pre class="programlisting"><span class="hl-tag">&lt;scanning</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"urn:jboss:scanning:1.0"</span><span class="hl-tag">/&gt;</span></pre>
          </div>

        <div class="section" title="Generic Java applications"><div class="titlepage"><div><div><h5 class="title"><a name="aop-aj-ltw-environment-generic"></a>Generic Java applications</h5></div></div></div>
          

          <p>When class instrumentation is required in environments that do not support or
          are not supported by the existing <code class="classname">LoadTimeWeaver</code>
          implementations,
          a JDK agent can be the only solution. For such cases, Spring
          provides <code class="classname">InstrumentationLoadTimeWeaver</code>,
          which requires a Spring-specific (but very general) VM agent,
          <code class="filename">org.springframework.instrument-{version}.jar</code>
          (previously named <code class="filename">spring-agent.jar</code>).</p>

          <p>To use it, you must start the virtual machine with the Spring agent, by
          supplying the following JVM options:</p>
          <pre class="programlisting">-javaagent:/path/to/org.springframework.instrument-{version}.jar</pre>

          <p>
          Note that this requires modification of the VM launch script which may prevent you from using this in application server
          environments (depending on your operation policies). Additionally, the JDK agent will instrument the <span class="emphasis"><em>entire</em></span>
          VM which can prove expensive.</p>
          <p>For performance reasons, it is recommended to use this configuration only if your target environment
          (such as <a class="ulink" href="http://www.eclipse.org/jetty/" target="_top">Jetty</a>) does not have (or does not support) a dedicated LTW.</p>
        </div>

      </div>
    </div>
  </div>

  <div class="section" title="9.9&nbsp;Further Resources"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-resources"></a>9.9&nbsp;Further Resources</h2></div></div></div>
    

    <p>More information on AspectJ can be found on the <a class="ulink" href="http://www.eclipse.org/aspectj" target="_top">AspectJ website</a>.</p>

    <p>The book <span class="emphasis"><em>Eclipse AspectJ</em></span> by Adrian Colyer et.
    al. (Addison-Wesley, 2005) provides a comprehensive introduction and
    reference for the AspectJ language.</p>

    <p>The book <span class="emphasis"><em>AspectJ in Action</em></span> by Ramnivas Laddad
    (Manning, 2003) comes highly recommended; the focus of the book is on
    AspectJ, but a lot of general AOP themes are explored (in some depth).</p>
  </div>

</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="expressions.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-core.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="aop-api.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8.&nbsp;Spring Expression Language (SpEL)&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;10.&nbsp;Spring AOP APIs</td></tr></table></div></body></html>